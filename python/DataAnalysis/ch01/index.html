
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://huyuhui001.github.io/mySite/index.html/python/DataAnalysis/ch01/">
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-8.1.9">
    
    
      
        <title>Ch01 - My Memo</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.2b4465f4.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.e6a45f82.min.css">
        
          
          
          <meta name="theme-color" content="#2094f3">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue" data-md-color-accent="deep-blue">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#4numpy" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="My Memo" class="md-header__button md-logo" aria-label="My Memo" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            My Memo
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Ch01
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="My Memo" class="md-nav__button md-logo" aria-label="My Memo" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    My Memo
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../linux/" class="md-nav__link">
        Linux
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        Python
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../about/" class="md-nav__link">
        About
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#4numpy" class="md-nav__link">
    第4章：NumPy基础：数组与向量化计算
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#numpy-ndarry" class="md-nav__link">
    NumPy ndarry：多维数组对象
  </a>
  
    <nav class="md-nav" aria-label="NumPy ndarry：多维数组对象">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ndarray-n-" class="md-nav__link">
    ndarray: N-维数组对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numpy" class="md-nav__link">
    NumPy数组算术
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    基础索引与切片
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    布尔索引
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    神奇索引
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    数组转置和换轴
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    通用函数：快速的逐元素数组函数
  </a>
  
    <nav class="md-nav" aria-label="通用函数：快速的逐元素数组函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ufuncndarray" class="md-nav__link">
    通用函数，也可以称为ufunc，是一种在ndarray数据中进行逐元素操作的函数。
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    使用数组进行面向数组编程
  </a>
  
    <nav class="md-nav" aria-label="使用数组进行面向数组编程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    将条件逻辑作为数组操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    数学和统计方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    基础数组统计方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    布尔值数组的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    唯一值与其他集合逻辑
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    使用数组进行文件输入和输出
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#numpylinalg" class="md-nav__link">
    线性代数 (numpy.linalg)
  </a>
  
    <nav class="md-nav" aria-label="线性代数 (numpy.linalg)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diag" class="md-nav__link">
    diag：将一个方阵的对角（或非对角）元素作为一维数组返回，或者将一维数组转换成一个方阵，并且在非对角线上有零点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dot" class="md-nav__link">
    dot：矩阵点乘
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trace" class="md-nav__link">
    trace：计算对角元素和
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#det" class="md-nav__link">
    det：计算矩阵的行列式（方阵）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig" class="md-nav__link">
    eig：计算方阵的特征值和特征向量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inv" class="md-nav__link">
    inv：计算方阵的逆矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinvmoore-penrose-" class="md-nav__link">
    pinv：计算矩阵的Moore-Penrose伪逆(摩尔－彭若斯广义逆)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qrqr" class="md-nav__link">
    qr：计算QR分解
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svdsvd" class="md-nav__link">
    svd：计算奇异值分解（SVD）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solvexax-ba" class="md-nav__link">
    solve：求解x的线性系统Ax = b，其中A是方阵
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#0-1" class="md-nav__link">
    [[0. 1.]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-1" class="md-nav__link">
    [1. 1.]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-1" class="md-nav__link">
    [2. 1.]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-1" class="md-nav__link">
    [3. 1.]]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#078583658-027462104-053027675-062675004" class="md-nav__link">
    [[ 0.78583658 -0.27462104 -0.53027675 -0.62675004]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#039054781-120503691-00057432-017243182" class="md-nav__link">
    [ 0.39054781  1.20503691 -0.0057432   0.17243182]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-041516669-093335854-001996088-012707275" class="md-nav__link">
    [-0.41516669 -0.93335854  0.01996088 -0.12707275]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#042952379-256998319-014848737-042871493" class="md-nav__link">
    [ 0.42952379  2.56998319  0.14848737 -0.42871493]]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30-30-30" class="md-nav__link">
    随机步中计算出30或-30的最小穿越时间， 是否连续在同一方向走了30步
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30argmax1" class="md-nav__link">
    使用布尔值数组来选出绝对步数超过30的步所在的行，并使用argmax从轴向1上获取穿越时间
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                

<h3 id="4numpy">第4章：NumPy基础：数组与向量化计算</h3>
<ul>
<li>NumPy ndarry：多维数组对象</li>
<li>通用函数：快速的逐元素数组函数</li>
<li>使用数组进行面向数组编程</li>
<li>使用数组进行文件输入和输出</li>
<li>线性代数</li>
<li>伪随机数生成</li>
<li>示例：随机漫步</li>
</ul>
<h3 id="numpy-ndarry">NumPy ndarry：多维数组对象</h3>
<p>约定</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
</code></pre>
<h4 id="ndarray-n-">ndarray: N-维数组对象</h4>
<p>一个ndarray是一个通用的多维同类数据容器，也就是说，它包含的每一个元素均为相同类型；\
每一个数组都有一个shape属性，用来表征数组每一维度的数量；\
每一个数组都有一个dtype属性，用来描述数组的数据类型；</p>
<p>下面是标准数组的生成函数
* array: 将输入数据（列表、元组、数组，其他序列）转换为ndarray，如果不显式指明数据类型，将自动推断；默认复制所有的输入数据。
* asarray：将输入转换为ndarray，但如果输入已经是ndarray则不再复制。
* arange：Python内置函数range的数组版，返回一个数组。</p>
<pre><code>data01 = np.random.randn(2, 3)  # 生成一个小的随机数组
print(data01)
print(data01 * 10)  # 给data加上一个数学操作, 所有的元素都同时乘以了10
print(data01 + data01)  # 给data加上一个数学操作, 数组中的对应元素进行了相加

print(data01.shape)  # (2, 3)
print(data01.dtype)  # float64
</code></pre>
<p>生成ndarray
在本书中，当你看到“数组”、“NumPy数组”或“ndarray”时，他们都表示同一个对象：ndarray对象</p>
<pre><code>data02 = [6, 7.5, 8, 0, 1]
print(data02)
# [6, 7.5, 8, 0, 1]

array01 = np.array(data02)
print(&quot;样本矩阵 \n&quot;, array01)
# [6.  7.5 8.  0.  1. ]

print(&quot;数组维度&quot;, array01.ndim)  # 1  一维数组
print(&quot;矩阵形状&quot;, array01.shape)  # (5, )  一行五列
print(&quot;矩阵数据类型&quot;, array01.dtype)  # float64  除非显式地指定，否则np.array会自动推断生成数组的数据类型

data03 = [[1, 2, 3, 4], [5, 6, 7, 8]]
array02 = np.array(data03)  # 嵌套序列，例如同等长度的列表，将会自动转换成多维数组
print(&quot;样本矩阵 \n&quot;, array02)

print(&quot;数组维度&quot;, array02.ndim)
print(&quot;矩阵形状&quot;, array02.shape)
print(&quot;矩阵数据类型&quot;, array02.dtype)

print(&quot;矩阵0轴向求和&quot;, array02.sum(axis=0))
print(&quot;矩阵1轴向求和&quot;, array02.sum(axis=1))

# 样本矩阵
#  [[1 2 3 4]
#  [5 6 7 8]]
# 数组维度 2
# 矩阵形状 (2, 4)
# 矩阵数据类型 int64
# 矩阵0轴向求和 [ 6  8 10 12]
# 矩阵1轴向求和 [10 26]


array03 = array02.astype(np.float64)  # 使用astype方法显式地转换数组的数据类型. 使用astype时总是生成一个新的数组，即使你传入的dtype与之前一样。
print(array03.dtype)  # float64
print(array03)
# [[1. 2. 3. 4.]
#  [5. 6. 7. 8.]]
</code></pre>
<p>zeros可以一次性创造全0数组。</p>
<pre><code>print(np.zeros(10))
# [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
</code></pre>
<p>ones可以一次性创造全1数组。</p>
<pre><code>print(np.ones((3, 5)))  # 注意，传参shape是一个元组
# [[1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]]
</code></pre>
<p>empty可以创建一个没有初始化数值的数组。 \
使用np.empty来生成一个全0数组，并不安全，有些时候它可能会返回未初始化的垃圾数值</p>
<pre><code>print(np.empty((2, 3, 2)))
# [[[2.30116964e-316 0.00000000e+000]
#   [2.10077583e-312 6.79038654e-313]
#   [2.22809558e-312 2.14321575e-312]]
#
#  [[2.35541533e-312 6.79038654e-313]
#   [2.22809558e-312 2.14321575e-312]
#   [2.46151512e-312 2.41907520e-312]]]
</code></pre>
<h4 id="numpy">NumPy数组算术</h4>
<p>一个标量就是一个单独的数。 \
一个向量就是一列数，这些数是有序排列的。 \
矩阵是二维数组，其中的每一个元素被两个索引而非一个所确定。\
几何代数中定义的张量是基于向量和矩阵的推广，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。\
带有标量计算的算术操作，会把计算参数传递给数组的每一个元素。</p>
<pre><code>array04 = np.array([
    [1, 2, 3, 4, 5],
    [3, 4, 5, 6, 7],
    [5, 6, 7, 8, 9]
], dtype=int)
print(array04 + array04)
# [[ 2  4  6  8 10]
#  [ 6  8 10 12 14]
#  [10 12 14 16 18]]
print(array04 - array04)
# [[0 0 0 0 0]
#  [0 0 0 0 0]
#  [0 0 0 0 0]]
print(array04 * array04)
# [[ 1  4  9 16 25]
#  [ 9 16 25 36 49]
#  [25 36 49 64 81]]
print(array04 / array04)
# [[1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]]
print(1 / array04)
# [[1.         0.5        0.33333333 0.25       0.2       ]
#  [0.33333333 0.25       0.2        0.16666667 0.14285714]
#  [0.2        0.16666667 0.14285714 0.125      0.11111111]]
print(array04 == array04)  # 同尺寸数组之间的比较，会产生一个布尔值数组 不同尺寸的数组间的操作，将会用到广播特性
# [[ True  True  True  True  True]
#  [ True  True  True  True  True]
#  [ True  True  True  True  True]]
</code></pre>
<h4 id="_1">基础索引与切片</h4>
<p>数组的切片是原数组的视图。这意味着任何对于视图的修改都会反映到原数组上。\
数组的切片, 返回的对象是降低一个维度的数组</p>
<pre><code>array05 = np.arange(10)
print(array05)  # [0 1 2 3 4 5 6 7 8 9]
print(array05[5:8])  # [5 6 7]
array06 = array05[5:8]
array06[:] = 12  # 传入了一个数值给数组的切片，数值被传递给了整个切片。不写切片值的[:]将会引用数组的所有值
print(array06)  # [12 12 12]
print(array05)  # [ 0  1  2  3  4 12 12 12  8  9]  切片的修改会反映到原数组上。

array07 = np.array([
    [[0, 1, 2], [3, 4, 5], [6, 7, 8]],
    [[9, 0, 1], [2, 3, 4], [5, 6, 7]],
    [[8, 9, 0], [1, 2, 3], [4, 5, 6]],
])  # 输出3维矩阵，3行3列，共9个元素，每个元素是一个含3个元素的列表

print(array07[:2, 1:])  # 输出是一个3维矩阵，显示原矩阵的第1，2行的2，3列元素
print(array07[:2, 1:].shape)  # (2, 2, 3)
# [[[3 4 5] [6 7 8]]
#  [[2 3 4] [5 6 7]]]

print(array07[2])  # 降维，输出原矩阵的第3行
print(array07[2].shape)  # (3, 3)
print(array07[2, :])  # 降维，输出原矩阵的第3行
print(array07[2, :].shape)  # (3, 3)
# [[8 9 0] [1 2 3] [4 5 6]]

print(array07[2:, :])  # 输出原矩阵的第3行
print(array07[2:, :].shape)  # (1, 3, 3)
# [[[8 9 0] [1 2 3] [4 5 6]]]

print(array07[:, :2])  # 输出原矩阵的1，2列
print(array07[:, :2].shape)  # (3, 2, 3)
# [[[0 1 2] [3 4 5]]
#  [[9 0 1] [2 3 4]]
#  [[8 9 0] [1 2 3]]]

print(array07[1, :2])  # 降维，输出原矩阵的第2行前2个元素
print(array07[1, :2].shape)  # (2, 3)
# [[9 0 1] [2 3 4]]

print(array07[1:2, :2])  # 输出原矩阵的第2行前2个元素
print(array07[1:2, :2].shape)  # (1, 2, 3)
# [[[9 0 1] [2 3 4]]]

old_value = array07[2].copy()
print(old_value)
# [[8 9 0] [1 2 3] [4 5 6]]

array07[2] = 25  # 标量和数组都可以传递给 array07[2]
print(array07)
# [[[ 0  1  2] [ 3  4  5] [ 6  7  8]]
#  [[ 9  0  1] [ 2  3  4] [ 5  6  7]]
#  [[25 25 25] [25 25 25] [25 25 25]]]

array07[2] = old_value
print(array07)
# [[[0 1 2] [3 4 5] [6 7 8]]
#  [[9 0 1] [2 3 4] [5 6 7]]
#  [[8 9 0] [1 2 3] [4 5 6]]]
</code></pre>
<h4 id="_2">布尔索引</h4>
<p>使用布尔值索引选择数据时，总是生成数据的拷贝，即使返回的数组并没有任何变化 \
假设我们的数据都在数组中，并且数组中的数据是一些存在重复的人名 \
用randn函数生成一些标准正态(standard normal)分布的数据 \
假设每个人名都和data数组中的一行相对应，并且我们想要选中所有’Bob’对应的行</p>
<pre><code>names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='&lt;U4')
data = np.random.randn(7, 4)
print(names)
# ['Bob' 'Joe' 'Will' 'Bob' 'Will' 'Joe' 'Joe']
print(data)
# [[ 0.19233985 -0.22530396 -0.68464485  0.03961609]
#  [ 0.26189893 -0.86823302  0.72726864  0.16122945]
#  [-0.70564457  0.59179465  0.05572085 -1.79999391]
#  [-0.21465342  0.09236611  0.02982635 -1.08500576]
#  [ 1.17260699 -0.53172414  0.16224439  0.60597493]
#  [ 0.49879926 -0.64871168  0.57597095  0.86329327]
#  [-0.64902274 -0.92406415  0.40021708 -0.18222566]]
print(names == 'Bob')
# [ True False False  True False False False]
print(data[names == 'Bob'])  # 上述data输出的第一行和第三行对应于Bob为True，布尔值数组的长度必须和数组轴索引长度一致
# [[ 0.19233985 -0.22530396 -0.68464485  0.03961609]
#  [-0.21465342  0.09236611  0.02982635 -1.08500576]]
print(data[names == 'Bob', 2:])
# [[-0.68464485  0.03961609] [ 0.02982635 -1.08500576]]
print(data[names == 'Bob', 3])
# [ 0.03961609 -1.08500576]
</code></pre>
<p>使用！=或在条件表达式前使用～对条件取反, 选择除了’Bob’以外的其他数据</p>
<pre><code>print(names != 'Bob')
print(data[~(names == 'Bob')])
</code></pre>
<p>选择三个名字中的两个时，可以对多个布尔值条件进行联合，使用数学操作符如&amp;（and）和|（or）</p>
<pre><code>mask = (names == 'Bob') | (names == 'Will')
print(mask)
# [ True False  True  True  True False False]

data[names == 'Joe'] = 7
print(data)
# [[ 1.12584226 -1.09988707  0.49842702  0.76308186]
#  [ 7.          7.          7.          7.        ]
#  [ 1.54212949 -0.34487439 -1.47775736 -0.25724376]
#  [ 0.60943059 -0.0164697   0.26681455 -1.70871624]
#  [ 0.28010374 -0.32339505 -0.95289544  2.76739316]
#  [ 7.          7.          7.          7.        ]
#  [ 7.          7.          7.          7.        ]]
</code></pre>
<h4 id="_3">神奇索引</h4>
<p>神奇索引是NumPy中的术语，用于描述使用整数数组进行数据索引。 \
神奇索引与切片不同，它总是将数据复制到一个新的数组中。 \
假设有一个8×4的数组 </p>
<pre><code>array08 = np.empty((8, 4))
for i in range(8):
    array08[i] = i

print(array08)
# [[0. 0. 0. 0.]
#  [1. 1. 1. 1.]
#  [2. 2. 2. 2.]
#  [3. 3. 3. 3.]
#  [4. 4. 4. 4.]
#  [5. 5. 5. 5.]
#  [6. 6. 6. 6.]
#  [7. 7. 7. 7.]]
print(array08[[2, -2]])  # 输出第二行和倒数第二行，传递一个包含指明所需顺序的列表或数组，选出一个符合特定顺序的子集
# [[2. 2. 2. 2.]
#  [6. 6. 6. 6.]]


array09 = np.arange(32).reshape((8, 4))
print(array09)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]
#  [12 13 14 15]
#  [16 17 18 19]
#  [20 21 22 23]
#  [24 25 26 27]
#  [28 29 30 31]]
print(array09[[1, 5, 7, 2]])
# [[ 4  5  6  7]
#  [20 21 22 23]
#  [28 29 30 31]
#  [ 8  9 10 11]]
print(array09[[0, 3, 1, 2]])
# [[ 0  1  2  3]
#  [12 13 14 15]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]
print(array09[[1, 5, 7, 2], [0, 3, 1, 2]])
# 基于array09[[1, 5, 7, 2]]输出的矩阵，[0, 3, 1, 2]指定了结果集的每一行选取的值，比如，3代表结果集的第二行[20 21 22 23]的第三个元素（23）
# 或者，可以理解为，元素（1, 0）、（5, 3）、（7, 1）和（2, 2）被选中。
# [ 4 23 29 10]
</code></pre>
<h4 id="_4">数组转置和换轴</h4>
<p>数组拥有transpose方法，也有特殊的T属性</p>
<pre><code>array10 = np.arange(15).reshape((3, 5))
print(array10)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]]
print(array10.T)  # 矩阵转置
# [[ 0  5 10]
#  [ 1  6 11]
#  [ 2  7 12]
#  [ 3  8 13]
#  [ 4  9 14]]
print(array10.transpose())  # 矩阵转置
# [[ 0  5 10]
#  [ 1  6 11]
#  [ 2  7 12]
#  [ 3  8 13]
#  [ 4  9 14]]
print(array10.swapaxes(1, 0))  # 矩阵转置。默认是(0轴, 1轴)。swapaxes返回的是数据的视图，没有对数据进行复制。
# [[ 0  5 10]
#  [ 1  6 11]
#  [ 2  7 12]
#  [ 3  8 13]
#  [ 4  9 14]]
print(np.dot(array10, array10.T))  # 计算矩阵内积。矩阵内积参照向量内积的定义是：两个向量对应分量乘积之和。
# [[ 30  80 130]
#  [ 80 255 430]
#  [130 430 730]]
</code></pre>
<p>对于更高维度的数组，transpose方法可以接收包含轴编号的元组，用于置换轴</p>
<pre><code>array11 = np.arange(36).reshape((3, 3, 4))
print(array11)
# [[[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]]
#
#  [[12 13 14 15]
#   [16 17 18 19]
#   [20 21 22 23]]
#
#  [[24 25 26 27]
#   [28 29 30 31]
#   [32 33 34 35]]]
print(array11.transpose((0, 1, 2)))  # 默认是(0轴, 1轴, 2轴)。所以输出原矩阵
# [[[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]]
#  [[12 13 14 15]
#   [16 17 18 19]
#   [20 21 22 23]]
#  [[24 25 26 27]
#   [28 29 30 31]
#   [32 33 34 35]]]
print(array11.transpose((1, 0, 2)))  # 原先的第二个轴变为第一个，原先的第一个轴变成了第二个，最后一个轴没有改变
# [[[ 0  1  2  3]
#   [12 13 14 15]
#   [24 25 26 27]]
#  [[ 4  5  6  7]
#   [16 17 18 19]
#   [28 29 30 31]]
#  [[ 8  9 10 11]
#   [20 21 22 23]
#   [32 33 34 35]]]
print(array11.swapaxes(1, 0))  # 同上transpose((1, 0, 2))
# [[[ 0  1  2  3]
#   [12 13 14 15]
#   [24 25 26 27]]
#  [[ 4  5  6  7]
#   [16 17 18 19]
#   [28 29 30 31]]
#  [[ 8  9 10 11]
#   [20 21 22 23]
#   [32 33 34 35]]]
print(array11.transpose((2, 1, 0)))
# [[[ 0 12 24]
#   [ 4 16 28]
#   [ 8 20 32]]
#  [[ 1 13 25]
#   [ 5 17 29]
#   [ 9 21 33]]
#  [[ 2 14 26]
#   [ 6 18 30]
#   [10 22 34]]
#  [[ 3 15 27]
#   [ 7 19 31]
#   [11 23 35]]]
</code></pre>
<h3 id="_5">通用函数：快速的逐元素数组函数</h3>
<h4 id="ufuncndarray">通用函数，也可以称为ufunc，是一种在ndarray数据中进行逐元素操作的函数。</h4>
<p>某些简单函数接收一个或多个标量数值，并产生一个或多个标量结果，而通用函数就是对这些简单函数的向量化封装。</p>
<p>一元通用函数
* abs、fabs：逐元素地计算整数、浮点数或复数的绝对值
* sqrt：计算每个元素的平方根（与arr<strong>0.5相等）
* square：计算每个元素的平方（与arr</strong>2相等）
* exp：计算以e为底, 数组元素为幂次的指数函数</p>
<p>二元通用函数
* add：将数组的对应元素相加。
* subtract：在第二个数组中，将第一个数组中包含的元素去除。
* multiply：将数组的对应元素相乘。
* divide，floor_divide：除、或整除（放弃余数）
* power：将第二个数组的元素作为第一个数组对应元素的幂次方。
* maximun、fmax：逐个元素计算最大值，fmax忽略NaN。
* minimum、fmin：逐个元素计算最小值，fmin忽略NaN。
* mod：按元素的求模计算（即求除法的余数）。
* copysign：将第一个数组的符号值改为第二个数组的符号值。
* greater、greater_euqal、less、less_equal、equal、not_euqal：进行逐个元素的比较，返回布尔值数组。
* logical_and、logical_or、logical_xor：进行逐个元素的逻辑操作。</p>
<pre><code>array12 = np.arange(10).reshape((2, 5))
print(array12)
# [[0 1 2 3 4]
#  [5 6 7 8 9]]
print(np.sqrt(array12))
# [[0.         1.         1.41421356 1.73205081 2.        ]
#  [2.23606798 2.44948974 2.64575131 2.82842712 3.        ]]
print(np.exp(array12))
# [[1.00000000e+00 2.71828183e+00 7.38905610e+00 2.00855369e+01 5.45981500e+01]
#  [1.48413159e+02 4.03428793e+02 1.09663316e+03 2.98095799e+03 8.10308393e+03]]

array13 = [1, 4, 5, 8, 9]
array14 = [2, 3, 6, 7, 10]
print(np.maximum(array13, array14))  # numpy.maximum逐个元素地将x和y中元素的最大值计算出来。
# [ 2  4  6  8 10]
print(np.add(array13, array14))  # numpy.maximum逐个元素地将x和y中元素的和计算出来。
# [ 3  7 11 15 19]


array15 = np.random.randn(7) * 5
print(array15)
# [-7.54395135 -0.065131    2.71582306  2.2432261  11.02637158  6.73968036  2.96895379]
remainder, whole_part = np.modf(array15)  # modf返回一个浮点值数组的小数部分和整数部分
print(remainder)
# [-0.54395135 -0.065131    0.71582306  0.2432261   0.02637158  0.73968036  0.96895379]
print(whole_part)
# [-7. -0.  2.  2. 11.  6.  2.]
</code></pre>
<h3 id="_6">使用数组进行面向数组编程</h3>
<p>利用数组表达式来替代显式循环的方法，称为向量化。\
向量化的数组操作会比纯Python的等价实现在速度上快一到两个数量级（甚至更多） </p>
<pre><code>array = np.arange(-5, 5, 1, dtype=int)
print(&quot;样本矩阵 \n&quot;, array)
xs, ys = np.meshgrid(array, array)  # np.meshgrid函数接收两个一维数组，并根据两个数组的所有(x, y)对生成一个二维矩阵
print(&quot;生成x轴向2维矩阵 \n&quot;, xs)
print(&quot;生成y轴向2维矩阵 \n&quot;, ys)
# 样本矩阵
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
# 生成x轴向2维矩阵
#  [[-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]
#  [-5 -4 -3 -2 -1  0  1  2  3  4]]
# 生成y轴向2维矩阵
#  [[-5 -5 -5 -5 -5 -5 -5 -5 -5 -5]
#  [-4 -4 -4 -4 -4 -4 -4 -4 -4 -4]
#  [-3 -3 -3 -3 -3 -3 -3 -3 -3 -3]
#  [-2 -2 -2 -2 -2 -2 -2 -2 -2 -2]
#  [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
#  [ 0  0  0  0  0  0  0  0  0  0]
#  [ 1  1  1  1  1  1  1  1  1  1]
#  [ 2  2  2  2  2  2  2  2  2  2]
#  [ 3  3  3  3  3  3  3  3  3  3]
#  [ 4  4  4  4  4  4  4  4  4  4]]
</code></pre>
<pre><code>z = np.sqrt(xs ** 2 + ys ** 2)
print(&quot;样本矩阵 \n&quot;, z)

plt.imshow(z, cmap=plt.cm.gray)  # 使用matplotlib来生成这个二维数组的可视化
print(plt.colorbar)  # &lt;function colorbar at 0x7f9c91193f70&gt;
print(plt.title(&quot;Image plot of $\sqrt{x^2 + y^2}$ for a grid of values&quot;))
# Text(0.5, 1.0, 'Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values')
plt.show()  # 输出图像
# 样本矩阵
#  [[7.07106781 6.40312424 5.83095189 5.38516481 5.09901951 5.  5.09901951 5.38516481 5.83095189 6.40312424]
#  [6.40312424 5.65685425 5.         4.47213595 4.12310563 4.  4.12310563 4.47213595 5.         5.65685425]
#  [5.83095189 5.         4.24264069 3.60555128 3.16227766 3.  3.16227766 3.60555128 4.24264069 5.        ]
#  [5.38516481 4.47213595 3.60555128 2.82842712 2.23606798 2.  2.23606798 2.82842712 3.60555128 4.47213595]
#  [5.09901951 4.12310563 3.16227766 2.23606798 1.41421356 1.  1.41421356 2.23606798 3.16227766 4.12310563]
#  [5.         4.         3.         2.         1.         0.  1.         2.         3.         4.        ]
#  [5.09901951 4.12310563 3.16227766 2.23606798 1.41421356 1.  1.41421356 2.23606798 3.16227766 4.12310563]
#  [5.38516481 4.47213595 3.60555128 2.82842712 2.23606798 2.  2.23606798 2.82842712 3.60555128 4.47213595]
#  [5.83095189 5.         4.24264069 3.60555128 3.16227766 3.  3.16227766 3.60555128 4.24264069 5.        ]
#  [6.40312424 5.65685425 5.         4.47213595 4.12310563 4.  4.12310563 4.47213595 5.         5.65685425]]
</code></pre>
<h4 id="_7">将条件逻辑作为数组操作</h4>
<p>numpy.where函数是三元表达式x if condition else y的向量化版本 \
np.where的第二个和第三个参数并不需要是数组，它们可以是标量。\
where在数据分析中的一个典型用法是根据一个数组来生成一个新的数组。\</p>
<p>假设我们有一个布尔值数组和两个数值数组 \
假设cond中的元素为True时，我们取xarr中的对应元素值，否则取yarr中的元素。</p>
<pre><code>xarray = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarray = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
cond = np.array([True, False, True, True, False])
</code></pre>
<p>通过列表推导式来实现 \
缺点: 首先，如果数组很大的话，速度会很慢（因为所有的工作都是通过解释器解释Python代码完成）。其次，当数组是多维时，就无法凑效了。</p>
<pre><code>result = [(x if c else y) for x, y, c in zip(xarray, yarray, cond)]  # 通过列表推导式来实现
print(result)  # [1.1, 2.2, 1.3, 1.4, 2.5]
</code></pre>
<p>通过np.where来实现</p>
<pre><code>result = np.where(cond, xarray, yarray)
print(result)  # [1.1 2.2 1.3 1.4 2.5]
</code></pre>
<p>假设有一个随机生成的矩阵数据，使用np.where实现替换</p>
<pre><code>array = np.random.randn(4, 4)
print(&quot;样本矩阵 \n&quot;, array)
print(&quot;矩阵元素是否大于0 \n&quot;, array &gt; 0)
result03 = np.where(array &gt; 0, 2, -2)  # 将其中的正值都替换为2，将所有的负值替换为-2
print(&quot;将其中的正值都替换为2，将所有的负值替换为-2 \n&quot;, result03)
result04 = np.where(array &gt; 0, 2, array)  # 仅将其中的正值都替换为2
print(&quot;仅将其中的正值都替换为2 \n&quot;, result04)
# 样本矩阵
#  [[-0.57177422 -0.34917512  2.20268075  1.99959296]
#  [ 0.67966599  2.67915099 -0.40528454 -0.80339907]
#  [-0.74406888  2.33802717 -0.74582936  0.59347128]
#  [ 0.68624473  0.65953112 -0.40871415 -0.68698878]]
# 矩阵元素是否大于0
#  [[False False  True  True]
#  [ True  True False False]
#  [False  True False  True]
#  [ True  True False False]]
# 将其中的正值都替换为2，将所有的负值替换为-2
#  [[-2 -2  2  2]
#  [ 2  2 -2 -2]
#  [-2  2 -2  2]
#  [ 2  2 -2 -2]]
# 仅将其中的正值都替换为2
#  [[-0.57177422 -0.34917512  2.          2.        ]
#  [ 2.          2.         -0.40528454 -0.80339907]
#  [-0.74406888  2.         -0.74582936  2.        ]
#  [ 2.          2.         -0.40871415 -0.68698878]]
</code></pre>
<h4 id="_8">数学和统计方法</h4>
<p>计算整个数组统计值或关于轴向数据的数学函数 \
可以使用聚合函数（通常也叫缩减函数），比如sum、mean和std（标准差），既可以直接调用数组实例的方法，也可以使用顶层的NumPy函数 \
举例 \
生成了一些正态分布的随机数，并计算部分聚合统计数据 </p>
<pre><code>array = np.random.randn(5, 4)
print(&quot;样本矩阵 \n&quot;, array)  # 输出矩阵有2个轴，0轴（4个元素）和1轴（5个元素）

print(&quot;矩阵元素平均值&quot;, array.mean())  # 计算矩阵元素平均值
print(&quot;矩阵元素平均值&quot;, np.mean(array))

print(&quot;矩阵元素和&quot;, array.sum())  # 计算矩阵元素和
print(&quot;矩阵元素和&quot;, np.sum(array))

print(&quot;0轴向的累和&quot;, array.sum(axis=0))  # 表示“计算0轴向的累和”
print(&quot;1轴向的累和&quot;, array.sum(axis=1))  # 表示“计算0轴向的累和”

print(&quot;1轴向的平均值&quot;, array.mean(axis=1))  # 表示“计算1轴向的平均值”

# 样本矩阵  shape=(5, 4)  0轴向5个元素, 1轴向4个元素
#  [[ 0.32532911 -0.00177984 -1.59432632  1.58375133]
#  [ 1.48921763  0.25202456  0.44076148 -1.02277289]
#  [-0.73490219  0.19197171 -0.22374362  0.52610852]
#  [-1.03531076  1.0595528  -0.11566501  0.34063544]
#  [-0.2122241  -0.81348187  1.70989712 -0.00732696]]
# 矩阵元素平均值 0.10788580775057008
# 矩阵元素平均值 0.10788580775057008
# 矩阵元素和 2.1577161550114017
# 矩阵元素和 2.1577161550114017
# 0轴向的累和 [-0.16789031  0.68828737  0.21692365  1.42039545]
# 1轴向的累和 [ 0.31297429  1.15923078 -0.24056558  0.24921247  0.67686419]
# 1轴向的平均值 [ 0.07824357  0.28980769 -0.06014139  0.06230312  0.16921605]
</code></pre>
<h4 id="_9">基础数组统计方法</h4>
<pre><code>array = np.array([
    [1, 2, 3, 4, 5],
    [3, 4, 5, 6, 7],
    [5, 6, 7, 8, 9]
], dtype=int)
print(&quot;样本矩阵 \n&quot;, array)
print(&quot;轴向求和&quot;, array.sum())
print(&quot;轴向求和&quot;, array.sum(axis=0))
print(&quot;数学平均&quot;, array.mean())
print(&quot;轴向数学平均&quot;, array.mean(axis=0))
print(&quot;标准差&quot;, array.std(), &quot;方差&quot;, array.var())
print(&quot;轴向标准差&quot;, array.std(axis=0), &quot;轴向方差&quot;, array.var(axis=0))
print(&quot;最小值&quot;, array.min(), &quot;最大值&quot;, array.max())
print(&quot;轴向最小值&quot;, array.min(axis=0), &quot;轴向最大值&quot;, array.max(axis=0))
print(&quot;最小值位置&quot;, array.argmin(), &quot;最大值位置&quot;, array.argmax())
print(&quot;轴向最小值位置&quot;, array.argmin(axis=0), &quot;轴向最大值位置&quot;, array.argmax(axis=0))
print(&quot;累积和 \n&quot;, array.cumsum())
print(&quot;轴向累积和 \n&quot;, array.cumsum(axis=1))
print(&quot;累积乘积 \n&quot;, array.cumprod())
print(&quot;轴向累积乘积 \n&quot;, array.cumprod(axis=1))
# 样本矩阵
#  [[1 2 3 4 5]
#  [3 4 5 6 7]
#  [5 6 7 8 9]]
# 轴向求和 75
# 轴向求和 [ 9 12 15 18 21]
# 数学平均 5.0
# 轴向数学平均 [3. 4. 5. 6. 7.]
# 标准差 2.160246899469287 方差 4.666666666666667
# 轴向标准差 [1.63299316 1.63299316 1.63299316 1.63299316 1.63299316] 轴向方差 [2.66666667 2.66666667 2.66666667 2.66666667 2.66666667]
# 最小值 1 最大值 9
# 轴向最小值 [1 2 3 4 5] 轴向最大值 [5 6 7 8 9]
# 最小值位置 0 最大值位置 14
# 轴向最小值位置 [0 0 0 0 0] 轴向最大值位置 [2 2 2 2 2]
# 累积和
#  [ 1  3  6 10 15 18 22 27 33 40 45 51 58 66 75]
# 轴向累积和
#  [[ 1  3  6 10 15]
#  [ 3  7 12 18 25]
#  [ 5 11 18 26 35]]
# 累积乘积
#  [         1          2          6         24        120        360
#        1440       7200      43200     302400    1512000    9072000
#    63504000  508032000 4572288000]
# 轴向累积乘积
#  [[    1     2     6    24   120]
#  [    3    12    60   360  2520]
#  [    5    30   210  1680 15120]]
</code></pre>
<h4 id="_10">布尔值数组的方法</h4>
<pre><code>array = np.random.randn(100)
result = (array &gt; 0).sum()  # 计算正值的个数
print(result)  # 59
</code></pre>
<p>布尔值数组，有两个非常有用的方法any和all。
* any检查数组中是否至少有一个True，
* all检查是否每个值都是True</p>
<pre><code>bools = np.array([False, False, True, False])
print(bools.any())  # True
print(bools.all())  # False
</code></pre>
<h4 id="_11">排序</h4>
<p>和Python的内建列表类型相似，NumPy数组可以使用sort方法按位置排序。 \
顶层的np.sort方法返回的是已经排序好的数组拷贝，而不是对原数组按位置排序。</p>
<pre><code>array = np.random.randn(6)
print(&quot;样本矩阵&quot;, array)
array.sort()
print(&quot;排序后矩阵&quot;, array)
# 样本矩阵 [-0.03119521  0.01839556  0.79238537 -2.46622775  0.62522211  0.22430846]
# 样本矩阵排序 [-2.46622775 -0.03119521  0.01839556  0.22430846  0.62522211  0.79238537]
</code></pre>
<p>多维数组中根据传递的axis值，沿着轴向对每个一维数据段进行排序</p>
<pre><code>array = np.random.randn(5, 3)
print(&quot;样本矩阵 \n&quot;, array)
array.sort(1)
print(&quot;对1轴排序后矩阵 \n&quot;, array)
# 样本矩阵
#  [[-0.88057833  0.30160954 -2.08788148]
#  [ 0.27969618  0.62923028 -0.58157581]
#  [-1.87194465 -1.1102104   1.09589605]
#  [ 0.1467938  -1.01558304 -0.25905165]
#  [-0.17294279  0.62369511  0.17947059]]
# 对1轴排序后矩阵
#  [[-2.08788148 -0.88057833  0.30160954]
#  [-0.58157581  0.27969618  0.62923028]
#  [-1.87194465 -1.1102104   1.09589605]
#  [-1.01558304 -0.25905165  0.1467938 ]
#  [-0.17294279  0.17947059  0.62369511]]
</code></pre>
<h4 id="_12">唯一值与其他集合逻辑</h4>
<p>NumPy包含一些针对一维ndarray数组的基础集合操作。 \</p>
<p>np.unique(x, y)，计算x的唯一值，并排序</p>
<pre><code>names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
result = np.unique(names)
print(result)  # ['Bob' 'Joe' 'Will']
result = sorted(set(names))  # ['Bob', 'Joe', 'Will'] 纯Python实现
print(result)

inits = np.array([3, 3, 3, 2, 2, 1, 1, 5, 5])
result = np.unique(inits)
print(result)  # [1 2 3 5]

# np.in1d（x, y），计算x中的元素是否包含在y中，并返回一个布尔值数组
inits = np.array([3, 3, 3, 2, 2, 1, 1, 5, 5])
print(np.in1d(inits, [3, 4, 5]))  # [ True  True  True False False False False  True  True]

# np.intersect1d（x, y)，计算x和y的交集，并排序
print(np.intersect1d(inits, [3, 4, 5]))  # [3 5]

# np.union1d（x, y)，计算x和y的并集，并排序
print(np.union1d(inits, [3, 4, 5]))  # [1 2 3 4 5]

# np.setdiff1d（x, y)，差集，在x中但不在y中的元素
print(np.setdiff1d(inits, [3, 4, 5]))  # [1 2]

# np.setxor1d（x, y)，异或集，在x或者y中，但不属于x，y交集的元素
print(np.setxor1d(inits, [3, 4, 5]))   # [1 2 4]
</code></pre>
<h3 id="_13">使用数组进行文件输入和输出</h3>
<p>NumPy可以在硬盘中将数据以文本或二进制文件的形式进行存入硬盘或由硬盘载入。\
在本节，只讨论NumPy的内建二进制格式，因为大部分用户更倾向于使用pandas或其他工具来载入文本或表格型数据\
np.save和np.load是高效存取硬盘数据的两大工具函数。\
数组在默认情况下是以未压缩的格式进行存储的，后缀名是.npy。</p>
<pre><code>import numpy as np

array1 = np.arange(10)
array2 = np.arange(15).reshape(3, 5)
array3 = np.arange(30).reshape(3, 2, 5)

print(array1)
# [0 1 2 3 4 5 6 7 8 9]
print(array2)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]]
print(array3)
# [[[ 0  1  2  3  4]
#   [ 5  6  7  8  9]]
#  [[10 11 12 13 14]
#   [15 16 17 18 19]]
#  [[20 21 22 23 24]
#   [25 26 27 28 29]]]

np.save('some_array', array1)  # 保存在代码当前路径。npy后缀名会被自动加上。
result = np.load('some_array.npy')
print(result)  # [0 1 2 3 4 5 6 7 8 9]

np.savez('some_array_archive.npz', a=array2, b=array3)
result = np.load('some_array_archive.npz')  # reslt是一个字典型的对象
print(result['b'])  # 载入单个数组
# [[[ 0  1  2  3  4]
#   [ 5  6  7  8  9]]
#  [[10 11 12 13 14]
#   [15 16 17 18 19]]
#  [[20 21 22 23 24]
#   [25 26 27 28 29]]]
</code></pre>
<h3 id="numpylinalg">线性代数 (numpy.linalg)</h3>
<p>参考链接：
* https://www.numpy.org.cn/reference/routines/linalg.html
* https://github.com/teadocs/numpy-cn
\
希腊字母: 
* Α   α   /'ælfə/        alpha
* Β   β   /'bi:tə/       beta
* Γ   γ   /'gæmə/        gamma
* Δ   δ   /'deltə/       delta
* Ε   ε   /'epsɪlɒn/     epsilon
* Ζ   ζ   /'zi:tə/       zeta
* Η   η   /'i:tə/        eta
* Θ   θ   /'θi:tə/       theta
* Ι   ι   /'aɪəʊtə/      iota
* Κ   κ   /'kæpə/        kappa
* ∧   λ   /'læmdə/       lambda
* Μ   μ   /mju:/         mu
* Ν   ν   /nju:/         nu
* Ξ   ξ   /ksi/          xi
* Ο   ο   /əuˈmaikrən/   omicron
* ∏   π   /paɪ/          pi
* Ρ   ρ   /rəʊ/          rho
* ∑   σ   /'sɪɡmə/       sigma
* Τ   τ   /tɔ:/          tau
* Υ   υ   /ˈipsɪlon/     upsilon
* Φ   φ   /faɪ/          phi
* Χ   χ   /kaɪ/          chi
* Ψ   ψ   /psaɪ/         psi
* Ω   ω   /'əʊmɪɡə/      omega</p>
<pre><code>import numpy as np
from numpy import linalg as LA
from numpy import *
from numpy.linalg import inv
import matplotlib.pyplot as plt
</code></pre>
<h4 id="diag">diag：将一个方阵的对角（或非对角）元素作为一维数组返回，或者将一维数组转换成一个方阵，并且在非对角线上有零点</h4>
<pre><code>a1 = np.arange(9, dtype=float).reshape((3, 3))
r1 = np.diag(a1)
r2 = np.diag(a1, k=1)
r3 = np.diag(a1, k=-1)
r4 = np.diag(np.diag(a1))  # 对角矩阵
print(&quot;样本矩阵 \n&quot;, a1)
print(&quot;矩阵对角线&quot;, r1)
print(&quot;矩阵对角线向上偏移&quot;, r2)
print(&quot;矩阵对角线向下偏移&quot;, r3)
print(&quot;对角矩阵 \n&quot;, r4)
# 样本矩阵
#  [[0. 1. 2.]
#   [3. 4. 5.]
#   [6. 7. 8.]]
# 矩阵对角线 [0. 4. 8.]
# 矩阵对角线向上偏移 [1. 5.]
# 矩阵对角线向下偏移 [3. 7.]
# 对角矩阵
#  [[0. 0. 0.]
#   [0. 4. 0.]
#   [0. 0. 8.]]
</code></pre>
<h4 id="dot">dot：矩阵点乘</h4>
<p>将向量中对应元素相乘，再相加所得。即普通的向量乘法运算。</p>
<pre><code>a1 = np.dot(3, 4)
print(a1)  # 12

a2 = np.arange(9, dtype=float).reshape((3, 3))
r2 = np.dot(a2, a2)
print(a2)
# [[0. 1. 2.]
#  [3. 4. 5.]
#  [6. 7. 8.]]
print(r2)
# [[ 15.  18.  21.]
#  [ 42.  54.  66.]
#  [ 69.  90. 111.]]

r3 = np.dot([2j, 3j], [2j, 3j])
print(r3)  # (-13+0j)
</code></pre>
<h4 id="trace">trace：计算对角元素和</h4>
<pre><code>a1 = np.arange(9, dtype=float).reshape((3, 3))
print(&quot;样本矩阵 \n&quot;, a1)

r1 = np.trace(a1)
print(&quot;对角线元素求和&quot;, r1)

a2 = np.arange(24, dtype=float).reshape((2, 3, 4))
r2 = np.trace(a2)
print(&quot;样本矩阵 \n&quot;, a2)
print(&quot;对角线元素求和&quot;, r2)

# 样本矩阵
#  [[0. 1. 2.]
#   [3. 4. 5.]
#   [6. 7. 8.]]
# 对角线元素求和 12.0
# 样本矩阵
#  [[[ 0.  1.  2.  3.]
#    [ 4.  5.  6.  7.]
#    [ 8.  9. 10. 11.]]
#
#   [[12. 13. 14. 15.]
#    [16. 17. 18. 19.]
#    [20. 21. 22. 23.]]]
# 对角线元素求和 [16. 18. 20. 22.]
</code></pre>
<h4 id="det">det：计算矩阵的行列式（方阵）</h4>
<ul>
<li>二阶行列式[[a, b], [c, d]]的值是ad - bc</li>
<li>三阶行列式 [[a, b, c], [d, e, f], [g, h, i]]的值是 aei + bfd + cdh - ceg - bdi - afh</li>
<li>三阶行列式的性质</li>
<li>性质1：行列式与它的转置行列式相等。</li>
<li>性质2：互换行列式的两行(列)，行列式变号。</li>
<li>推论：如果行列式有两行(列)完全相同，则此行列式为零。</li>
<li>性质3：行列式的某一行(列)中所有的元素都乘以同一数k，等于用数k乘此行列式。</li>
<li>推论：行列式中某一行(列)的所有元素的公因子可以提到行列式符号的外面。</li>
<li>性质4：行列式中如果有两行(列)元素成比例，则此行列式等于零。</li>
<li>性质5：把行列式的某一列(行)的各元素乘以同一数然后加到另一列(行)对应的元素上去，行列式不变。</li>
</ul>
<pre><code>a1 = np.array([[1, 2], [3, 4]])
r1 = np.linalg.det(a1)
print(&quot;二阶方阵 \n&quot;, a1)
print(&quot;二阶行列式的值&quot;, r1)
# 二阶方阵
#  [[1 2]
#   [3 4]]
# 二阶行列式的值 -2.0000000000000004
# 希腊字母
# α, β, γ,δ, ε, ζ, η, θ, ι, κ, λ, μ, ν,
# ξ, ο, π, ρ, ς, σ, τ, υ, φ, χ, ψ, ω,

a2 = np.arange(9).reshape(3, 3)
r2 = np.linalg.det(a2)
print(&quot;三阶方阵 \n&quot;, a2)
print(&quot;三阶行列式的值&quot;, r2)
# 三阶方阵
#  [[0 1 2]
#   [3 4 5]
#   [6 7 8]]
# 三阶行列式的值 0.0

a3 = np.arange(16).reshape(4, 4)
r3 = np.linalg.det(a3)
print(&quot;四阶方阵 \n&quot;, a3)
print(&quot;四阶行列式的值&quot;, r3)
# 四阶方阵
#  [[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]# 希腊字母
# α, β, γ,δ, ε, ζ, η, θ, ι, κ, λ, μ, ν,
# ξ, ο, π, ρ, ς, σ, τ, υ, φ, χ, ψ, ω,

#   [12 13 14 15]]
# 四阶行列式的值 0.0
</code></pre>
<h4 id="eig">eig：计算方阵的特征值和特征向量</h4>
<p>特征值与特征向量的定义\
设A是n阶方阵，若数λ和n维非零列向量x，使得Ax = λx成立，则称λ是方阵A的一个特征值，x为方阵A的对应于特征值λ的一个特征向量。\
A是方阵。（对于非方阵，是没有特征值的，但会有条件数。）\
特征向量x为非零列向量。</p>
<pre><code>v_eigenvectors, v_eigenvalues = LA.eig(np.diag((1, 2, 3)))
print(&quot;特征向量&quot;, v_eigenvectors)
print(&quot;特征值 \n&quot;, v_eigenvalues)
# 特征向量 [1. 2. 3.]
# 特征值
#  [[1. 0. 0.]
#   [0. 1. 0.]
#   [0. 0. 1.]]

v_eigenvectors, v_eigenvalues = LA.eig(np.array([[1, -1], [1, 1]]))
print(&quot;特征向量&quot;, v_eigenvectors)
print(&quot;特征值 \n&quot;, v_eigenvalues)
# 特征向量 [1.+1.j 1.-1.j]
# 特征值
#  [[0.70710678+0.j         0.70710678-0.j        ]
#   [0.        -0.70710678j 0.        +0.70710678j]]
</code></pre>
<h4 id="inv">inv：计算方阵的逆矩阵</h4>
<pre><code>a1 = np.array([[1, 2], [3, 4]])
r1 = inv(a1)
r2 = inv(np.matrix(a1))
print(&quot;原矩阵 \n&quot;, a1)
print(&quot;逆矩阵 \n&quot;, r1)
print(&quot;逆矩阵 \n&quot;, r2)
# 原矩阵
#  [[1 2]
#   [3 4]]
# 逆矩阵
#  [[-2.   1. ]
#   [ 1.5 -0.5]]
# 逆矩阵
#  [[-2.   1. ]
#   [ 1.5 -0.5]]
</code></pre>
<h4 id="pinvmoore-penrose-">pinv：计算矩阵的Moore-Penrose伪逆(摩尔－彭若斯广义逆)</h4>
<p>下面的例子检验 a * a+ * a == a 和 a+ * a * a+ == a+</p>
<pre><code>a = np.random.randn(9, 6)
B = np.linalg.pinv(a)
r1 = np.allclose(a, np.dot(a, np.dot(B, a)))
r2 = np.allclose(B, np.dot(B, np.dot(a, B)))
print(a)
print(B)
print(r1)  # True
print(r2)  # True
# a:
# [[-2.30316101 -0.63217332  1.24134743 -0.72492307  0.12456801 -0.14192548]
#  [ 1.37573495  0.07626697 -0.71870843  1.26824984 -0.79485727 -0.24630455]
#  [ 0.29003175 -1.23931665 -0.50864107 -0.31140718  0.45467649 -2.44973999]
#  [-0.70748664 -1.2995059   0.85126149 -1.10918804 -2.10042342  0.75942293]
#  [ 1.91765238  1.23892103  1.58516486 -1.65520154  0.11894439  0.84536298]
#  [ 1.03220791  0.1715148   0.85595408  0.58569706  1.34066384 -1.5782386 ]
#  [-0.54432889 -0.0114189   1.55403934  0.89852512  1.15586365 -0.30733805]
#  [-0.80874673  0.14602121  1.04680044  1.98722514  0.39766383  0.75178788]
#  [ 0.01664663  0.06243353 -0.50725334 -0.37707204 -1.76701091 -0.33866559]]
# B:
# [[-0.25055838  0.13963115  0.08990923  0.16280282  0.12997291  0.05088469 -0.01541299 -0.01656133 -0.21731387]
#  [ 0.22862622 -0.05108109 -0.2639602  -0.47835978  0.11776862  0.09324694  0.00436756 -0.00609393  0.61995597]
#  [ 0.10422554  0.03985857  0.00198025  0.15139023  0.17165026  0.15697725  0.17360246  0.13150089  0.08378135]
#  [-0.07021378  0.17665487 -0.04109252  0.0015022  -0.11998477  0.0543575   0.08649033  0.21190785  0.04065729]
#  [-0.08110336 -0.15274536  0.05601496 -0.07967802 -0.02454705 -0.04152356  0.00071268 -0.05981012 -0.43996066]
#  [-0.17998537 -0.03160871 -0.12587707  0.16856246  0.00565094 -0.21038026 -0.06060039  0.04322126 -0.42038066]]
</code></pre>
<h4 id="qrqr">qr：计算QR分解</h4>
<p>QR（正交三角）分解法是求一般矩阵全部特征值的最有效并广泛应用的方法。\
一般矩阵先经过正交相似变化成为Hessenberg矩阵，然后再应用QR方法求特征值和特征向量。\
它是将矩阵分解成一个正规正交矩阵Q与上三角形矩阵R，所以称为QR分解法。</p>
<pre><code>a = np.arange(9).reshape(3, 3)
q, r = np.linalg.qr(a)
print(&quot;原矩阵 \n&quot;, a)
print(&quot;正交矩阵 \n&quot;, q)
print(&quot;上三角矩阵 \n&quot;, r)
# 原矩阵
#  [[0 1 2]
#   [3 4 5]
#   [6 7 8]]
# 正交矩阵
#  [[ 0.          0.91287093  0.40824829]
#   [-0.4472136   0.36514837 -0.81649658]
#   [-0.89442719 -0.18257419  0.40824829]]
# 上三角矩阵
#  [[-6.70820393e+00 -8.04984472e+00 -9.39148551e+00]
#   [ 0.00000000e+00  1.09544512e+00  2.19089023e+00]
#   [ 0.00000000e+00  0.00000000e+00 -8.88178420e-16]]
</code></pre>
<h4 id="svdsvd">svd：计算奇异值分解（SVD）</h4>
<p>几何意义：SVD分解的几何意义是任何一个矩阵A在一系列旋转和平移下都能转化成一个对角矩阵∑ , 其中酉阵U, V的几何意义就是一系列旋转和平移的叠加。</p>
<pre><code>a = mat([[1, 2, 3],[4, 5, 6]])
U, sigma, V = np.linalg.svd(a)
print(&quot;原矩阵 \n&quot;, a)
print(&quot;左奇异值U \n&quot;, U)
print(&quot;奇异值Sigma \n&quot;, sigma)
print(&quot;右奇异值V \n&quot;, V)
# 原矩阵
#  [[1 2 3]
#   [4 5 6]]
# 左奇异值U
#  [[-0.3863177  -0.92236578]
#   [-0.92236578  0.3863177 ]]
# 奇异值Sigma
#  [9.508032   0.77286964]
# 右奇异值V
#  [[-0.42866713 -0.56630692 -0.7039467 ]
#   [ 0.80596391  0.11238241 -0.58119908]
#   [ 0.40824829 -0.81649658  0.40824829]]
</code></pre>
<h4 id="solvexax-ba">solve：求解x的线性系统Ax = b，其中A是方阵</h4>
<p>解方程组\
x + 2y = 1 \
3x + 5y = 2</p>
<p>```a = np.array([[1, 2], [3, 5]])
b = np.array([1, 2])
x = np.linalg.solve(a, b)
print(x)  # [-1.  1.]</p>
<pre><code>

#### lstsq：计算Ax = b的最小二乘解
用最小二乘法拟合数据得到一个形如y = mx + c的线性方程\
Return the least-squares solution to a linear matrix equation

</code></pre>
<p>x = np.array([0, 1, 2, 3])  # 原始数据点的横坐标
y = np.array([-1, 0.2, 0.9, 2.1])  # 原始数据点的纵坐标
print(x)  # [0 1 2 3]
print(y)  # [-1.   0.2  0.9  2.1]
A = np.vstack([x, np.ones(len(x))]).T  # 构造系数矩阵
print(A)</p>
<h1 id="0-1">[[0. 1.]</h1>
<h1 id="1-1">[1. 1.]</h1>
<h1 id="2-1">[2. 1.]</h1>
<h1 id="3-1">[3. 1.]]</h1>
<p>m, c = np.linalg.lstsq(A, y, rcond=None)[0]  # 解出斜率a和纵截距c
plt.plot(x, y, 'o', label='Original data', markersize=10)  # 做出原始数据散点图
plt.plot(x, m*x + c, 'r', label='Fitted line')  # 用上面解出的参数做出拟合曲线y=mx+c
plt.legend()
plt.show()</p>
<pre><code>


### 伪随机数生成
</code></pre>
<p>import numpy as np</p>
<pre><code>numpy.random模块填补了Python内建的random模块的不足，可以高效地生成多种概率分布下的完整样本值数组。\
numpy.random中的数据生成函数公用了一个全局的随机数种子。\
使用numpy.random.RandomState生成一个随机数生成器，使数据独立于其他的随机数状态\
通过np.random.seed更改NumPy的随机数种子。

#### numpy.random中的部分函数列表
* seed: 向随机数生成器传递随机状态种子
* permutation: 返回一个序列的随机排列，或者返回一个乱序的整数范围序列
* shuffle: 随机排列一个序列
* rand: 从均匀分布中抽取样本
* randint: 根据给定的由低到高的范围抽取随机整数
* randn: 从均值0方差1的正态分布中抽取样本(MATLAB型接口）
* binomial: 从二项分布中抽取样本
* normal: 从正态（高斯）分布中抽取样本
* beta从beta: 分布中抽取样本
* chisquare: 从卡方分布中抽取样本

例如，使用normal来获得一个4×4的正态分布样本数组，称为伪随机数
</code></pre>
<p>samples = np.random.normal(size=(4, 4))
print(samples)</p>
<h1 id="078583658-027462104-053027675-062675004">[[ 0.78583658 -0.27462104 -0.53027675 -0.62675004]</h1>
<h1 id="039054781-120503691-00057432-017243182">[ 0.39054781  1.20503691 -0.0057432   0.17243182]</h1>
<h1 id="-041516669-093335854-001996088-012707275">[-0.41516669 -0.93335854  0.01996088 -0.12707275]</h1>
<h1 id="042952379-256998319-014848737-042871493">[ 0.42952379  2.56998319  0.14848737 -0.42871493]]</h1>
<pre><code>
### 示例：随机漫步
</code></pre>
<p>import matplotlib.pyplot as plt
import numpy as np</p>
<p>nwalks = 5000
nsteps = 1000</p>
<p>draws = np.random.randint(0, 2, size=(nwalks, nsteps))  # 0或1
print("draws \n", draws)</p>
<p>steps = np.where(draws &gt; 0, 1, -1)  # 如果draws&gt;0， 则返回1，否则返回-1
print("steps \n", steps)</p>
<p>walks = steps.cumsum(1)  # 对1轴进行累计求和
print("walks \n", walks)</p>
<p>print("walks max", walks.max())  # 计算出这些随机步的最大值
print("walks min", walks.min())  # 计算出这些随机步的最小值</p>
<h1 id="30-30-30">随机步中计算出30或-30的最小穿越时间， 是否连续在同一方向走了30步</h1>
<h1 id="30argmax1">使用布尔值数组来选出绝对步数超过30的步所在的行，并使用argmax从轴向1上获取穿越时间</h1>
<p>hits30 = (np.abs(walks) &gt;= 30).any(1)
print("hits30", hits30)
print("hits30 sum", hits30.sum())
crossing_times = (np.abs(walks[hits30]) &gt;= 30).argmax(1)
print("hits30 cross time", crossing_times.mean())</p>
<p>plt.title("walk")
plt.plot(walks)
plt.show()
```</p>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../../assets/javascripts/workers/search.22074ed6.min.js"}</script>
    
    
      <script src="../../../assets/javascripts/bundle.960e086b.min.js"></script>
      
    
  </body>
</html>
<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://huyuhui001.github.io/mySite/python/DataAnalysis/ch07/ rel=canonical><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.3.0, mkdocs-material-7.3.6"><title>数据聚合与分组操作 - UPSkilling</title><link rel=stylesheet href=../../../assets/stylesheets/main.a57b2b03.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.3f5d1f46.min.css><meta name=theme-color content=#009485><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style><link rel=stylesheet href=../../../extra.css></head> <body dir=ltr data-md-color-scheme data-md-color-primary=teal data-md-color-accent=green> <script>function __prefix(e){return new URL("../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#_1 class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=UPSkilling class="md-header__button md-logo" aria-label=UPSkilling data-md-component=logo> <img src=../../../assets/logo.jpg alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> UPSkilling </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 数据聚合与分组操作 </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/huyuhui001/mySite title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> huyuhui001/mySite </div> </a> </div> </nav> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../.. class=md-tabs__link> UPSkilling </a> </li> <li class=md-tabs__item> <a href=../../../linux/Administration/01/ class=md-tabs__link> Linux </a> </li> <li class=md-tabs__item> <a href=../../../k8s/installation/single-local/ class=md-tabs__link> Kubernetes </a> </li> <li class=md-tabs__item> <a href=../../Foundation/ch00/ class="md-tabs__link md-tabs__link--active"> Python </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=UPSkilling class="md-nav__button md-logo" aria-label=UPSkilling data-md-component=logo> <img src=../../../assets/logo.jpg alt=logo> </a> UPSkilling </label> <div class=md-nav__source> <a href=https://github.com/huyuhui001/mySite title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> huyuhui001/mySite </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1 type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1> UPSkilling <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=UPSkilling data-md-level=1> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> UPSkilling </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. class=md-nav__link> Welcome </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2> Linux <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Linux data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Linux </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2_1 type=checkbox id=__nav_2_1> <label class=md-nav__link for=__nav_2_1> SUSE Linux Administration <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="SUSE Linux Administration" data-md-level=2> <label class=md-nav__title for=__nav_2_1> <span class="md-nav__icon md-icon"></span> SUSE Linux Administration </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../linux/Administration/01/ class=md-nav__link> Linux File System Overview </a> </li> <li class=md-nav__item> <a href=../../../linux/Administration/02/ class=md-nav__link> Useful Commands </a> </li> <li class=md-nav__item> <a href=../../../linux/Administration/03/ class=md-nav__link> Shell </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2_2 type=checkbox id=__nav_2_2> <label class=md-nav__link for=__nav_2_2> SUSE Enterprise Storage Foundation <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="SUSE Enterprise Storage Foundation" data-md-level=2> <label class=md-nav__title for=__nav_2_2> <span class="md-nav__icon md-icon"></span> SUSE Enterprise Storage Foundation </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../linux/SES/linux_ses_memo/ class=md-nav__link> SUSE Enterprise Storage Foundation </a> </li> <li class=md-nav__item> <a href=../../../linux/SES/linux_ses_demo/ class=md-nav__link> SUSE Enterprise Storage Basic Operation </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2_3 type=checkbox id=__nav_2_3> <label class=md-nav__link for=__nav_2_3> Linux SRE <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Linux SRE" data-md-level=2> <label class=md-nav__title for=__nav_2_3> <span class="md-nav__icon md-icon"></span> Linux SRE </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../linux/SRE/01-fundamentals/ class=md-nav__link> Linux Fundamentals </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3> Kubernetes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Kubernetes data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Kubernetes </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_1 type=checkbox id=__nav_3_1> <label class=md-nav__link for=__nav_3_1> Installation <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Installation data-md-level=2> <label class=md-nav__title for=__nav_3_1> <span class="md-nav__icon md-icon"></span> Installation </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/installation/single-local/ class=md-nav__link> Single Node Installation </a> </li> <li class=md-nav__item> <a href=../../../k8s/installation/multiple-local/ class=md-nav__link> Multiple Nodes Installation </a> </li> <li class=md-nav__item> <a href=../../../k8s/installation/aliyun-ubuntu/ class=md-nav__link> Installation on Aliyun ECS </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_2 type=checkbox id=__nav_3_2> <label class=md-nav__link for=__nav_3_2> Docker <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Docker data-md-level=2> <label class=md-nav__title for=__nav_3_2> <span class="md-nav__icon md-icon"></span> Docker </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/docker/ class=md-nav__link> Fundamentals </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_3 type=checkbox id=__nav_3_3> <label class=md-nav__link for=__nav_3_3> Foundamentals <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Foundamentals data-md-level=2> <label class=md-nav__title for=__nav_3_3> <span class="md-nav__icon md-icon"></span> Foundamentals </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/memo/ class=md-nav__link> Memo </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/overview/ class=md-nav__link> Overview </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/basics/ class=md-nav__link> kubectl basics </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_4 type=checkbox id=__nav_3_4> <label class=md-nav__link for=__nav_3_4> Core Kubernetes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Core Kubernetes" data-md-level=2> <label class=md-nav__title for=__nav_3_4> <span class="md-nav__icon md-icon"></span> Core Kubernetes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/pod/ class=md-nav__link> Pod </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/deployment/ class=md-nav__link> Deployment </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/service/ class=md-nav__link> Service </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_5 type=checkbox id=__nav_3_5> <label class=md-nav__link for=__nav_3_5> Application Modelling <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Application Modelling" data-md-level=2> <label class=md-nav__title for=__nav_3_5> <span class="md-nav__icon md-icon"></span> Application Modelling </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/namespace/ class=md-nav__link> Namespace </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/statefulset/ class=md-nav__link> StatefulSet </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/daemonset/ class=md-nav__link> DaemonSet </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/job/ class=md-nav__link> Job and Cronjob </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/configuration/ class=md-nav__link> Configuration </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/secrets/ class=md-nav__link> Secrets </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/persistence/ class=md-nav__link> Persistence </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/rbac/ class=md-nav__link> Role Based Access Control (RBAC) </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/ingress/ class=md-nav__link> Ingress </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_6 type=checkbox id=__nav_3_6> <label class=md-nav__link for=__nav_3_6> Advanced Kubernetes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Advanced Kubernetes" data-md-level=2> <label class=md-nav__title for=__nav_3_6> <span class="md-nav__icon md-icon"></span> Advanced Kubernetes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/scheduling/ class=md-nav__link> Scheduling </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/hpa/ class=md-nav__link> Horizontal Pod Autoscaling </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/policy/ class=md-nav__link> Policy </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/networkpolicy/ class=md-nav__link> Network Policy </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/clustermgt/ class=md-nav__link> Cluster Management </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_7 type=checkbox id=__nav_3_7> <label class=md-nav__link for=__nav_3_7> Operating Kubernetes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Operating Kubernetes" data-md-level=2> <label class=md-nav__title for=__nav_3_7> <span class="md-nav__icon md-icon"></span> Operating Kubernetes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/troubleshooting/ class=md-nav__link> Troubleshooting </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/healthcheck/ class=md-nav__link> Health Check </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/helming/ class=md-nav__link> Helming </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_8 type=checkbox id=__nav_3_8> <label class=md-nav__link for=__nav_3_8> Case Study <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Case Study" data-md-level=2> <label class=md-nav__title for=__nav_3_8> <span class="md-nav__icon md-icon"></span> Case Study </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/casestudy-operation-resources/ class=md-nav__link> Operations on Resources </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/casestudy-health-check/ class=md-nav__link> Health Check </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/casestudy-calico/ class=md-nav__link> Calico Installation </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/kyma/ class=md-nav__link> Kyma </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3_9 type=checkbox id=__nav_3_9> <label class=md-nav__link for=__nav_3_9> Demos <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Demos data-md-level=2> <label class=md-nav__title for=__nav_3_9> <span class="md-nav__icon md-icon"></span> Demos </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/demo/cap_on_kyma/ class=md-nav__link> Build CAP application on Kyma </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4> Python <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Python data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Python </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4_1 type=checkbox id=__nav_4_1> <label class=md-nav__link for=__nav_4_1> Python基础 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Python基础 data-md-level=2> <label class=md-nav__title for=__nav_4_1> <span class="md-nav__icon md-icon"></span> Python基础 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Foundation/ch00/ class=md-nav__link> 安装 </a> </li> <li class=md-nav__item> <a href=../../Foundation/ch01/ class=md-nav__link> 语言基础 </a> </li> <li class=md-nav__item> <a href=../../Foundation/ch02/ class=md-nav__link> 打包Packing和拆包Unpacking </a> </li> <li class=md-nav__item> <a href=../../Foundation/ch03/ class=md-nav__link> 函数及文件 </a> </li> <li class=md-nav__item> <a href=../../Foundation/ch04/ class=md-nav__link> 面向对象概念 </a> </li> <li class=md-nav__item> <a href=../../Foundation/ch05/ class=md-nav__link> 面向对象特性 </a> </li> <li class=md-nav__item> <a href=../../Foundation/Algorithms/ class=md-nav__link> 数据结构和算法 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4_2 type=checkbox id=__nav_4_2 checked> <label class=md-nav__link for=__nav_4_2> Python数据分析基础 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Python数据分析基础 data-md-level=2> <label class=md-nav__title for=__nav_4_2> <span class="md-nav__icon md-icon"></span> Python数据分析基础 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../ch01/ class=md-nav__link> NumPy基础 </a> </li> <li class=md-nav__item> <a href=../ch10/ class=md-nav__link> NumPy进阶 </a> </li> <li class=md-nav__item> <a href=../ch02/ class=md-nav__link> Pandas入门 </a> </li> <li class=md-nav__item> <a href=../ch03/ class=md-nav__link> 数据载入、存储及文件格式 </a> </li> <li class=md-nav__item> <a href=../ch04/ class=md-nav__link> 数据清洗与准备 </a> </li> <li class=md-nav__item> <a href=../ch05/ class=md-nav__link> 数据规整：连接、联合与重塑 </a> </li> <li class=md-nav__item> <a href=../ch06/ class=md-nav__link> 绘图与可视化 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> 数据聚合与分组操作 <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> 数据聚合与分组操作 </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#groupby class=md-nav__link> GroupBy机制 </a> <nav class=md-nav aria-label=GroupBy机制> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 分组机制 </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> 遍历各分组 </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> 选择一列或所有列的子集 </a> </li> <li class=md-nav__item> <a href=#series class=md-nav__link> 使用字典和Series分组 </a> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> 使用函数分组 </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> 根据索引层级分组 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> 数据聚合 </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> 逐列及多函数应用 </a> <nav class=md-nav aria-label=逐列及多函数应用> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_9 class=md-nav__link> 返回不含行索引的聚合数据 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#- class=md-nav__link> 应用：通用拆分-应用-联合 </a> <nav class=md-nav aria-label=应用：通用拆分-应用-联合> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_10 class=md-nav__link> 压缩分组键 </a> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> 分位数与桶分析 </a> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> 示例：使用指定分组值填充缺失值 </a> </li> <li class=md-nav__item> <a href=#_13 class=md-nav__link> 示例：随机采样与排列 </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> 示例：分组加权平均和相关性 </a> </li> <li class=md-nav__item> <a href=#_15 class=md-nav__link> 示例：逐组线性回归 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_16 class=md-nav__link> 数据透视表与交叉表 </a> <nav class=md-nav aria-label=数据透视表与交叉表> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_17 class=md-nav__link> 数据透视表 </a> </li> <li class=md-nav__item> <a href=#crosstab class=md-nav__link> 交叉表：crosstab </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../ch08/ class=md-nav__link> 时间序列 </a> </li> <li class=md-nav__item> <a href=../ch09/ class=md-nav__link> 高阶pandas </a> </li> <li class=md-nav__item> <a href=../ch11/ class=md-nav__link> Python建模库介绍 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4_3 type=checkbox id=__nav_4_3> <label class=md-nav__link for=__nav_4_3> Demos <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Demos data-md-level=2> <label class=md-nav__title for=__nav_4_3> <span class="md-nav__icon md-icon"></span> Demos </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Demo/CourseSystem/ class=md-nav__link> 选课系统 </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#groupby class=md-nav__link> GroupBy机制 </a> <nav class=md-nav aria-label=GroupBy机制> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 分组机制 </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> 遍历各分组 </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> 选择一列或所有列的子集 </a> </li> <li class=md-nav__item> <a href=#series class=md-nav__link> 使用字典和Series分组 </a> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> 使用函数分组 </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> 根据索引层级分组 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> 数据聚合 </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> 逐列及多函数应用 </a> <nav class=md-nav aria-label=逐列及多函数应用> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_9 class=md-nav__link> 返回不含行索引的聚合数据 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#- class=md-nav__link> 应用：通用拆分-应用-联合 </a> <nav class=md-nav aria-label=应用：通用拆分-应用-联合> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_10 class=md-nav__link> 压缩分组键 </a> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> 分位数与桶分析 </a> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> 示例：使用指定分组值填充缺失值 </a> </li> <li class=md-nav__item> <a href=#_13 class=md-nav__link> 示例：随机采样与排列 </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> 示例：分组加权平均和相关性 </a> </li> <li class=md-nav__item> <a href=#_15 class=md-nav__link> 示例：逐组线性回归 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_16 class=md-nav__link> 数据透视表与交叉表 </a> <nav class=md-nav aria-label=数据透视表与交叉表> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_17 class=md-nav__link> 数据透视表 </a> </li> <li class=md-nav__item> <a href=#crosstab class=md-nav__link> 交叉表：crosstab </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <a href=https://github.com/huyuhui001/mySite/edit/main/docs/python/DataAnalysis/ch07.md title="Edit this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg> </a> <h1 id=_1>数据聚合与分组操作<a class=headerlink href=#_1 title="Permanent link"> ¶</a></h1> <h2 id=groupby>GroupBy机制<a class=headerlink href=#groupby title="Permanent link"> ¶</a></h2> <div class=highlight><pre><span></span><code>import pandas as pd
import numpy as np
</code></pre></div> <h3 id=_2>分组机制<a class=headerlink href=#_2 title="Permanent link"> ¶</a></h3> <p>分组操作第一步，数据包含在pandas对象中，可以是Series、DataFrame或其他数据结构。之后根据提供的一个或多个键分离到各个组中。</p> <p>分组键可是多种形式的，并且键不一定是完全相同的类型(注意后面介绍的三个方法是可以产生用于分隔对象的值数组的快捷方式)：</p> <ul> <li>与需要分组的轴向长度一致的值列表或值数组。默认情况下，groupby在axis=0的轴向上分组。</li> <li>DataFrame的列名的值。</li> <li>可以将分组轴向上的值和分组名称相匹配的字典或Series。</li> <li>可以在轴索引或索引中的单个标签上调用的函数。</li> </ul> <p>请注意，分组键中的任何缺失值将被排除在结果之外。</p> <p>分离操作是在数据对象的特定轴向上进行的。例如，DataFrame可以在它的行方向（axis=0）或列方向（axis=1）进行分组。</p> <p>分组操作后，一个函数就可以应用到各个组中，产生新的值。最终，所有函数的应用结果会联合为一个结果对象。 <div class=highlight><pre><span></span><code>df = pd.DataFrame(
    {
        &#39;key1&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;],
        &#39;key2&#39;: [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;],
        &#39;data1&#39;: [1, 3, 5, 7, 9],
        &#39;data2&#39;: [2, 4, 6, 8, 10]
    }
)
</code></pre></div></p> <p>根据key1标签计算data1列的均值，方法一，访问<code>data1</code>并使用<code>key1</code>列（它是一个Series）调用<code>groupby</code>方法： <div class=highlight><pre><span></span><code>grouped = df[&#39;data1&#39;].groupby(df[&#39;key1&#39;])
print(grouped)  # &lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x7fdd2cb01430&gt;
</code></pre></div></p> <p><code>grouped</code>变量现在是一个<code>GroupBy</code>对象，它实际上还没有进行任何计算，拥有一些关于分组键df['key1']的一些中间数据的信息。</p> <p>下面对<code>grouped</code>对象做一些操作： <div class=highlight><pre><span></span><code>result = grouped.mean()  # 计算平均值
print(result)
# key1
# a    4.333333
# b    6.000000
# Name: data1, dtype: float64
grouped_means = df[&#39;data1&#39;].groupby([df[&#39;key1&#39;], df[&#39;key2&#39;]]).mean()
print(grouped_means)
# key1  key2
# a     one     5.0
#       two     3.0
# b     one     5.0
#       two     7.0
# Name: data1, dtype: float64
</code></pre></div></p> <p>上面例子使用了两个键对数据进行分组，并且结果Series现在拥有一个包含唯一键对的多层索引。</p> <p>下面对计算的平均值（mean）进行重塑（unstack）。 <div class=highlight><pre><span></span><code>print(grouped_means.unstack())
# key2  one  two
# key1
# a     5.0  3.0
# b     5.0  7.0
</code></pre></div></p> <p>分组信息通常包含在同一个DataFrame中。在这种情况下，可以传递列名（无论那些列名是字符串、数字或其他Python对象）作为分组键：</p> <p>下面例子中<code>df.groupby('key1').mean()</code>的结果里并没有<code>key2</code>列。这是因为<code>df['key2']</code>并不是数值数据，即<code>df['key2']</code>是一个冗余列，因此被排除在结果之外。 <div class=highlight><pre><span></span><code>result = df.groupby(&#39;key1&#39;).mean()
print(result)
#          data1     data2
# key1
# a     4.333333  5.333333
# b     6.000000  7.000000

result = df.groupby([&#39;key1&#39;, &#39;key2&#39;]).mean()
print(result)
#            data1  data2
# key1 key2
# a    one     5.0    6.0
#      two     3.0    4.0
# b    one     5.0    6.0
#      two     7.0    8.0

result = df.groupby([&#39;key1&#39;, &#39;key2&#39;]).size()
print(result)
# key1  key
# a     one     2
#       two     1
# b     one     1
#       two     1
# dtype: int64
</code></pre></div></p> <h3 id=_3>遍历各分组<a class=headerlink href=#_3 title="Permanent link"> ¶</a></h3> <p><code>GroupBy</code>对象支持迭代，会生成一个包含组名和数据块的2维元组序列。 <div class=highlight><pre><span></span><code>df = pd.DataFrame(
    {
        &#39;key1&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;],
        &#39;key2&#39;: [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;],
        &#39;data1&#39;: [1, 3, 5, 7, 9],
        &#39;data2&#39;: [2, 4, 6, 8, 10]
    }
)
</code></pre></div></p> <p>单个分组键的情况: <div class=highlight><pre><span></span><code>for name, group in df.groupby(&#39;key1&#39;):
    print(name)
    print(group)
# a
#   key1 key2  data1  data2
# 0    a  one      1      2
# 1    a  two      3      4
# 4    a  one      9     10
# b
#   key1 key2  data1  data2
# 2    b  one      5      6
# 3    b  two      7      8
</code></pre></div></p> <p>多个分组键的情况: 元组中的第一个元素是键值的元组。 <div class=highlight><pre><span></span><code>for (k1, k2), group in df.groupby([&#39;key1&#39;, &#39;key2&#39;]):
    print((k1, k2))
    print(group)
# (&#39;a&#39;, &#39;one&#39;)
#   key1 key2  data1  data2
# 0    a  one      1      2
# 4    a  one      9     10
# (&#39;a&#39;, &#39;two&#39;)
#   key1 key2  data1  data2
# 1    a  two      3      4
# (&#39;b&#39;, &#39;one&#39;)
#   key1 key2  data1  data2
# 2    b  one      5      6
# (&#39;b&#39;, &#39;two&#39;)
#   key1 key2  data1  data2
# 3    b  two      7      8

result = dict(list(df.groupby(&#39;key1&#39;)))
print(result)
# df.groupby(&#39;key1&#39;)的结果是一个对象
# &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f240fe058b0&gt;
# list(df.groupby(&#39;key1&#39;))的结果是包含FrameData的结构的列表list:
# [
#     (&#39;a&#39;,   key1 key2  data1  data2
#           0    a  one      1      2
#           1    a  two      3      4
#           4    a  one      9     10),
#     (&#39;b&#39;,   key1 key2  data1  data2
#           2    b  one      5      6
#           3    b  two      7      8)
# ]
# dict(list(df.groupby(&#39;key1&#39;)))的结果是包含FrameData的结构的字典dict
# {
#     &#39;a&#39;:   key1 key2  data1  data2
#          0    a  one      1      2
#          1    a  two      3      4
#          4    a  one      9     10,
#     &#39;b&#39;:   key1 key2  data1  data2
#          2    b  one      5      6
#          3    b  two      7      8
# }
print(result[&#39;b&#39;])
#   key1 key2  data1  data2
# 2    b  one      5      6
# 3    b  two      7      8
</code></pre></div></p> <p>默认情况下，<code>groupby</code>在<code>axis=0</code>的轴向上分组，也可以在其他任意轴向上进行分组。 <div class=highlight><pre><span></span><code>print(df.dtypes)
# key1     object
# key2     object
# data1     int64
# data2     int64
# dtype: object

grouped = df.groupby(df.dtypes, axis=1)
print(grouped)  # &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f4f6636df70&gt;
print(list(grouped))
# [
#     (dtype(&#39;int64&#39;),    data1  data2
#                      0      1      2
#                      1      3      4
#                      2      5      6
#                      3      7      8
#                      4      9     10),
#     (dtype(&#39;O&#39;),   key1 key2
#                  0    a  one
#                  1    a  two
#                  2    b  one
#                  3    b  two
#                  4    a  one)
# ]
</code></pre></div></p> <p>打印各分组如下： <div class=highlight><pre><span></span><code>for dtype, group in grouped:
    print(dtype)
    print(group)
# int64
#       data1  data2
# 0         1      2
# 1         3      4
# 2         5      6
# 3         7      8
# 4         9     10
# object
#        key1   key2
# 0         a    one
# 1         a    two
# 2         b    one
# 3         b    two
# 4         a    one
</code></pre></div></p> <h3 id=_4>选择一列或所有列的子集<a class=headerlink href=#_4 title="Permanent link"> ¶</a></h3> <p>对于从DataFrame创建的<code>GroupBy</code>对象，用列名称或列名称数组进行索引时，会产生用于聚合的列子集的效果。</p> <p>如果传递的是列表或数组，则此索引操作返回的对象是分组的DataFrame；如果只有单个列名作为标量传递，则为分组的Series；</p> <p>对比下面4句： <div class=highlight><pre><span></span><code>result = df.groupby(&#39;key1&#39;)[&#39;data1&#39;]  # 单个列名
print(result)  # &lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa988609040&gt;
for key, data in result:
    print(key)
    print(data)
result = df[&#39;data1&#39;].groupby(df[&#39;key1&#39;])  # 单个列名
print(result)  # &lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa988609910&gt;
for key, data in result:
    print(key)
    print(data)
# a
# 0    1
# 1    3
# 4    9
# Name: data1, dtype: int64
# b
# 2    5
# 3    7
# Name: data1, dtype: int64
result = df.groupby(&#39;key1&#39;)[[&#39;data1&#39;]]  # 列表或数组
print(result)  # &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f32666176a0&gt;
for key, data in result:
    print(key)
    print(data)
# a
#   key1 key2  data1  data2
# 0    a  one      1      2
# 1    a  two      3      4
# 4    a  one      9     10
# b
#   key1 key2  data1  data2
# 2    b  one      5      6
# 3    b  two      7      8
result = df[[&#39;data1&#39;]].groupby(df[&#39;key1&#39;])  # 列表或数组
print(result)  # &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f32666171f0&gt;
for key, data in result:
    print(key)
    print(data)
# a
#    data1
# 0      1
# 1      3
# 4      9
# b
#    data1
# 2      5
# 3      7
</code></pre></div></p> <h3 id=series>使用字典和Series分组<a class=headerlink href=#series title="Permanent link"> ¶</a></h3> <p>分组信息可能会以非数组形式存在。</p> <p>生成一个示例DataFrame。 <div class=highlight><pre><span></span><code>people = pd.DataFrame(
    [[1, 3, 5, 7, 9],
     [0, 2, 4, 6, 8],
     [0, 2, 4, 6, 8],
     [1, 3, 5, 7, 9],
     [1, 2, 3, 4, 5]],
    columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],
    index=[&#39;Joe&#39;, &#39;Steve&#39;, &#39;Wes&#39;, &#39;Jim&#39;, &#39;Travis&#39;]
)
</code></pre></div></p> <p>添加一些NA值。 <div class=highlight><pre><span></span><code>people.iloc[2:3, [1, 2]] = np.nan
print(people)
#         a    b    c  d  e
# Joe     1  3.0  5.0  7  9
# Steve   0  2.0  4.0  6  8
# Wes     0  NaN  NaN  6  8
# Jim     1  3.0  5.0  7  9
# Travis  1  2.0  3.0  4  5
</code></pre></div></p> <p>假设有如下各列的分组对应关系，并且想把各列按组累加。 <div class=highlight><pre><span></span><code>mapping = {
    &#39;a&#39;: &#39;red&#39;,
    &#39;b&#39;: &#39;red&#39;,
    &#39;c&#39;: &#39;blue&#39;,
    &#39;d&#39;: &#39;blue&#39;,
    &#39;e&#39;: &#39;red&#39;,
    &#39;f&#39;: &#39;orange&#39;  # 注意：健f虽然没有被用到，但不影响在这里定义。
}
</code></pre></div></p> <p>把<code>mapping</code>这个字典传给<code>groupby()</code>。 <div class=highlight><pre><span></span><code>by_column = people.groupby(mapping, axis=1)
print(by_column.sum())
#         blue   red
# Joe     12.0  13.0
# Steve   10.0  10.0
# Wes      6.0   8.0
# Jim     12.0  13.0
# Travis   7.0   8.0
</code></pre></div></p> <p>Series也有相同的功能，可以视为固定大小的映射。 <div class=highlight><pre><span></span><code>map_services = pd.Series(mapping)
print(map_services)
# a       red
# b       red
# c      blue
# d      blue
# e       red
# f    orange
# dtype: object
result = people.groupby(map_services, axis=1).count()
print(result)
#         blue  red
# Joe        2    3
# Steve      2    3
# Wes        1    2
# Jim        2    3
# Travis     2    3
</code></pre></div></p> <h3 id=_5>使用函数分组<a class=headerlink href=#_5 title="Permanent link"> ¶</a></h3> <p>与使用字典或Series分组相比，使用Python函数是定义分组关系的一种更为通用的方式。</p> <p>作为分组键传递的函数将会按照每个索引值调用一次，同时返回值会被用作分组名称。注意：函数是作用在索引上。 <div class=highlight><pre><span></span><code>result = people.groupby(len).sum()  # 人的名字是索引值，根据名字的长度来进行分组
print(result)
#    a    b     c   d   e
# 3  2  6.0  10.0  20  26
# 5  0  2.0   4.0   6   8
# 6  1  2.0   3.0   4   5
</code></pre></div></p> <p>可以将函数与数组、字典或Series进行混合，所有的对象都会在内部转换为数组。 <div class=highlight><pre><span></span><code>key_list = [&#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;two&#39;]
result = people.groupby([len, key_list]).min()
print(result)
#        a    b    c  d  e
# 3 one  0  3.0  5.0  6  8
#   two  1  3.0  5.0  7  9
# 5 one  0  2.0  4.0  6  8
# 6 two  1  2.0  3.0  4  5
</code></pre></div></p> <h3 id=_6>根据索引层级分组<a class=headerlink href=#_6 title="Permanent link"> ¶</a></h3> <p>根据层级分组时，将层级数值或层级名称传递给<code>level</code>关键字。 <div class=highlight><pre><span></span><code>columns = pd.MultiIndex.from_arrays(
    [[&#39;US&#39;, &#39;US&#39;, &#39;US&#39;, &#39;JP&#39;, &#39;JP&#39;],
     [1, 3, 5, 1, 3]],
    names=[&#39;cty&#39;, &#39;tenor&#39;]
)
hier_df = pd.DataFrame(
    [[1, 3, 5, 7, 9],
     [0, 2, 4, 6, 8],
     [1, 3, 5, 7, 9],
     [1, 2, 3, 4, 5]],
    columns=columns
)
print(hier_df)
# cty   US       JP
# tenor  1  3  5  1  3
# 0      1  3  5  7  9
# 1      0  2  4  6  8
# 2      1  3  5  7  9
# 3      1  2  3  4  5

result = hier_df.groupby(level=&#39;cty&#39;, axis=1).count()
print(result)
# cty  JP  US
# 0     2   3
# 1     2   3
# 2     2   3
# 3     2   3
</code></pre></div></p> <h2 id=_7>数据聚合<a class=headerlink href=#_7 title="Permanent link"> ¶</a></h2> <p>聚合是指所有根据数组产生标量值的数据转换过程，比如：<code>mean</code>、<code>count</code>、<code>min</code>和<code>sum</code>等一些聚合操作。 <div class=highlight><pre><span></span><code>import pandas as pd
import numpy as np
</code></pre></div></p> <p>预备知识：</p> <p>分位数（Quantile），也称分位点，是指将一个随机变量的概率分布范围分为几个等份的数值点，分析其数据变量的趋势。 常用的分位数有 中位数、四分位数、百分位数等。</p> <p>中位数（Medians）是一个统计学的专有名词，代表一个样本、种群或概率分布中的一个数值，可以将数值集合划分为相等的两部分。</p> <p>利用pandas库计算<code>data = [6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36]</code>的分位数。</p> <p>确定<code>p</code>分位数位置的两种方法(<code>n</code>为数据的总个数，<code>p</code>为<code>0-1</code>之间的值)。在python中计算分位数位置的方案采用<code>position=1+(n-1)*p</code>：</p> <ul> <li><code>position = (n+1)*p</code></li> <li><code>position = 1 + (n-1)*p</code></li> </ul> <p>案例1 <div class=highlight><pre><span></span><code>data = pd.Series(np.array([6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36]))
print(&quot;数据格式：&quot;)
print(np.sort(data))  # 必须要排序
print(&#39;Q1:&#39;, data.quantile(.25))
print(&#39;Q2:&#39;, data.quantile(.5))
print(&#39;Q3:&#39;, data.quantile(.75))
# 数据格式：
# [ 6  7 15 36 39 40 41 42 43 47 49]
# Q1: 25.5
# Q2: 40.0
# Q3: 42.5
# 手算计算结果：
# Q1的p分位数(0.25)位置position = 1+(11-1)*0.25 = 3.5(取第3位) (p=0.25) Q1=15+(36-15)*0.5=25.5 (第3、4位的差乘以余数0.5)
# Q2的p分位数(0.5)位置position = 1+(11-1)*0.5 = 6 (p=0.5) Q2=40
# Q3的p分位数(0.75)位置position = 1+(11-1)*0.75 = 9 (p=0.75) Q3=42+(43-42)*0.5=42.5
# IQR = Q3 - Q1 = 17
</code></pre></div></p> <p>案例2 <div class=highlight><pre><span></span><code>df = pd.DataFrame(np.array([[1, 1], [2, 10], [3, 100], [4, 100]]), columns=[&#39;a&#39;, &#39;b&#39;])
print(&quot;数据原始格式：&quot;)
print(df)
print(&quot;计算p=0.1时，a列和b列的分位数&quot;)
print(df.quantile(.1))
# 数据原始格式：
#    a    b
# 0  1    1
# 1  2   10
# 2  3  100
# 3  4  100
# 计算p=0.1时，a列和b列的分位数
# a    1.3
# b    3.7
# Name: 0.1, dtype: float64
# 手算计算结果：
# 计算a列
# position=1+(4-1)*0.1=1.3 (取第1位)
# Q1=1+(2-1)*0.3=1.3  (第1、2位的差乘以余数0.3)
# 计算b列
# position=1+(4-1)*0.1=1.3 (取第1位)
# Q1=1+(10-1)*0.3=3.7  (第1、2位的差乘以余数0.3)
</code></pre></div></p> <p>优化的<code>groupby</code>方法：</p> <ul> <li>count: 分组中非NA值的数量</li> <li>sum: 非NA值的累加和</li> <li>mean: 非NA值的平均值</li> <li>median: 非NA值的算术中位数</li> <li>std, var: 无偏的(n-1分母)标准差和方差</li> <li>min, max: 非NA值的最小值、最大值</li> <li>prod: 非NA值的乘积</li> <li>first, last: 非NA值的第一个、最后一个值</li> </ul> <div class=highlight><pre><span></span><code>df = pd.DataFrame(
    {
        &#39;key1&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;],
        &#39;key2&#39;: [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;],
        &#39;data1&#39;: [1, 3, 5, 7, 9],
        &#39;data2&#39;: [2, 4, 6, 8, 10]
    }
)

print(df)
#   key1 key2  data1  data2
# 0    a  one      1      2
# 1    a  two      3      4
# 2    b  one      5      6
# 3    b  two      7      8
# 4    a  one      9     10

grouped = df.groupby(&#39;key1&#39;)
result = grouped[&#39;data1&#39;]
for i in result:
    print(i)
# (&#39;a&#39;, 0    1
#       1    3
#       4    9
#       Name: data1, dtype: int64)
# (&#39;b&#39;, 2    5
#       3    7
#       Name: data1, dtype: int64)
result = grouped[&#39;data1&#39;].quantile(0.9)  # quantile分位数
print(result)
# key1
# a    7.8
# b    6.8
# Name: data1, dtype: float64
# 手算计算结果：
# 计算a列
# position=1+(3-1)*0.9=2.8
# Q1=3+(9-3)*0.8=7.8
# 计算b列
# position=1+(2-1)*0.9=1.9
# Q1=5+(7-5)*0.9=6.8
</code></pre></div> <p>使用自行制定的聚合，并再调用已经在分组对象上定义好的方法。 <div class=highlight><pre><span></span><code>def peak_to_peak(arr):
    return arr.max() - arr.min()


result = grouped.agg(peak_to_peak)
print(result)
#       data1  data2
# key1
# a         8      8
# b         2      2

result = grouped.describe()
print(result)
#      data1                                ... data2
#      count      mean       std  min  25%  ...   min  25%  50%  75%   max
# key1                                      ...
# a      3.0  4.333333  4.163332  1.0  2.0  ...   2.0  3.0  4.0  7.0  10.0
# b      2.0  6.000000  1.414214  5.0  5.5  ...   6.0  6.5  7.0  7.5   8.0
</code></pre></div></p> <h2 id=_8>逐列及多函数应用<a class=headerlink href=#_8 title="Permanent link"> ¶</a></h2> <div class=highlight><pre><span></span><code>tips = pd.read_csv(&#39;../examples/tips.csv&#39;)
tips[&#39;tip_pct&#39;] = tips[&#39;tip&#39;] / (tips[&#39;total_bill&#39;] - tips[&#39;tip&#39;])
print(tips.head(5))
#    total_bill   tip smoker  day    time  size   tip_pct
# 0       16.99  1.01     No  Sun  Dinner     2  0.063204
# 1       10.34  1.66     No  Sun  Dinner     3  0.191244
# 2       21.01  3.50     No  Sun  Dinner     3  0.199886
# 3       23.68  3.31     No  Sun  Dinner     2  0.162494
# 4       24.59  3.61     No  Sun  Dinner     4  0.172069
</code></pre></div> <p>根据各列同时使用多个函数进行聚合 <div class=highlight><pre><span></span><code>grouped = tips.groupby([&#39;day&#39;, &#39;smoker&#39;])
# for i in grouped:
#     print(i)
# ((&#39;Fri&#39;, &#39;No&#39;),      total_bill   tip smoker  day    time  size   tip_pct
#                 91        22.49  3.50     No  Fri  Dinner     2  0.184308
#                 ......
#                 223       15.98  3.00     No  Fri   Lunch     3  0.231125)
# ((&#39;Fri&#39;, &#39;Yes&#39;),      total_bill   tip smoker  day    time  size   tip_pct
#                  90        28.97  3.00    Yes  Fri  Dinner     2  0.115518
#                  ......
#                  226       10.09  2.00    Yes  Fri   Lunch     2  0.247219)
# ......

grouped_pct = grouped[&#39;tip_pct&#39;]
for i in grouped_pct:
    print(i)
# ((&#39;Fri&#39;, &#39;No&#39;), 91     0.184308
#                 94     0.166667
#                 ......
# Name: tip_pct, dtype: float64)
# ((&#39;Fri&#39;, &#39;Yes&#39;), 90     0.115518
#                  92     0.210526
#                  ......
# Name: tip_pct, dtype: float64)
# ......
</code></pre></div></p> <p>将函数名以字符串形式传递。 <div class=highlight><pre><span></span><code>result = grouped_pct.agg(&#39;mean&#39;)
print(result)
# day   smoker
# Fri   No        0.179740
#       Yes       0.216293
# Sat   No        0.190412
#       Yes       0.179833
# Sun   No        0.193617
#       Yes       0.322021
# Thur  No        0.193424
#       Yes       0.198508
# Name: tip_pct, dtype: float64
</code></pre></div></p> <p>如果传递的是函数或者函数名的列表，会得到一个列名是这些函数名的DataFrame。 下面传递了聚合函数的列表给agg方法，这些函数会各自运用于数据分组。 <div class=highlight><pre><span></span><code>result = grouped_pct.agg([&#39;mean&#39;, &#39;std&#39;, peak_to_peak])
print(result)
#                  mean       std  peak_to_peak
# day  smoker
# Fri  No      0.179740  0.039458      0.094263
#      Yes     0.216293  0.077530      0.242219
# Sat  No      0.190412  0.058626      0.352192
#      Yes     0.179833  0.089496      0.446137
# Sun  No      0.193617  0.060302      0.274897
#      Yes     0.322021  0.538061      2.382107
# Thur No      0.193424  0.056065      0.284273
#      Yes     0.198508  0.057170      0.219047
</code></pre></div></p> <p>如果传递的是<code>(name, function)</code>元组的列表，每个元组的第一个元素将作为DataFrame的列名（可以认为二元元组的列表是一种有序的对应关系）： <div class=highlight><pre><span></span><code>result = grouped_pct.agg([(&#39;foo&#39;, &#39;mean&#39;), (&#39;bar&#39;, np.std)])  # foo是mean值的列名
print(result)
#                   foo       bar
# day  smoker
# Fri  No      0.179740  0.039458
#      Yes     0.216293  0.077530
# Sat  No      0.190412  0.058626
#      Yes     0.179833  0.089496
# Sun  No      0.193617  0.060302
#      Yes     0.322021  0.538061
# Thur No      0.193424  0.056065
#      Yes     0.198508  0.057170
</code></pre></div></p> <p>可以指定应用到所有列上的函数列表或每一列上要应用的不同函数。</p> <p>下面产生的DataFrame拥有分层列，与分别聚合每一列，再以列名作为<code>keys</code>参数使用<code>concat</code>将结果拼接在一起的结果相同。 <div class=highlight><pre><span></span><code>functions = [&#39;count&#39;, &#39;mean&#39;, &#39;max&#39;]
result = grouped[[&#39;tip_pct&#39;, &#39;total_bill&#39;]].agg(functions)
print(result)
#             tip_pct                     total_bill
#               count      mean       max      count       mean    max
# day  smoker
# Fri  No           4  0.179740  0.231125          4  18.420000  22.75
#      Yes         15  0.216293  0.357737         15  16.813333  40.17
# Sat  No          45  0.190412  0.412409         45  19.661778  48.33
#      Yes         42  0.179833  0.483092         42  21.276667  50.81
# Sun  No          57  0.193617  0.338101         57  20.506667  48.17
#      Yes         19  0.322021  2.452381         19  24.120000  45.35
# Thur No          45  0.193424  0.362976         45  17.113111  41.19
#      Yes         17  0.198508  0.317965         17  19.190588  43.11
# 把[&#39;tip_pct&#39;, &#39;total_bill&#39;]改成[[&#39;tip_pct&#39;, &#39;total_bill&#39;]]，就可以避免报错
# FutureWarning: Indexing with multiple keys (implicitly converted to a tuple of keys) will be deprecated, use a list instead.
# result = grouped[&#39;tip_pct&#39;, &#39;total_bill&#39;].agg(functions)
print(result[&#39;tip_pct&#39;])
#              count      mean       max
# day  smoker
# Fri  No          4  0.179740  0.231125
#      Yes        15  0.216293  0.357737
# Sat  No         45  0.190412  0.412409
#      Yes        42  0.179833  0.483092
# Sun  No         57  0.193617  0.338101
#      Yes        19  0.322021  2.452381
# Thur No         45  0.193424  0.362976
#      Yes        17  0.198508  0.317965
</code></pre></div></p> <p>也同样可以传递具有自定义名称的元组列表： <div class=highlight><pre><span></span><code>ftuples = [(&#39;Durchschnitt&#39;, &#39;mean&#39;), (&#39;Abweichung&#39;, np.var)]
result = grouped[[&#39;tip_pct&#39;, &#39;total_bill&#39;]].agg(ftuples)
print(result)
#                  tip_pct              total_bill
#             Durchschnitt Abweichung Durchschnitt  Abweichung
# day  smoker
# Fri  No         0.179740   0.001557    18.420000   25.596333
#      Yes        0.216293   0.006011    16.813333   82.562438
# Sat  No         0.190412   0.003437    19.661778   79.908965
#      Yes        0.179833   0.008010    21.276667  101.387535
# Sun  No         0.193617   0.003636    20.506667   66.099980
#      Yes        0.322021   0.289509    24.120000  109.046044
# Thur No         0.193424   0.003143    17.113111   59.625081
#      Yes        0.198508   0.003268    19.190588   69.808518
</code></pre></div></p> <p>要将不同的函数应用到一个或多个列上，需要将含有列名与函数对应关系的字典传递给<code>agg</code>： <div class=highlight><pre><span></span><code>result = grouped.agg({&#39;tip&#39;: np.max, &#39;size&#39;: &#39;sum&#39;})
print(result)
#                tip  size
# day  smoker
# Fri  No       3.50     9
#      Yes      4.73    31
# Sat  No       9.00   115
#      Yes     10.00   104
# Sun  No       6.00   167
#      Yes      6.50    49
# Thur No       6.70   112
#      Yes      5.00    40
result = grouped.agg({&#39;tip_pct&#39;: [&#39;min&#39;, &#39;max&#39;, &#39;mean&#39;, &#39;std&#39;]})
print(result)
#               tip_pct
#                   min       max      mean       std
# day  smoker
# Fri  No      0.136861  0.231125  0.179740  0.039458
#      Yes     0.115518  0.357737  0.216293  0.077530
# Sat  No      0.060217  0.412409  0.190412  0.058626
#      Yes     0.036955  0.483092  0.179833  0.089496
# Sun  No      0.063204  0.338101  0.193617  0.060302
#      Yes     0.070274  2.452381  0.322021  0.538061
# Thur No      0.078704  0.362976  0.193424  0.056065
#      Yes     0.098918  0.317965  0.198508  0.057170
</code></pre></div></p> <p>只有多个函数应用于至少一个列时，DataFrame才具有分层列。</p> <h3 id=_9>返回不含行索引的聚合数据<a class=headerlink href=#_9 title="Permanent link"> ¶</a></h3> <p>在前面所有的例子中，聚合数据返回时都是带有索引的，有时索引是分层的，由唯一的分组键联合形成。</p> <p>因为不是所有的情况下都需要索引，所以在大多数情况下可以通过向groupby传递as_index=False来禁用分组键作为索引的行为： <div class=highlight><pre><span></span><code>result = tips.groupby([&#39;day&#39;, &#39;smoker&#39;], as_index=False).mean()
print(result)
#     day smoker  total_bill       tip      size   tip_pct
# 0   Fri     No   18.420000  2.812500  2.250000  0.179740
# 1   Fri    Yes   16.813333  2.714000  2.066667  0.216293
# 2   Sat     No   19.661778  3.102889  2.555556  0.190412
# 3   Sat    Yes   21.276667  2.875476  2.476190  0.179833
# 4   Sun     No   20.506667  3.167895  2.929825  0.193617
# 5   Sun    Yes   24.120000  3.516842  2.578947  0.322021
# 6  Thur     No   17.113111  2.673778  2.488889  0.193424
# 7  Thur    Yes   19.190588  3.030000  2.352941  0.198508
</code></pre></div></p> <p>通过在结果上调用reset_index也可以获得同样的结果。使用as_index=False可以避免一些不必要的计算。 <div class=highlight><pre><span></span><code>result = tips.groupby([&#39;day&#39;, &#39;smoker&#39;]).mean()
print(result.reset_index())
#     day smoker  total_bill       tip      size   tip_pct
# 0   Fri     No   18.420000  2.812500  2.250000  0.179740
# 1   Fri    Yes   16.813333  2.714000  2.066667  0.216293
# 2   Sat     No   19.661778  3.102889  2.555556  0.190412
# 3   Sat    Yes   21.276667  2.875476  2.476190  0.179833
# 4   Sun     No   20.506667  3.167895  2.929825  0.193617
# 5   Sun    Yes   24.120000  3.516842  2.578947  0.322021
# 6  Thur     No   17.113111  2.673778  2.488889  0.193424
# 7  Thur    Yes   19.190588  3.030000  2.352941  0.198508
print(result)
#              total_bill       tip      size   tip_pct
# day  smoker
# Fri  No       18.420000  2.812500  2.250000  0.179740
#      Yes      16.813333  2.714000  2.066667  0.216293
# Sat  No       19.661778  3.102889  2.555556  0.190412
#      Yes      21.276667  2.875476  2.476190  0.179833
# Sun  No       20.506667  3.167895  2.929825  0.193617
#      Yes      24.120000  3.516842  2.578947  0.322021
# Thur No       17.113111  2.673778  2.488889  0.193424
#      Yes      19.190588  3.030000  2.352941  0.198508
</code></pre></div></p> <h2 id=->应用：通用拆分-应用-联合<a class=headerlink href=#- title="Permanent link"> ¶</a></h2> <div class=highlight><pre><span></span><code>import pandas as pd
import numpy as np
import statsmodels.api as sm
</code></pre></div> <p><code>GroupBy</code>方法最常见的目的是<code>apply</code>（应用）。<code>apply</code>将对象拆分成多块，然后在每一块上调用传递的函数，之后尝试将每一块拼接到一起。</p> <p>根据下面的小费数据集，按组选出小费百分比（tip-pct）最高的五组。 <div class=highlight><pre><span></span><code>tips = pd.read_csv(&#39;../examples/tips.csv&#39;)
tips[&#39;tip_pct&#39;] = tips[&#39;tip&#39;] / (tips[&#39;total_bill&#39;] - tips[&#39;tip&#39;])
</code></pre></div></p> <p>样本数据 <div class=highlight><pre><span></span><code>print(tips.head(5))
#    total_bill   tip smoker  day    time  size   tip_pct
# 0       16.99  1.01     No  Sun  Dinner     2  0.063204
# 1       10.34  1.66     No  Sun  Dinner     3  0.191244
# 2       21.01  3.50     No  Sun  Dinner     3  0.199886
# 3       23.68  3.31     No  Sun  Dinner     2  0.162494
# 4       24.59  3.61     No  Sun  Dinner     4  0.172069
</code></pre></div></p> <p>首先，写一个可以在特定列中选出最大值所在行的函数：</p> <p>添加了升序，结果输出最后5行（最后的5行也是最大的5个<code>tip_tcp</code>记录）。 <div class=highlight><pre><span></span><code>def top(df, n=5, column=&#39;tip_pct&#39;):
    return df.sort_values(by=column, ascending=True)[-n:]


result = top(tips, n=6)
print(result)
# 等价方式：
# result = tips.sort_values(&#39;tip_pct&#39;)[-6:]
# print(result)
#      total_bill   tip smoker  day    time  size   tip_pct
# 109       14.31  4.00    Yes  Sat  Dinner     2  0.387973
# 183       23.17  6.50    Yes  Sun  Dinner     4  0.389922
# 232       11.61  3.39     No  Sat  Dinner     2  0.412409
# 67         3.07  1.00    Yes  Sat  Dinner     1  0.483092
# 178        9.60  4.00    Yes  Sun  Dinner     2  0.714286
# 172        7.25  5.15    Yes  Sun  Dinner     2  2.452381
</code></pre></div></p> <p>如果按照<code>smoker</code>进行分组，之后调用<code>apply</code>，会得到以下结果：</p> <p><code>top</code>函数在DataFrame的每一行分组上被调用，之后使用<code>pandas.concat</code>将函数结果粘贴在一起，并使用分组名作为各组的标签。 因此结果包含一个分层索引，该分层索引的内部层级包含原DataFrame的索引值。 <div class=highlight><pre><span></span><code>result = tips.groupby(&#39;smoker&#39;).apply(top)
print(result)
#             total_bill   tip smoker   day    time  size   tip_pct
# smoker
# No     88        24.71  5.85     No  Thur   Lunch     2  0.310180
#        185       20.69  5.00     No   Sun  Dinner     5  0.318674
#        51        10.29  2.60     No   Sun  Dinner     2  0.338101
#        149        7.51  2.00     No  Thur   Lunch     2  0.362976
#        232       11.61  3.39     No   Sat  Dinner     2  0.412409
# Yes    109       14.31  4.00    Yes   Sat  Dinner     2  0.387973
#        183       23.17  6.50    Yes   Sun  Dinner     4  0.389922
#        67         3.07  1.00    Yes   Sat  Dinner     1  0.483092
#        178        9.60  4.00    Yes   Sun  Dinner     2  0.714286
#        172        7.25  5.15    Yes   Sun  Dinner     2  2.452381
</code></pre></div></p> <p>如果除了向<code>apply</code>传递函数，还传递其他参数或关键字的话，你可以把这些放在函数后进行传递。 <div class=highlight><pre><span></span><code>result = tips.groupby(&#39;smoker&#39;).apply(top, n=1, column=&#39;total_bill&#39;)
print(result)
# 这2行都是smoker是yes和no时最大total_bill值所在行。
#             total_bill   tip smoker  day    time  size   tip_pct
# smoker
# No     212       48.33   9.0     No  Sat  Dinner     4  0.228833
# Yes    170       50.81  10.0    Yes  Sat  Dinner     3  0.245038
</code></pre></div></p> <p>在<code>GroupBy</code>对象上调用<code>describe</code>方法。 <div class=highlight><pre><span></span><code>result = tips.groupby(&#39;smoker&#39;)[&#39;tip_pct&#39;].describe()
print(result)
#         count      mean       std  ...       50%       75%       max
# smoker                             ...
# No      151.0  0.192237  0.057665  ...  0.184308  0.227015  0.412409
# Yes      93.0  0.218176  0.254295  ...  0.181818  0.242326  2.452381
# [2 rows x 8 columns]
print(result.unstack(&#39;smoker&#39;))  # 类似于转置
#        smoker
# count  No        151.000000
#        Yes        93.000000
# mean   No          0.192237
#        Yes         0.218176
# std    No          0.057665
#        Yes         0.254295
# min    No          0.060217
#        Yes         0.036955
# 25%    No          0.158622
#        Yes         0.119534
# 50%    No          0.184308
#        Yes         0.181818
# 75%    No          0.227015
#        Yes         0.242326
# max    No          0.412409
#        Yes         2.452381
# dtype: float64
</code></pre></div></p> <p>在<code>GroupBy</code>对象的内部，当调用像<code>describe</code>这样的方法时，实际上是以下代码的简写： <div class=highlight><pre><span></span><code>grouped = tips.groupby([&#39;smoker&#39;])
f = lambda x: x.describe()
result = grouped.apply(f)
print(result)
#               total_bill         tip        size     tip_pct
# smoker
# No     count  151.000000  151.000000  151.000000  151.000000
#        mean    19.188278    2.991854    2.668874    0.192237
#        std      8.255582    1.377190    1.017984    0.057665
#        min      7.250000    1.000000    1.000000    0.060217
#        25%     13.325000    2.000000    2.000000    0.158622
#        50%     17.590000    2.740000    2.000000    0.184308
#        75%     22.755000    3.505000    3.000000    0.227015
#        max     48.330000    9.000000    6.000000    0.412409
# Yes    count   93.000000   93.000000   93.000000   93.000000
#        mean    20.756344    3.008710    2.408602    0.218176
#        std      9.832154    1.401468    0.810751    0.254295
#        min      3.070000    1.000000    1.000000    0.036955
#        25%     13.420000    2.000000    2.000000    0.119534
#        50%     17.920000    3.000000    2.000000    0.181818
#        75%     26.860000    3.680000    3.000000    0.242326
#        max     50.810000   10.000000    5.000000    2.452381
</code></pre></div></p> <h3 id=_10>压缩分组键<a class=headerlink href=#_10 title="Permanent link"> ¶</a></h3> <p>在前面的例子中所得到的对象，都具有分组键所形成的分层索引以及每个原始对象的索引。 也可以通过向<code>groupby</code>传递<code>group_keys=False</code>来禁用这个功能。 <div class=highlight><pre><span></span><code>result = tips.groupby(&#39;smoker&#39;, group_keys=True).apply(top)
print(result)
#             total_bill   tip smoker   day    time  size   tip_pct
# smoker
# No     88        24.71  5.85     No  Thur   Lunch     2  0.310180
#        185       20.69  5.00     No   Sun  Dinner     5  0.318674
#        51        10.29  2.60     No   Sun  Dinner     2  0.338101
#        149        7.51  2.00     No  Thur   Lunch     2  0.362976
#        232       11.61  3.39     No   Sat  Dinner     2  0.412409
# Yes    109       14.31  4.00    Yes   Sat  Dinner     2  0.387973
#        183       23.17  6.50    Yes   Sun  Dinner     4  0.389922
#        67         3.07  1.00    Yes   Sat  Dinner     1  0.483092
#        178        9.60  4.00    Yes   Sun  Dinner     2  0.714286
#        172        7.25  5.15    Yes   Sun  Dinner     2  2.452381
result = tips.groupby(&#39;smoker&#39;, group_keys=False).apply(top)
print(result)
#      total_bill   tip smoker   day    time  size   tip_pct
# 88        24.71  5.85     No  Thur   Lunch     2  0.310180
# 185       20.69  5.00     No   Sun  Dinner     5  0.318674
# 51        10.29  2.60     No   Sun  Dinner     2  0.338101
# 149        7.51  2.00     No  Thur   Lunch     2  0.362976
# 232       11.61  3.39     No   Sat  Dinner     2  0.412409
# 109       14.31  4.00    Yes   Sat  Dinner     2  0.387973
# 183       23.17  6.50    Yes   Sun  Dinner     4  0.389922
# 67         3.07  1.00    Yes   Sat  Dinner     1  0.483092
# 178        9.60  4.00    Yes   Sun  Dinner     2  0.714286
# 172        7.25  5.15    Yes   Sun  Dinner     2  2.452381
</code></pre></div></p> <h3 id=_11>分位数与桶分析<a class=headerlink href=#_11 title="Permanent link"> ¶</a></h3> <p>第8章中，pandas有一些工具，尤其是<code>cut</code>和<code>qcut</code>，用于将数据按照你选择的箱位或样本分位数进行分桶。 与<code>groupby</code>方法一起使用这些函数可以对数据集更方便地进行分桶或分位分析。</p> <p>复习：机械学习中的分箱处理。</p> <p>在机械学习中经常会对数据进行分箱处理的操作， 也就是把一段连续的值切分成若干段，每一段的值看成一个分类。这个把连续值转换成离散值的过程，我们叫做分箱处理。</p> <p>比如，把年龄按15岁划分成一组，0-15岁叫做少年，16-30岁叫做青年，31-45岁叫做壮年。在这个过程中，我们把连续的年龄分成了三个类别，“少年”，“青年”和“壮年”就是各个类别的名称，或者叫做标签。</p> <p>在pandas中，<code>cut</code>和<code>qcut</code>函数都可以进行分箱处理操作。</p> <ul> <li><code>cut()</code>按照变量的值对变量进行分割，每个分组里数据的个数并不一样。</li> <li><code>qcut()</code>是按变量的数量来对变量进行分割，并且尽量保证每个分组里变量的个数相同。</li> </ul> <p>考虑下面一个简单的随机数据集和一个使用<code>cut</code>的等长桶分类： <div class=highlight><pre><span></span><code>df = pd.DataFrame(
    {
        &#39;data1&#39;: np.random.randn(1000),
        &#39;data2&#39;: np.random.randn(1000)
    }
)
quartiles = pd.cut(df.data1, 4)  # 按照data1值由小到大的顺序将数据分成4份，并且使每组值的范围大致相等。
print(quartiles[:10])
# 0     (-0.0743, 1.729]
# 1     (-0.0743, 1.729]
# 2     (-0.0743, 1.729]
# 3     (-0.0743, 1.729]
# 4    (-1.877, -0.0743]
# 5     (-0.0743, 1.729]
# 6     (-0.0743, 1.729]
# 7     (-0.0743, 1.729]
# 8    (-1.877, -0.0743]
# 9     (-0.0743, 1.729]
# Name: data1, dtype: category
# Categories (
#     4,
#     interval[float64, right]): [
#         (-3.687, -1.877] &lt; (-1.877, -0.0743] &lt; (-0.0743, 1.729] &lt; (1.729, 3.531]
#     ]
</code></pre></div></p> <p>上面<code>cut</code>返回的<code>Categorical</code>对象可以直接传递给<code>groupby</code>。利用它计算出<code>data2</code>列的一个统计值集合，如下： <div class=highlight><pre><span></span><code>def get_stats(group):
    return {
        &#39;min&#39;: group.min(),
        &#39;max&#39;: group.max(),
        &#39;count&#39;: group.count(),
        &#39;mean&#39;: group.mean()
    }
grouped = df.data2.groupby(quartiles)
for i in grouped:
    print(i)
result = grouped.apply(get_stats).unstack()
print(result)
#                        min       max  count      mean
# data1
# (-3.145, -1.424] -1.759377  2.484321   77.0 -0.127900
# (-1.424, 0.29]   -3.142344  2.830654  524.0 -0.081931
# (0.29, 2.005]    -3.557136  3.261635  376.0  0.015715
# (2.005, 3.719]   -2.829458  1.766352   23.0 -0.198780
</code></pre></div></p> <p>使用<code>qcut</code>，根据样本分位数计算出等大小的桶，就是等长桶。通过传递<code>labels=False</code>来获得分位数数值。 <div class=highlight><pre><span></span><code>grouping = pd.qcut(df.data1, 10, labels=False)
grouped = df.data2.groupby(grouping)
result = grouped.apply(get_stats).unstack()
print(result)
#             min       max  count      mean
# data1
# 0     -3.678934  3.022862  100.0  0.029658
# 1     -2.319813  2.646502  100.0  0.094035
# 2     -2.873727  2.470840  100.0  0.023866
# 3     -2.196701  2.042251  100.0  0.021232
# 4     -2.154161  2.020809  100.0  0.110834
# 5     -2.723061  2.415626  100.0  0.057365
# 6     -2.291470  2.536159  100.0  0.020866
# 7     -2.064083  1.799356  100.0 -0.081025
# 8     -3.405679  1.792581  100.0 -0.009705
# 9     -2.469285  2.600849  100.0 -0.061721
</code></pre></div></p> <h3 id=_12>示例：使用指定分组值填充缺失值<a class=headerlink href=#_12 title="Permanent link"> ¶</a></h3> <p>在清除缺失值时，有时会使用<code>dropna</code>来去除缺失值，有时使用修正值或来自于其他数据的值来输入（填充）到<code>null</code>值（<code>NA</code>）。 <code>fillna</code>是一个可以使用的正确工具。</p> <p>例如下面例子中使用使用平均值来填充NA值： <div class=highlight><pre><span></span><code>data = (100, 110, 120, 130, 140, 150)
s = pd.Series(data)
print(s)
# 0    100
# 1    110
# 2    120
# 3    130
# 4    140
# 5    150
# dtype: float64
</code></pre></div></p> <p>将数据中的一些值设置为缺失值： <div class=highlight><pre><span></span><code>s[::2] = np.nan
print(s)
# 0      NaN
# 1    110.0
# 2      NaN
# 3    130.0
# 4      NaN
# 5    150.0
# dtype: float64
result = s.fillna(s.mean())  # 110, 130, 150的平均值是130
print(result)
# 0    130.0
# 1    110.0
# 2    130.0
# 3    130.0
# 4    130.0
# 5    150.0
# dtype: float64
</code></pre></div></p> <p>下面的例子是按组填充NA值：</p> <ul> <li>方法1,对数据分组后使用<code>apply</code>。</li> <li>方法2,在每个数据块上都调用<code>fillna</code>的函数。</li> </ul> <div class=highlight><pre><span></span><code>data = (100, 110, 120, 130, 140, 150, 160, 170)
states = [&#39;Ohio&#39;, &#39;New York&#39;, &#39;Vermont&#39;, &#39;Florida&#39;, &#39;Oregon&#39;, &#39;Nevada&#39;, &#39;California&#39;, &#39;Idaho&#39;]
group_key = [&#39;East&#39;] * 4 + [&#39;West&#39;] * 4  # 4个East和4个West拼接的列表list

s = pd.Series(data, index=states)
print(s)
# Ohio          100
# New York      110
# Vermont       120
# Florida       130
# Oregon        140
# Nevada        150
# California    160
# Idaho         170
# dtype: int64
</code></pre></div> <p>将数据中的一些值设置为缺失值： <div class=highlight><pre><span></span><code>s[[&#39;Vermont&#39;, &#39;Nevada&#39;, &#39;Idaho&#39;]] = np.nan
print(s)
# Ohio          100.0
# New York      110.0
# Vermont         NaN
# Florida       130.0
# Oregon        140.0
# Nevada          NaN
# California    160.0
# Idaho           NaN
# dtype: float64

result = s.groupby(group_key).mean()
print(result)
# East    113.333333
# West    150.000000
# dtype: float64
</code></pre></div></p> <p>用上面得出的分组平均值来填充NA。 <div class=highlight><pre><span></span><code>fill_mean = lambda g: g.fillna(g.mean())
result = s.groupby(group_key).apply(fill_mean)
print(result)
# Ohio          100.000000
# New York      110.000000
# Vermont       113.333333
# Florida       130.000000
# Oregon        140.000000
# Nevada        150.000000
# California    160.000000
# Idaho         150.000000
# dtype: float64
</code></pre></div></p> <p>如果已经在代码中为每个分组预定义了填充值，可以利用每个分组都有的内置的<code>name</code>属性，实现填充<code>NA</code>。 <div class=highlight><pre><span></span><code>fill_value = {&#39;East&#39;: 0.5, &#39;West&#39;: -1}
fill_func = lambda g: g.fillna(fill_value[g.name])
result = s.groupby(group_key).apply(fill_func)
print(result)
# Ohio          100.0
# New York      110.0
# Vermont         0.5
# Florida       130.0
# Oregon        140.0
# Nevada         -1.0
# California    160.0
# Idaho          -1.0
# dtype: float64
</code></pre></div></p> <h3 id=_13>示例：随机采样与排列<a class=headerlink href=#_13 title="Permanent link"> ¶</a></h3> <p>假设想从大数据集中抽取随机样本（有或没有替换）以用于蒙特卡罗模拟目的或某些其他应用程序。 有很多方法来执行“抽取”，这里使用Series的sample方法。</p> <p>为了演示，这里介绍一种构造一副英式扑克牌的方法： <div class=highlight><pre><span></span><code># 梅花clubs、方块diamonds、红桃hearts、黑桃spades。
suits = [&#39;H&#39;, &#39;S&#39;, &#39;C&#39;, &#39;D&#39;]
card_val = (list(range(1, 11)) + [10] * 3) * 4
# card_val [
#     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10,
#     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10,
#     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10,
#     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10
#     ]
base_names = [&#39;A&#39;] + list(range(2, 11)) + [&#39;J&#39;, &#39;K&#39;, &#39;Q&#39;]
# base_names： [&#39;A&#39;, 2, 3, 4, 5, 6, 7, 8, 9, 10, &#39;J&#39;, &#39;K&#39;, &#39;Q&#39;]
</code></pre></div></p> <p>生成了一个长度为<code>52</code>的Series, Series的索引包含了牌名，Series的值可以用游戏（为了保持简单，让’A’为1 ）： <div class=highlight><pre><span></span><code>cards = []
for suit in [&#39;H&#39;, &#39;S&#39;, &#39;C&#39;, &#39;D&#39;]:
    cards.extend(str(num) + suit for num in base_names)

deck = pd.Series(card_val, index=cards)
print(deck)
# AH      1
# 2H      2
# 3H      3
# 4H      4
# 5H      5
# 6H      6
# 7H      7
# 8H      8
# 9H      9
# 10H    10
# JH     10
# KH     10
# QH     10
# AS      1
# 2S      2
# 3S      3
# 4S      4
# 5S      5
# 6S      6
# 7S      7
# 8S      8
# 9S      9
# 10S    10
# JS     10
# KS     10
# QS     10
# AC      1
# 2C      2
# 3C      3
# 4C      4
# 5C      5
# 6C      6
# 7C      7
# 8C      8
# 9C      9
# 10C    10
# JC     10
# KC     10
# QC     10
# AD      1
# 2D      2
# 3D      3
# 4D      4
# 5D      5
# 6D      6
# 7D      7
# 8D      8
# 9D      9
# 10D    10
# JD     10
# KD     10
# QD     10
# dtype: int64
</code></pre></div></p> <p>从这副牌中拿出五张牌可以写成： <div class=highlight><pre><span></span><code>def draw(_deck, n=5):
    return _deck.sample(n)


print(draw(deck))
# KD    10
# 2S     2
# 5C     5
# 6C     6
# QD    10
# dtype: int64
</code></pre></div></p> <p>假设要从每个花色中随机抽取两张牌。由于花色是牌名的最后两个字符，可以基于这点进行分组，并使用<code>apply</code>： <div class=highlight><pre><span></span><code>get_suit = lambda card: card[-1]  # 最后一个字母是花色
result = deck.groupby(get_suit).apply(draw, n=2)
print(result)
# C  10C    10
#    3C      3
# D  KD     10
#    AD      1
# H  5H      5
#    7H      7
# S  3S      3
#    5S      5
# dtype: int64
</code></pre></div></p> <p>或者也可以写成： <div class=highlight><pre><span></span><code>result = deck.groupby(get_suit, group_keys=False).apply(draw, n=2)
print(result)
# JC     10
# 8C      8
# QD     10
# 4D      4
# 10H    10
# 6H      6
# 7S      7
# KS     10
# dtype: int64
</code></pre></div></p> <h3 id=_14>示例：分组加权平均和相关性<a class=headerlink href=#_14 title="Permanent link"> ¶</a></h3> <p>在<code>groupby</code>的拆分-应用-联合的范式下，DataFrame的列间操作或两个Seriese之间的操作，例如实现分组加权平均。</p> <p>下面例子，使用一个包含分组键和权重值的数据集： <div class=highlight><pre><span></span><code>dt = np.random.randn(8)
wt = np.random.randn(8)
df = pd.DataFrame(
    {
        &#39;category&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;],
        &#39;data&#39;: dt,
        &#39;weight&#39;: wt
    }
)
print(df)
#   category      data    weight
# 0        a -0.250764 -0.085285
# 1        a  0.167155 -1.361254
# 2        a  0.399306  1.755542
# 3        a -0.514477  0.270124
# 4        b -0.005558  0.886514
# 5        b  0.607596 -1.384315
# 6        b -1.029627 -0.845340
# 7        b -0.294204  1.253965
</code></pre></div></p> <p>通过<code>category</code>进行分组加权平均如下： <div class=highlight><pre><span></span><code>grouped = df.groupby(&#39;category&#39;)
get_wavg = lambda g: np.average(g[&#39;data&#39;], weights=g[&#39;weight&#39;])
result = grouped.apply(get_wavg)
print(result)
# category
# a    0.614499
# b    3.863947
# dtype: float64
</code></pre></div></p> <p>另一个例子，一个从雅虎财经上获得的数据集，该数据集包含一些标普500 （SPX符号）和股票的收盘价： <div class=highlight><pre><span></span><code>close_px = pd.read_csv(&#39;../examples/stock_px_2.csv&#39;, parse_dates=True, index_col=0)

print(close_px.info())
# &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
# DatetimeIndex: 2214 entries, 2003-01-02 to 2011-10-14
# Data columns (total 4 columns):
#  #   Column  Non-Null Count  Dtype
# ---  ------  --------------  -----
#  0   AAPL    2214 non-null   float64
#  1   MSFT    2214 non-null   float64
#  2   XOM     2214 non-null   float64
#  3   SPX     2214 non-null   float64
# dtypes: float64(4)
# memory usage: 86.5 KB
# None

print(close_px[-4:])
#               AAPL   MSFT    XOM      SPX
# 2011-10-11  400.29  27.00  76.27  1195.54
# 2011-10-12  402.19  26.96  77.16  1207.25
# 2011-10-13  408.43  27.18  76.37  1203.66
# 2011-10-14  422.00  27.27  78.11  1224.58
</code></pre></div></p> <p>目标任务：计算一个DataFrame，它包含标普指数（SPX）每日收益的年度相关性（通过百分比变化计算）。</p> <p>首先创建一个计算每列与’SPX’列成对关联的函数： <div class=highlight><pre><span></span><code>spx_corr = lambda x: x.corrwith(x[&#39;SPX&#39;])
</code></pre></div></p> <p>之后，使用<code>pct_change</code>计算<code>close-px</code>百分比的变化： <div class=highlight><pre><span></span><code>rets = close_px.pct_change().dropna()  # Percentage change between the current and a prior element.
print(rets)
#                 AAPL      MSFT       XOM       SPX
# 2003-01-03  0.006757  0.001421  0.000684 -0.000484
# 2003-01-06  0.000000  0.017975  0.024624  0.022474
# ...              ...       ...       ...       ...
# 2011-10-14  0.033225  0.003311  0.022784  0.017380
# [2213 rows x 4 columns]
</code></pre></div></p> <p>最后，按年对百分比变化进行分组，可以使用单行函数从每个行标签中提取每个<code>datetime</code>标签的<code>year</code>属性： <div class=highlight><pre><span></span><code>get_year = lambda x: x.year
by_year = rets.groupby(get_year)
result = by_year.apply(spx_corr)
print(result)
#           AAPL      MSFT       XOM  SPX
# 2003  0.541124  0.745174  0.661265  1.0
# 2004  0.374283  0.588531  0.557742  1.0
# 2005  0.467540  0.562374  0.631010  1.0
# 2006  0.428267  0.406126  0.518514  1.0
# 2007  0.508118  0.658770  0.786264  1.0
# 2008  0.681434  0.804626  0.828303  1.0
# 2009  0.707103  0.654902  0.797921  1.0
# 2010  0.710105  0.730118  0.839057  1.0
# 2011  0.691931  0.800996  0.859975  1.0
</code></pre></div></p> <p>可以计算内部列相关性。这里计算了苹果和微软的年度相关性： <div class=highlight><pre><span></span><code>result = by_year.apply(lambda g: g[&#39;AAPL&#39;].corr(g[&#39;MSFT&#39;]))
print(result)
# 2003    0.480868
# 2004    0.259024
# 2005    0.300093
# 2006    0.161735
# 2007    0.417738
# 2008    0.611901
# 2009    0.432738
# 2010    0.571946
# 2011    0.581987
# dtype: float64
</code></pre></div></p> <h3 id=_15>示例：逐组线性回归<a class=headerlink href=#_15 title="Permanent link"> ¶</a></h3> <p>定义以下<code>regress</code>（回归）函数（使用<code>statsmodels</code>计量经济学库），该函数对每个数据块执行普通最小二乘（OLS）回归： <div class=highlight><pre><span></span><code>def regress(data, yvar, xvars):
    Y = data[yvar]
    X = data[xvars]
    X[&#39;intercept&#39;] = 1.
    result = sm.OLS(Y, X).fit()
    return result.params
</code></pre></div></p> <p>现在要计算AAPL在SPX回报上的年度线性回归： <div class=highlight><pre><span></span><code>result = by_year.apply(regress, &#39;AAPL&#39;, [&#39;SPX&#39;])
print(result)
#            SPX  intercept
# 2003  1.195406   0.000710
# 2004  1.363463   0.004201
# 2005  1.766415   0.003246
# 2006  1.645496   0.000080
# 2007  1.198761   0.003438
# 2008  0.968016  -0.001110
# 2009  0.879103   0.002954
# 2010  1.052608   0.001261
# 2011  0.806605   0.001514
</code></pre></div></p> <h2 id=_16>数据透视表与交叉表<a class=headerlink href=#_16 title="Permanent link"> ¶</a></h2> <h3 id=_17>数据透视表<a class=headerlink href=#_17 title="Permanent link"> ¶</a></h3> <p>数据透视表是电子表格程序和其他数据分析软件中常见的数据汇总工具。 它根据一个或多个键聚合一张表的数据，将数据在矩形格式中排列，其中一些分组键是沿着行的，另一些是沿着列的。</p> <p>Python中的pandas透视表是通过这里所介绍的groupby工具以及使用分层索引的重塑操作实现的。</p> <p>DataFrame拥有一个<code>pivot_table</code>方法，并且还有还一个顶层的<code>pandas.pivot_table</code>函数。</p> <p>除了为<code>groupby</code>提供一个方便接口，<code>pivot_table</code>还可以添加部分总计，也称作边距。 <div class=highlight><pre><span></span><code>import pandas as pd
import numpy as np
</code></pre></div></p> <p>根据下面的小费数据集，计算一张在行方向上按<code>day</code>和<code>smoker</code>排列的分组平均值（默认的<code>pivot_table</code>聚合类型）的表。</p> <p><code>pivot_table</code>选项：</p> <ul> <li>values: 需要聚合的列名，默认情况下聚合所有数值型的列。</li> <li>index: 在结果透视表的行上进行分组的列名或者其他分组键。</li> </ul> <div class=highlight><pre><span></span><code>tips = pd.read_csv(&#39;../examples/tips.csv&#39;)
tips[&#39;tip_pct&#39;] = tips[&#39;tip&#39;] / (tips[&#39;total_bill&#39;] - tips[&#39;tip&#39;])
</code></pre></div> <p>样本数据。 <div class=highlight><pre><span></span><code>print(tips.head(5))
#    total_bill   tip smoker  day    time  size   tip_pct
# 0       16.99  1.01     No  Sun  Dinner     2  0.063204
# 1       10.34  1.66     No  Sun  Dinner     3  0.191244
# 2       21.01  3.50     No  Sun  Dinner     3  0.199886
# 3       23.68  3.31     No  Sun  Dinner     2  0.162494
# 4       24.59  3.61     No  Sun  Dinner     4  0.172069
</code></pre></div></p> <p>计算在行方向上按<code>day</code>和<code>smoker</code>排列的分组平均值。也可以直接使用<code>groupby</code>实现。 <div class=highlight><pre><span></span><code>result = tips.pivot_table(index=[&#39;day&#39;, &#39;smoker&#39;])
print(result)
#                  size       tip   tip_pct  total_bill
# day  smoker
# Fri  No      2.250000  2.812500  0.179740   18.420000
#      Yes     2.066667  2.714000  0.216293   16.813333
# Sat  No      2.555556  3.102889  0.190412   19.661778
#      Yes     2.476190  2.875476  0.179833   21.276667
# Sun  No      2.929825  3.167895  0.193617   20.506667
#      Yes     2.578947  3.516842  0.322021   24.120000
# Thur No      2.488889  2.673778  0.193424   17.113111
#      Yes     2.352941  3.030000  0.198508   19.190588
</code></pre></div></p> <p>在<code>tip_pct</code>和<code>size</code>上进行聚合，并根据<code>time</code>分组。将把<code>smoker</code>放入表的列，而将<code>day</code>放入表的行： <div class=highlight><pre><span></span><code>result = tips.pivot_table(
    [&#39;tip_pct&#39;, &#39;size&#39;],
    index=[&#39;time&#39;, &#39;day&#39;],
    columns=&#39;smoker&#39;
)
print(result)
#                  size             tip_pct
# smoker             No       Yes        No       Yes
# time   day
# Dinner Fri   2.000000  2.222222  0.162612  0.202545
#        Sat   2.555556  2.476190  0.190412  0.179833
#        Sun   2.929825  2.578947  0.193617  0.322021
#        Thur  2.000000       NaN  0.190114       NaN
# Lunch  Fri   3.000000  1.833333  0.231125  0.236915
#        Thur  2.500000  2.352941  0.193499  0.198508
</code></pre></div></p> <p>通过传递<code>margins=True</code>来扩充这个表来包含部分总计。这会添加<code>All</code>行和列标签，其中相应的值是单层中所有数据的分组统计值。</p> <p>这里<code>All</code>的值是均值，且该均值是不考虑吸烟者与非吸烟者（<code>All</code>列）或行分组中任何两级的（<code>All</code>行）。 <div class=highlight><pre><span></span><code>result = tips.pivot_table(
    [&#39;tip_pct&#39;, &#39;size&#39;],
    index=[&#39;time&#39;, &#39;day&#39;],
    columns=&#39;smoker&#39;,
    margins=True
)
print(result)
#                  size                       tip_pct
# smoker             No       Yes       All        No       Yes       All
# time   day
# Dinner Fri   2.000000  2.222222  2.166667  0.162612  0.202545  0.192562
#        Sat   2.555556  2.476190  2.517241  0.190412  0.179833  0.185305
#        Sun   2.929825  2.578947  2.842105  0.193617  0.322021  0.225718
#        Thur  2.000000       NaN  2.000000  0.190114       NaN  0.190114
# Lunch  Fri   3.000000  1.833333  2.000000  0.231125  0.236915  0.236088
#        Thur  2.500000  2.352941  2.459016  0.193499  0.198508  0.194895
# All          2.668874  2.408602  2.569672  0.192237  0.218176  0.202123
</code></pre></div></p> <p>要使用不同的聚合函数时，将函数传递给<code>aggfunc</code>。例如，<code>count</code>或者<code>len</code>将给出一张分组大小的交叉表（计数或出现频率）： <div class=highlight><pre><span></span><code>result = tips.pivot_table(
    [&#39;tip_pct&#39;, &#39;size&#39;],
    index=[&#39;time&#39;, &#39;day&#39;],
    columns=&#39;smoker&#39;,
    aggfunc=len,
    margins=True
)
print(result)
#               size            tip_pct
# smoker          No   Yes  All      No   Yes  All
# time   day
# Dinner Fri     3.0   9.0   12     3.0   9.0   12
#        Sat    45.0  42.0   87    45.0  42.0   87
#        Sun    57.0  19.0   76    57.0  19.0   76
#        Thur    1.0   NaN    1     1.0   NaN    1
# Lunch  Fri     1.0   6.0    7     1.0   6.0    7
#        Thur   44.0  17.0   61    44.0  17.0   61
# All          151.0  93.0  244   151.0  93.0  244
</code></pre></div></p> <p>对于空值<code>NA</code>，传递一个<code>fill_value</code>。 <div class=highlight><pre><span></span><code>result = tips.pivot_table(
    [&#39;tip_pct&#39;, &#39;size&#39;],
    index=[&#39;time&#39;, &#39;day&#39;],
    columns=&#39;smoker&#39;,
    aggfunc=&#39;mean&#39;,
    fill_value=0,
    margins=True
)
print(result)
#                  size                       tip_pct
# smoker             No       Yes       All        No       Yes       All
# time   day
# Dinner Fri   2.000000  2.222222  2.166667  0.162612  0.202545  0.192562
#        Sat   2.555556  2.476190  2.517241  0.190412  0.179833  0.185305
#        Sun   2.929825  2.578947  2.842105  0.193617  0.322021  0.225718
#        Thur  2.000000  0.000000  2.000000  0.190114  0.000000  0.190114
# Lunch  Fri   3.000000  1.833333  2.000000  0.231125  0.236915  0.236088
#        Thur  2.500000  2.352941  2.459016  0.193499  0.198508  0.194895
# All          2.668874  2.408602  2.569672  0.192237  0.218176  0.202123
</code></pre></div></p> <h3 id=crosstab>交叉表：crosstab<a class=headerlink href=#crosstab title="Permanent link"> ¶</a></h3> <p>交叉表（简写为crosstab）是数据透视表的一个特殊情况，计算的是分组中的频率。<code>crosstab</code>的前两个参数可是数组、Series或数组的列表。 <div class=highlight><pre><span></span><code>sample = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
nationality = [&#39;USA&#39;, &#39;Japan&#39;, &#39;USA&#39;, &#39;Japan&#39;, &#39;Japan&#39;, &#39;Japan&#39;, &#39;USA&#39;, &#39;USA&#39;, &#39;Japan&#39;, &#39;USA&#39;]
handedness = [&#39;Right-handed&#39;, &#39;Left-handed&#39;, &#39;Right-handed&#39;, &#39;Right-handed&#39;, &#39;Left-handed&#39;, &#39;Right-handed&#39;,
              &#39;Right-handed&#39;, &#39;Left-handed&#39;, &#39;Right-handed&#39;, &#39;Right-handed&#39;]
df = pd.DataFrame(
    {
        &#39;sample&#39;: sample,
        &#39;nationality&#39;: nationality,
        &#39;handedness&#39;: handedness
    }
)
print(df)
#    sample nationality    handedness
# 0       1         USA  Right-handed
# 1       2       Japan   Left-handed
# 2       3         USA  Right-handed
# 3       4       Japan  Right-handed
# 4       5       Japan   Left-handed
# 5       6       Japan  Right-handed
# 6       7         USA  Right-handed
# 7       8         USA   Left-handed
# 8       9       Japan  Right-handed
# 9      10         USA  Right-handed
</code></pre></div></p> <p>按照国籍和惯用性来总结这些数据，可以使用<code>pivot_table</code>来实现这个功能，但是<code>pandas.crosstable</code>函数更为方便： <div class=highlight><pre><span></span><code>result = pd.crosstab(df.nationality, df.handedness, margins=True)
print(result)
# handedness   Left-handed  Right-handed  All
# nationality
# Japan                  2             3    5
# USA                    1             4    5
# All                    3             7   10
</code></pre></div></p> <p>在小费数据中可以这么做： <div class=highlight><pre><span></span><code>result = pd.crosstab([&#39;tips.time&#39;, tips.day], tips.smoker, margins=True)
print(result)
# smoker           No  Yes  All
# row_0     day
# tips.time Fri     4   15   19
#           Sat    45   42   87
#           Sun    57   19   76
#           Thur   45   17   62
# All             151   93  244
</code></pre></div></p> </article> </div> </div> <a href=# class="md-top md-icon" data-md-component=top data-md-state=hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg> Back to top </a> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../ch06/ class="md-footer__link md-footer__link--prev" aria-label="Previous: 绘图与可视化" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Previous </span> 绘图与可视化 </div> </div> </a> <a href=../ch08/ class="md-footer__link md-footer__link--next" aria-label="Next: 时间序列" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Next </span> 时间序列 </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.instant", "navigation.top"], "search": "../../../assets/javascripts/workers/search.fcfe8b6d.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": null}</script> <script src=../../../assets/javascripts/bundle.b1047164.min.js></script> </body> </html>
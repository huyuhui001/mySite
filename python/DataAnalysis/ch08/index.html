
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="canonical" href="https://huyuhui001.github.io/mySite/index.html/python/DataAnalysis/ch08/">
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-7.3.6">
    
    
      
        <title>时间序列 - MEMO</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.a57b2b03.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.3f5d1f46.min.css">
        
          
          
          <meta name="theme-color" content="#4051b5">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="deep-blue">
  
    
    <script>function __prefix(e){return new URL("../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="MEMO" class="md-header__button md-logo" aria-label="MEMO" data-md-component="logo">
      
  <img src="../../../assets/logo.jpg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            MEMO
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              时间序列
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="MEMO" class="md-nav__button md-logo" aria-label="MEMO" data-md-component="logo">
      
  <img src="../../../assets/logo.jpg" alt="logo">

    </a>
    MEMO
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" data-md-state="indeterminate" type="checkbox" id="__nav_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          Linux
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Linux" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          Linux
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../linux/Administration/linux_admin/" class="md-nav__link">
        SUSE Linux Administration
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../linux/SES/linux_ses/" class="md-nav__link">
        SUSE Enterprise Storage Foundation
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" data-md-state="indeterminate" type="checkbox" id="__nav_2" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          Python
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Python" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Python
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Foundation/python_foundation_index/" class="md-nav__link">
        Python Foundamentals
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../python_data_analysis_index/" class="md-nav__link">
        Data Analysis
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Demo/python_demo_index/" class="md-nav__link">
        Demos
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" data-md-state="indeterminate" type="checkbox" id="__nav_3" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          Cloud
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Cloud" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Cloud
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../cloud/MicroservicesKubernetes/" class="md-nav__link">
        Microservices with K8s
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../cloud/KubernetesFoundationMemo/" class="md-nav__link">
        K8s Foundamentals
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../cloud/Kubernetes-Installation/" class="md-nav__link">
        K8s Installation
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../cloud/KubernetesTutorials-BTP-trail/" class="md-nav__link">
        K8s Demos on Kyma@SAP BTP
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../cloud/KubernetesTutorials-Aliyun-Foundamentals/" class="md-nav__link">
        K8s Demos on Ubuntu@Aliyun
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../about/" class="md-nav__link">
        About
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    日期和时间数据的类型及工具
  </a>
  
    <nav class="md-nav" aria-label="日期和时间数据的类型及工具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#datetime" class="md-nav__link">
    datetime
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#datetime_1" class="md-nav__link">
    字符串与datetime互相转换
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    时间序列基础
  </a>
  
    <nav class="md-nav" aria-label="时间序列基础">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#datetimeindex" class="md-nav__link">
    DatetimeIndex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    索引、选择、子集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    含有重复索引的时间序列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    日期范围、频率和移位
  </a>
  
    <nav class="md-nav" aria-label="日期范围、频率和移位">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    生成日期范围
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    频率和日期偏置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="_1">时间序列</h1>
<h2 id="_2">日期和时间数据的类型及工具</h2>
<p>时间序列数据在很多领域都是重要的结构化数据形式。在多个时间点观测或测量的数据形成了时间序列。</p>
<p>许多时间序列是固定频率的，也就是说数据是根据相同的规则定期出现的，例如每15秒、每5分钟或每月1次。</p>
<p>时间序列也可以是不规则的，没有固定的时间单位或单位间的偏移量。</p>
<p>如何标记和引用时间序列数据取决于应用程序，时间序列包括：</p>
<ul>
<li>时间戳，具体的时刻。</li>
<li>固定的时间区间，例如2007的1月或整个2010年。</li>
<li>时间间隔，由开始和结束时间戳表示。时间区间可以被认为是间隔的特殊情况。</li>
<li>实验时间或消耗时间。每个时间戳是相对于特定开始时间的时间的量度（例如，自从被放置在烤箱中每秒烘烤的饼干的直径）。</li>
<li>目前主要关注前三类中的时间序列。</li>
</ul>
<pre><code>from datetime import datetime, timedelta
import datetime as dt
from dateutil.parser import parse
import pandas as pd
</code></pre>
<h3 id="datetime">datetime</h3>
<p>datetime格式符：</p>
<ul>
<li>%a    星期的英文单词的缩写：如星期一， 则返回 Mon</li>
<li>%A    星期的英文单词的全拼：如星期一，返回 Monday</li>
<li>%b    月份的英文单词的缩写：如一月， 则返回 Jan</li>
<li>%B    月份的引文单词的缩写：如一月， 则返回 January</li>
<li>%c    返回datetime的字符串表示，如03/08/15 23:01:26</li>
<li>%d    返回的是当前时间是当前月的第几天</li>
<li>%f    微秒的表示： 范围: [0,999999]</li>
<li>%H    以24小时制表示当前小时</li>
<li>%I    以12小时制表示当前小时</li>
<li>%m    返回月份 范围[0,12]</li>
<li>%M    返回分钟数 范围 [0,59]</li>
<li>%P    返回是上午还是下午–AM or PM</li>
<li>%S    返回秒数 范围 [0,61]。。。手册说明的</li>
<li>%U    返回当周是当年的第几周 以周日为第一天</li>
<li>%W    返回当周是当年的第几周 以周一为第一天</li>
<li>%w    当天在当周的天数，范围为[0, 6]，6表示星期天</li>
<li>%x    日期的字符串表示 ：03/08/15</li>
<li>%X    时间的字符串表示 ：23:22:08</li>
<li>%y    两个数字表示的年份 15</li>
<li>%Y    四个数字表示的年份 2015</li>
<li>%z    与utc时间的间隔 （如果是本地时间，返回空字符串）</li>
<li>%Z    时区名称（如果是本地时间，返回空字符串）</li>
</ul>
<pre><code>datestrs = ['2020/5/6', '2021/10/1']
# 注意区分datetime模块和datetime类，名字相同，容易引起错误。
# 比如datetime.datetime就报错type object 'datetime.datetime' has no attribute 'datetime'
print(datetime)
# &lt;class 'datetime.datetime'&gt;
print(dt)
# &lt;module 'datetime' from '/opt/Python-3.9.6/Lib/datetime.py'&gt;
</code></pre>
<p>Python标准库包含了日期和时间数据的类型。<code>datetime</code>、<code>time</code>和<code>calendar</code>模块是开始处理时间数据的主要内容。
<code>datetime.datetime</code>类型，或简写为<code>datetime</code>，是广泛使用的。</p>
<pre><code>now = datetime.now()
print(now)
# 2021-10-07 20:24:43.834293

result = dt.datetime(2021, 10, 7, 20, 26, 00, 72973)
print(result)
# 2021-10-07 20:26:00.072973
</code></pre>
<p><code>datetime</code>既存储了日期，也存储了细化到微秒的时间。
<code>timedelta</code>表示两个<code>datetime</code>对象的时间差。</p>
<pre><code>delta = datetime(2021, 10, 7) - datetime(2021, 9, 7)
print(delta)
# 30 days, 0:00:00
print(delta.days)
# 30
print(delta.seconds)
# 0

result = dt.timedelta(926, 56700)
print(result)
# 926 days, 15:45:00
</code></pre>
<p>可以为一个<code>datetime</code>对象加上（或减去）一个<code>timedelta</code>或其整数倍来产生一个新的<code>datetime</code>对象。</p>
<pre><code>start = datetime(2021, 10, 7)

result = start + timedelta(12)
print(result)
# 2021-10-19 00:00:00

result = start - 2 * timedelta(5)
print(result)
# 2021-09-27 00:00:00
</code></pre>
<h3 id="datetime_1">字符串与datetime互相转换</h3>
<p>使用<code>str</code>方法或传递一个指定的格式给<code>strftime</code>方法来对<code>datetime</code>对象和pandas的<code>Timestamp</code>对象进行格式化。</p>
<pre><code>stamp = datetime(2021, 10, 7)
result = str(stamp)
print(result)
# 2021-10-07 00:00:00
</code></pre>
<p>使用<code>datetime.srtptime</code>和<code>datetime</code>格式符，把字符串转换日期。
<code>datetime.strptime</code>是在已知格式的情况下转换日期的好方式。</p>
<pre><code>value = '2021-10-7'
result = datetime.strptime(value, '%Y-%m-%d')
print(result)
# 2021-10-07 00:00:00

datestrs = ['2020/5/6', '2021/10/1']
result = [datetime.strptime(x, '%Y/%m/%d') for x in datestrs]
print(result)
# [datetime.datetime(2020, 5, 6, 0, 0), datetime.datetime(2021, 10, 1, 0, 0)]
</code></pre>
<p><code>dateutil</code>解析通用日期格式：</p>
<pre><code>print(parse('2020/5/6'))
# 2020-05-06 00:00:00

print(parse('Jan 31, 2021 10:25 AM'))
# 2021-01-31 10:25:00

print(parse('5/6/2021', dayfirst=True))  # 日期出现在月份之前
# 2021-06-05 00:00:00
</code></pre>
<p>pandas主要是面向处理日期数组的，无论是用作轴索引还是用作DataFrame中的列。
<code>to_datetime</code>方法可以转换很多不同的日期表示格式。
<code>to_datetime</code>方法还可以处理那些被认为是缺失值的值（None、空字符串等）。
<code>NaT</code>（Not a time）是pandas中时间戳数据的是null值。</p>
<pre><code>datestrs = ['2020/5/6 12:00:00', '2021/10/1 09:00:00']
result = pd.to_datetime(datestrs)
print(result)
# DatetimeIndex(['2020-05-06 12:00:00', '2021-10-01 09:00:00'], dtype='datetime64[ns]', freq=None)

idx = pd.to_datetime(datestrs + [None])
print(idx)
# DatetimeIndex(['2020-05-06 12:00:00', '2021-10-01 09:00:00', 'NaT'], dtype='datetime64[ns]', freq=None)
print(idx[2])
# NaT
print(pd.isnull(idx))
# [False False  True]
</code></pre>
<h2 id="_3">时间序列基础</h2>
<pre><code>from datetime import datetime
import pandas as pd
import numpy as np
</code></pre>
<h3 id="datetimeindex">DatetimeIndex</h3>
<p>pandas中的基础时间序列种类是由时间戳索引的Series，在pandas外部则通常表示为Python字符串或<code>datetime</code>对象。</p>
<p>所有使用<code>datetime</code>对象的地方都可以用<code>Timestamp</code>。</p>
<pre><code>dates = [
    datetime(2021, 10, 1),
    datetime(2021, 10, 3),
    datetime(2021, 10, 5),
    datetime(2021, 10, 7),
    datetime(2021, 10, 9),
    datetime(2021, 10, 11)
]
data = np.random.rand(6)
ts = pd.Series(data, index=dates)
print(ts)
# 2021-10-01    0.678297
# 2021-10-03    0.538631
# 2021-10-05    0.934413
# 2021-10-07    0.018534
# 2021-10-09    0.938441
# 2021-10-11    0.173329
# dtype: float64
</code></pre>
<p>这些<code>datetime</code>对象被放入<code>DatetimeIndex</code>中。</p>
<pre><code>print(ts.index)
# DatetimeIndex(['2021-10-01', '2021-10-03', '2021-10-05', '2021-10-07',
#                '2021-10-09', '2021-10-11'],
#               dtype='datetime64[ns]', freq=None)
</code></pre>
<p><code>DatetimeIndex</code>中的标量值是<code>pandas</code>的<code>Timestamp</code>对象：</p>
<pre><code>stamp = ts.index[0]
print(stamp)
# 2021-10-01 00:00:00
</code></pre>
<p>和其他Series类似，不同索引的时间序列之间的算术运算在日期上自动对齐：</p>
<pre><code>print(ts + ts[::2])  # ts[::2]会将ts中每隔一个的元素选择出
# 2021-10-01    1.356595
# 2021-10-03         NaN
# 2021-10-05    1.868825
# 2021-10-07         NaN
# 2021-10-09    1.876883
# 2021-10-11         NaN
# dtype: float64
</code></pre>
<p>pandas使用NumPy的<code>datetime64</code>数据类型在纳秒级的分辨率下存储时间戳</p>
<pre><code>print(ts.index.dtype)
# datetime64[ns]
</code></pre>
<h3 id="_4">索引、选择、子集</h3>
<p>当基于标签进行索引和选择时，时间序列的行为和其他的pandas.Series类似：</p>
<pre><code>stamp = ts.index[2]
print(ts[stamp])
# 0.9344125159374457  对应2021-10-05
</code></pre>
<p>也可以传递一个能解释为日期的字符串：</p>
<pre><code>print(ts['10/9/2021'])
print(ts['20211003'])
</code></pre>
<p>对一个长的时间序列，可以传递一个年份或一个年份和月份来选择数据切片：</p>
<pre><code>data = np.random.randn(1000)
longer_ts = pd.Series(
    data,
    index=pd.date_range('1/1/2021', periods=1000)
)

print(longer_ts)
# 2021-01-01   -0.009192
# 2021-01-02   -1.079068
# 2021-01-03   -1.851176
# 2021-01-04    1.347109
# 2021-01-05   -0.236394
#                 ...
# 2023-09-23   -1.317943
# 2023-09-24    0.201741
# 2023-09-25    0.442282
# 2023-09-26    0.176137
# 2023-09-27    1.146437
# Freq: D, Length: 1000, dtype: float64
</code></pre>
<p>字符串’2001’被解释为一个年份，并选择了相应的时间区间。</p>
<pre><code>print(longer_ts['2021'])
# 2021-01-01    2.170411
# 2021-01-02    1.186933
# 2021-01-03    0.399262
# 2021-01-04   -1.042606
# 2021-01-05    2.082112
#                 ...
# 2021-12-27   -0.988282
# 2021-12-28    0.598683
# 2021-12-29    2.770580
# 2021-12-30   -1.463262
# 2021-12-31   -1.642846
# Freq: D, Length: 365, dtype: float64
</code></pre>
<p>指定了年份和月份也是有效的。</p>
<pre><code>print(longer_ts['2021-10'])
# 2021-10-01    0.712265
# 2021-10-02    1.195221
# 2021-10-03   -1.930220
# 2021-10-04   -0.720816
# 2021-10-05    0.081777
# 2021-10-06   -0.037466
# 2021-10-07    3.737303
# 2021-10-08    1.620383
# 2021-10-09    0.990797
# 2021-10-10    0.507850
# 2021-10-11    0.846935
# 2021-10-12    0.996947
# 2021-10-13   -1.078558
# 2021-10-14    0.871832
# 2021-10-15   -0.591698
# 2021-10-16   -0.805463
# 2021-10-17    0.160528
# 2021-10-18   -0.028474
# 2021-10-19    2.305579
# 2021-10-20   -1.132288
# 2021-10-21    0.649980
# 2021-10-22    0.615327
# 2021-10-23    0.185108
# 2021-10-24    0.857199
# 2021-10-25   -1.473752
# 2021-10-26   -0.895161
# 2021-10-27   -0.432717
# 2021-10-28    0.734504
# 2021-10-29    1.892493
# 2021-10-30    0.456619
# 2021-10-31   -0.255288
# Freq: D, dtype: float64
</code></pre>
<p>使用<code>datetime</code>对象进行切片也是可以的：</p>
<pre><code>print(longer_ts[datetime(2023, 1, 6):])
# 2023-01-06    0.952591
# 2023-01-07   -0.900259
# 2023-01-08    0.925332
# 2023-01-09    0.173215
# 2023-01-10   -0.507791
#                 ...
# 2023-09-23   -0.319989
# 2023-09-24   -1.105417
# 2023-09-25   -2.118769
# 2023-09-26    0.009420
# 2023-09-27   -0.310281
# Freq: D, Length: 265, dtype: float64
</code></pre>
<p>因为大部分的时间序列数据是按时间顺序排序的，可以使用不包含在时间序列中的时间戳进行切片，以执行范围查询：</p>
<pre><code>print(longer_ts['2021/10/1':'2021/10/5'])
# 2021-10-01   -0.591853
# 2021-10-02   -1.554564
# 2021-10-03   -0.712585
# 2021-10-04   -0.326657
# 2021-10-05    1.044887
# Freq: D, dtype: float64
</code></pre>
<p>使用<code>truncate</code>在两个日期间对Series进行切片：</p>
<pre><code>print(longer_ts.truncate(after='2021/10/1'))
# 2021-01-01   -0.906685
# 2021-01-02   -0.470732
# 2021-01-03   -0.041316
# 2021-01-04   -0.287356
# 2021-01-05    0.104268
#                 ...
# 2021-09-27   -0.669198
# 2021-09-28   -2.222169
# 2021-09-29   -0.653814
# 2021-09-30   -0.625868
# 2021-10-01    0.872684
# Freq: D, Length: 274, dtype: float64
</code></pre>
<p>上面这些操作也都适用于DataFrame，并在其行上进行索引：</p>
<pre><code>dates = pd.date_range('10/1/2020', periods=100, freq='W-WED')
data = np.random.randn(100, 4)
long_df = pd.DataFrame(
    data,
    index=dates,
    columns=['Colorado', 'Texas', 'New York', 'Ohio']
)

print(long_df)
#             Colorado     Texas  New York      Ohio
# 2020-10-07 -1.186789  2.020634  0.300076 -0.955234
# 2020-10-14  1.502838  0.965368 -0.797539 -0.292833
# ...              ...       ...       ...       ...
# 2022-08-24 -0.253116 -0.263307  0.602425  0.370599
# 2022-08-31  0.907918  0.091939  0.789694  2.781535
# [100 rows x 4 columns]


print(long_df.loc['10-2020'])
#             Colorado     Texas  New York      Ohio
# 2020-10-07  1.031616 -1.812038 -0.446577  0.395656
# 2020-10-14 -0.673167  0.198804 -0.439141  0.086004
# 2020-10-21 -1.139786  0.716820  0.006516 -0.284335
# 2020-10-28 -0.637939  1.647810 -0.750786  0.140637
</code></pre>
<h3 id="_5">含有重复索引的时间序列</h3>
<p>在某些应用中，可能会有多个数据观察值落在特定的时间戳上。下面是个例子：</p>
<pre><code>dates = pd.DatetimeIndex(
    ['2021/1/1', '2021/1/2', '2021/1/2', '2021/1/2', '2021/1/3']
)
dup_ts = pd.Series(
    np.arange(5),
    index=dates
)
print(dup_ts)
# 2021-01-01    0
# 2021-01-02    1
# 2021-01-02    2
# 2021-01-02    3
# 2021-01-03    4
# dtype: int64
</code></pre>
<p>通过检查索引的<code>is_unique</code>属性，可以看出索引并不是唯一的：</p>
<pre><code>print(dup_ts.index.is_unique)
# False
</code></pre>
<p>对上面的Series进行索引，结果是标量值还是Series切片取决于是否有时间戳是重复的：</p>
<pre><code>result = dup_ts['2021/1/3']
print(result)
# 4
result = dup_ts['2021/1/2']
print(result)
# 2021-01-02    1
# 2021-01-02    2
# 2021-01-02    3
# dtype: int64
</code></pre>
<p>假设想要聚合含有非唯一时间戳的数据。一种方式就是使用<code>groupby</code>并传递<code>level=0</code>：</p>
<pre><code>grouped = dup_ts.groupby(level=0)
result = grouped.mean()
print(result)
# 2021-01-01    0.0
# 2021-01-02    2.0
# 2021-01-03    4.0
# dtype: float64

result = grouped.count()
print(result)
# 2021-01-01    1
# 2021-01-02    3
# 2021-01-03    1
# dtype: int64
</code></pre>
<h2 id="_6">日期范围、频率和移位</h2>
<pre><code>from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from pandas.tseries.offsets import Hour, Minute, Day, MonthEnd
</code></pre>
<p>pandas的通用时间序列是不规则的，即时间序列的频率不是固定的。
但有时需要处理固定频率的场景，例如每日的、每月的或每15分钟的时间序列数据。
可以通过调用resample方法将样本时间序列转换为固定的每日频率数据。</p>
<p>在频率间转换，又称为重新采样。</p>
<pre><code>dates = [
    datetime(2021, 10, 1),
    datetime(2021, 10, 3),
    datetime(2021, 10, 5),
    datetime(2021, 10, 7),
    datetime(2021, 10, 9),
    datetime(2021, 10, 11)
]
data = np.random.rand(6)
ts = pd.Series(data, index=dates)
print(ts)
# 2021-10-01    0.956685
# 2021-10-03    0.817168
# 2021-10-05    0.275543
# 2021-10-07    0.614226
# 2021-10-09    0.061377
# 2021-10-11    0.357080
# dtype: float64


resampler = ts.resample('D')  # 字符串’D’被解释为每日频率
print(resampler)
# DatetimeIndexResampler [freq=&lt;Day&gt;, axis=0, closed=left, label=left, convention=start, origin=start_day]
</code></pre>
<h3 id="_7">生成日期范围</h3>
<p><code>pandas.date_range</code>是用于根据特定频率生成指定长度的<code>DatetimeIndex</code>。
默认情况下，<code>date_range</code>生成的是每日的时间戳。如果只传递一个起始或结尾日期，你必须传递一个用于生成范围的数字。
开始日期和结束日期严格定义了生成日期索引的边界。</p>
<pre><code>index = pd.date_range('2021/1/1', '2021/1/30')
print(index)
index = pd.date_range(start='2021/1/1', periods=30)
print(index)
index = pd.date_range(end='2021/1/30', periods=30)
print(index)
# DatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04',
#                '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08',
#                '2021-01-09', '2021-01-10', '2021-01-11', '2021-01-12',
#                '2021-01-13', '2021-01-14', '2021-01-15', '2021-01-16',
#                '2021-01-17', '2021-01-18', '2021-01-19', '2021-01-20',
#                '2021-01-21', '2021-01-22', '2021-01-23', '2021-01-24',
#                '2021-01-25', '2021-01-26', '2021-01-27', '2021-01-28',
#                '2021-01-29', '2021-01-30'],
#               dtype='datetime64[ns]', freq='D')
</code></pre>
<p>默认情况下，<code>date_range</code>保留开始或结束时间戳的时间（如果有的话）。
<code>normalize</code>选项可以实现生成的是标准化为零点的时间戳。</p>
<pre><code>index = pd.date_range('2021/1/1 12:56:30', periods=5)
print(index)
# DatetimeIndex(['2021-01-01 12:56:30', '2021-01-02 12:56:30',
#                '2021-01-03 12:56:30', '2021-01-04 12:56:30',
#                '2021-01-05 12:56:30'],
#               dtype='datetime64[ns]', freq='D')
index = pd.date_range('2021/1/1 12:56:30', periods=5, normalize=True)
print(index)
# DatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04',
#                '2021-01-05'],
#               dtype='datetime64[ns]', freq='D')
</code></pre>
<p>Pandas时间序列：频率和日期偏移量。</p>
<p>pandas中的频率是由一个基础频率(例如“日”、“月”)和一个乘数组成。
基础频率通常以一个字符串别名表示，比如“D”表示日，“M”表示月。
对于每个基础频率，都有一个被称为日期偏移量(dateoffset)的对象与之对应，比如日期偏移量<code>Hour</code>对应的频率是<code>H</code>。</p>
<p>常用频率与日期偏移量。</p>
<table>
<thead>
<tr>
<th>频率</th>
<th>日期偏移量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>D</td>
<td>Day</td>
<td>日历日</td>
</tr>
<tr>
<td>B</td>
<td>BusinessDay</td>
<td>工作日</td>
</tr>
<tr>
<td>H</td>
<td>Hour</td>
<td>小时</td>
</tr>
<tr>
<td>T/min</td>
<td>Minute</td>
<td>分</td>
</tr>
<tr>
<td>S</td>
<td>Second</td>
<td>秒</td>
</tr>
<tr>
<td>L/ms</td>
<td>Milli</td>
<td>毫秒</td>
</tr>
<tr>
<td>U</td>
<td>Micro</td>
<td>微秒</td>
</tr>
<tr>
<td>M</td>
<td>MonthEnd</td>
<td>每月最后一个日历日</td>
</tr>
<tr>
<td>BM</td>
<td>BusinessMonthEnd</td>
<td>每月最后一个工作日</td>
</tr>
<tr>
<td>MS</td>
<td>MonthBegin</td>
<td>每月第一个日历日</td>
</tr>
<tr>
<td>BMS</td>
<td>BussinessMonthBegin</td>
<td>每月第一个工作日</td>
</tr>
<tr>
<td>W-MON, W-TUE, ...</td>
<td>Week</td>
<td>指定星期几(MON,TUE,WED,THU,FRI,SAT,SUN)</td>
</tr>
<tr>
<td>WOM-1MON,WOM-2MON, ...</td>
<td>WeekOfMonth</td>
<td>产生每月第一,第二,第三或第四周的星期几。例如WOM-3FRI表示每月第3个星期五</td>
</tr>
<tr>
<td>Q-JAN,Q-FEB, ...</td>
<td>QuarterEnd</td>
<td>以指定月份结束的年度，每季度最后一个月的最后一个日历日</td>
</tr>
<tr>
<td>BQ-JAN,BQ-FEB, ...</td>
<td>BusinessQuarterEnd</td>
<td>以指定月份结束的年度，每季度最后一个月的最后一个工作日</td>
</tr>
<tr>
<td>QS-JAN,QS-FEB, ...</td>
<td>QuarterBegin</td>
<td>以指定月份结束的年度，每季度最后一个月的第一个日历日</td>
</tr>
<tr>
<td>BQS-JAN,BQS-FEB, ...</td>
<td>BusinessQuarterBegin</td>
<td>以指定月份结束的年度，每季度最后一个月的第一个工作日</td>
</tr>
<tr>
<td>A-JAN,A-FEB, ...</td>
<td>YearEnd</td>
<td>每年指定月份的最后一个日历日</td>
</tr>
<tr>
<td>BA-JAN,BA-FEB, ...</td>
<td>BusinessYearEnd</td>
<td>每年指定月份的最后一个工作日</td>
</tr>
<tr>
<td>AS-JAN,AS-FEB, ...</td>
<td>YearBegin</td>
<td>每年指定月份的第一个日历日</td>
</tr>
<tr>
<td>BAS-JAN,BAS-FEB, ...</td>
<td>BusinessYearBegin</td>
<td>每年指定月份的第一个工作日</td>
</tr>
</tbody>
</table>
<h3 id="_8">频率和日期偏置</h3>
<p>pandas中的频率是由基础频率和倍数组成的。
基础频率通常会有字符串别名，例如<code>M</code>代表每月，<code>H</code>代表每小时。
对于每个基础频率，都有一个对象可以被用于定义日期偏置。</p>
<p>例如，每小时的频率可以使用<code>Hour</code>类来表示：
```hour = Hour()
print(hour)</p>
<h1 id="_9"><Hour></h1>
<pre><code>
可以传递一个整数来定义偏置量的倍数：
</code></pre>
<p>four_hours = Hour(4)
print(four_hours)</p>
<h1 id="4-hours">&lt;4 * Hours&gt;</h1>
<pre><code>
在大多数应用中，不需要显式地创建这些对象，而是使用字符串别名，如`H`或`4H`。在基础频率前放一个整数就可以生成倍数：
</code></pre>
<p>ts = pd.date_range('2021/1/1', '2021/1/2 23:59', freq='4h')
print(ts)</p>
<h1 id="datetimeindex2021-01-01-000000-2021-01-01-040000">DatetimeIndex(['2021-01-01 00:00:00', '2021-01-01 04:00:00',</h1>
<h1 id="2021-01-01-080000-2021-01-01-120000">'2021-01-01 08:00:00', '2021-01-01 12:00:00',</h1>
<h1 id="2021-01-01-160000-2021-01-01-200000">'2021-01-01 16:00:00', '2021-01-01 20:00:00',</h1>
<h1 id="2021-01-02-000000-2021-01-02-040000">'2021-01-02 00:00:00', '2021-01-02 04:00:00',</h1>
<h1 id="2021-01-02-080000-2021-01-02-120000">'2021-01-02 08:00:00', '2021-01-02 12:00:00',</h1>
<h1 id="2021-01-02-160000-2021-01-02-200000">'2021-01-02 16:00:00', '2021-01-02 20:00:00'],</h1>
<h1 id="dtypedatetime64ns-freq4h">dtype='datetime64[ns]', freq='4H')</h1>
<pre><code>
多个偏置可以通过加法进行联合：
</code></pre>
<p>print(Hour(2) + Minute(30))</p>
<h1 id="150-minutes">&lt;150 * Minutes&gt;</h1>
<pre><code>
类似地，可以传递频率字符串：
</code></pre>
<p>ts = pd.date_range('2021/1/1', '2021/1/1 23:59', freq='4h30min')
print(ts)</p>
<h1 id="datetimeindex2021-01-01-000000-2021-01-01-043000">DatetimeIndex(['2021-01-01 00:00:00', '2021-01-01 04:30:00',</h1>
<h1 id="2021-01-01-090000-2021-01-01-133000">'2021-01-01 09:00:00', '2021-01-01 13:30:00',</h1>
<h1 id="2021-01-01-180000-2021-01-01-223000">'2021-01-01 18:00:00', '2021-01-01 22:30:00'],</h1>
<h1 id="dtypedatetime64ns-freq270t">dtype='datetime64[ns]', freq='270T')</h1>
<pre><code>
有些频率描述点的时间并不是均匀分隔的。例如，`M`（日历月末）和`BM`（月内最后工作日）取决于当月天数，月末是否是周末。我们将这些日期称为锚定偏置量。



#### 月中某星期的日期

&quot;月中某星期&quot;（week of month ）的日期是一个有用的频率类，以`WOM`开始。
</code></pre>
<p>rng = pd.date_range('2021-1-1', '2021-9-1', freq='WOM-3FRI')  # 每月第三个星期五
print(rng)</p>
<h1 id="datetimeindex2021-01-15-2021-02-19-2021-03-19-2021-04-16">DatetimeIndex(['2021-01-15', '2021-02-19', '2021-03-19', '2021-04-16',</h1>
<h1 id="2021-05-21-2021-06-18-2021-07-16-2021-08-20">'2021-05-21', '2021-06-18', '2021-07-16', '2021-08-20'],</h1>
<h1 id="dtypedatetime64ns-freqwom-3fri">dtype='datetime64[ns]', freq='WOM-3FRI')</h1>
<pre><code>




### 移位（前向和后向）日期

&quot;移位&quot;是指将日期按时间向前移动或向后移动。

Series和DataFrame都有一个`shift`方法用于进行简单的前向或后向移位，而不改变索引。
进行移位时，会在时间序列的起始位或结束位引入缺失值。
</code></pre>
<p>data = [0.882972, 1.363282, -0.687750, -0.048117]
ts = pd.Series(data, index=pd.date_range('2021-1-1', periods=4, freq='M'))
print(ts)</p>
<h1 id="2021-01-31-0882972">2021-01-31    0.882972</h1>
<h1 id="2021-02-28-1363282">2021-02-28    1.363282</h1>
<h1 id="2021-03-31-0687750">2021-03-31   -0.687750</h1>
<h1 id="2021-04-30-0048117">2021-04-30   -0.048117</h1>
<h1 id="freq-m-dtype-float64">Freq: M, dtype: float64</h1>
<p>print(ts.shift(2))</p>
<h1 id="2021-01-31-nan">2021-01-31         NaN</h1>
<h1 id="2021-02-28-nan">2021-02-28         NaN</h1>
<h1 id="2021-03-31-0882972">2021-03-31    0.882972</h1>
<h1 id="2021-04-30-1363282">2021-04-30    1.363282</h1>
<h1 id="freq-m-dtype-float64_1">Freq: M, dtype: float64</h1>
<p>print(ts.shift(-2))</p>
<h1 id="2021-01-31-0687750">2021-01-31   -0.687750</h1>
<h1 id="2021-02-28-0048117">2021-02-28   -0.048117</h1>
<h1 id="2021-03-31-nan">2021-03-31         NaN</h1>
<h1 id="2021-04-30-nan">2021-04-30         NaN</h1>
<h1 id="freq-m-dtype-float64_2">Freq: M, dtype: float64</h1>
<pre><code>
`shift`常用于计算时间序列或DataFrame多列时间序列的百分比变化：
</code></pre>
<p>print(ts/ts.shift(1))</p>
<h1 id="2021-01-31-nan_1">2021-01-31         NaN</h1>
<h1 id="2021-02-28-1543970">2021-02-28    1.543970</h1>
<h1 id="2021-03-31-0504481">2021-03-31   -0.504481</h1>
<h1 id="2021-04-30-0069963">2021-04-30    0.069963</h1>
<h1 id="freq-m-dtype-float64_3">Freq: M, dtype: float64</h1>
<p>print(ts/ts.shift(1) - 1)</p>
<h1 id="2021-01-31-nan_2">2021-01-31         NaN</h1>
<h1 id="2021-02-28-0543970">2021-02-28    0.543970</h1>
<h1 id="2021-03-31-1504481">2021-03-31   -1.504481</h1>
<h1 id="2021-04-30-0930037">2021-04-30   -0.930037</h1>
<h1 id="freq-m-dtype-float64_4">Freq: M, dtype: float64</h1>
<pre><code>
如果频率是已知的，则可以将频率传递给`shift`来推移时间戳：
</code></pre>
<p>print(ts.shift(2, freq='M'))  # 原始数据的“月“增加了偏移值</p>
<h1 id="2021-03-31-0882972_1">2021-03-31    0.882972</h1>
<h1 id="2022021-10-31-0000001-04-30-1363282">2022021-10-31 00:00:001-04-30    1.363282</h1>
<h1 id="2021-05-31-0687750">2021-05-31   -0.687750</h1>
<h1 id="2021-06-30-0048117">2021-06-30   -0.048117</h1>
<h1 id="freq-m-dtype-float64_5">Freq: M, dtype: float64</h1>
<p>print(ts.shift(2, freq='D'))  # 原始数据的“日“增加了偏移值</p>
<h1 id="2021-02-02-0882972">2021-02-02    0.882972</h1>
<h1 id="2021-03-02-1363282">2021-03-02    1.363282</h1>
<h1 id="2021-04-02-0687750">2021-04-02   -0.687750</h1>
<h1 id="2021-05-02-0048117">2021-05-02   -0.048117</h1>
<h1 id="dtype-float64">dtype: float64</h1>
<p>print(ts.shift(2, freq='90T'))  # 原始数据的“小时“增加了偏移值</p>
<h1 id="2021-01-31-030000-0882972">2021-01-31 03:00:00    0.882972</h1>
<h1 id="2021-02-28-030000-1363282">2021-02-28 03:00:00    1.363282</h1>
<h1 id="2021-03-31-030000-0687750">2021-03-31 03:00:00   -0.687750</h1>
<h1 id="2021-04-30-030000-0048117">2021-04-30 03:00:00   -0.048117</h1>
<h1 id="dtype-float64_1">dtype: float64</h1>
<pre><code>

#### 使用偏置进行移位日期

pandas日期偏置也可以使用`datetime`或`Timestamp`对象完成：
</code></pre>
<p>now = datetime(2021, 10, 9)
print(now)</p>
<h1 id="2021-10-09-000000">2021-10-09 00:00:00</h1>
<p>print(now + 3 * Day())</p>
<h1 id="2021-10-12-000000">2021-10-12 00:00:00</h1>
<pre><code>
锚定偏置可以使用`rollforward`和`rollback`分别显式地将日期向前或向后&quot;滚动&quot;。
如果添加了一个锚定偏置量，比如`MonthEnd`，根据频率规则，第一个增量会将日期“前滚”到下一个日期：
</code></pre>
<p>print(now + MonthEnd())  # “前滚”到当前月的月底</p>
<h1 id="2021-10-31-000000">2021-10-31 00:00:00</h1>
<p>print(now + MonthEnd(2))  # 注意这里的序列号，当前月是1,下个月是2</p>
<h1 id="2021-11-30-000000">2021-11-30 00:00:00</h1>
<p>offset = MonthEnd()
print(offset.rollback(now))</p>
<h1 id="2021-09-30-000000">2021-09-30 00:00:00</h1>
<p>print(offset.rollforward(now))</p>
<h1 id="2021-10-31-000000_1">2021-10-31 00:00:00</h1>
<pre><code>
将移位方法与`groupby`一起使用是日期偏置的一种创造性用法：
</code></pre>
<p>ts = pd.Series(
    np.random.randn(20),
    index=pd.date_range('2021/1/1', periods=20, freq='4d')
)
print(ts)</p>
<h1 id="2021-01-01-0674348">2021-01-01    0.674348</h1>
<h1 id="2021-01-05-1437803">2021-01-05   -1.437803</h1>
<h1 id="2021-01-09-0079218">2021-01-09   -0.079218</h1>
<h1 id="2021-01-13-1444890">2021-01-13   -1.444890</h1>
<h1 id="2021-01-17-0643279">2021-01-17    0.643279</h1>
<h1 id="2021-01-21-1089965">2021-01-21    1.089965</h1>
<h1 id="2021-01-25-0021876">2021-01-25    0.021876</h1>
<h1 id="2021-01-29-0692138">2021-01-29    0.692138</h1>
<h1 id="2021-02-02-0833496">2021-02-02    0.833496</h1>
<h1 id="2021-02-06-1082616">2021-02-06    1.082616</h1>
<h1 id="2021-02-10-0729415">2021-02-10   -0.729415</h1>
<h1 id="2021-02-14-0271186">2021-02-14    0.271186</h1>
<h1 id="2021-02-18-1416218">2021-02-18   -1.416218</h1>
<h1 id="2021-02-22-0780402">2021-02-22   -0.780402</h1>
<h1 id="2021-02-26-0113773">2021-02-26   -0.113773</h1>
<h1 id="2021-03-02-2095338">2021-03-02    2.095338</h1>
<h1 id="2021-03-06-0302612">2021-03-06   -0.302612</h1>
<h1 id="2021-03-10-1113632">2021-03-10    1.113632</h1>
<h1 id="2021-03-14-1314581">2021-03-14   -1.314581</h1>
<h1 id="2021-03-18-0947746">2021-03-18    0.947746</h1>
<h1 id="freq-4d-dtype-float64">Freq: 4D, dtype: float64</h1>
<p>print(ts.groupby(offset.rollforward).mean())  # 前滚至当月月底，计算当月平均值</p>
<h1 id="2021-01-31-0019962">2021-01-31    0.019962</h1>
<h1 id="2021-02-28-0121787">2021-02-28   -0.121787</h1>
<h1 id="2021-03-31-0507905">2021-03-31    0.507905</h1>
<h1 id="dtype-float64_2">dtype: float64</h1>
<h1 id="resample">使用resample是更简单更快捷的方法</h1>
<p>print(ts.resample('M').mean())</p>
<h1 id="2021-01-31-0019962_1">2021-01-31    0.019962</h1>
<h1 id="2021-02-28-0121787_1">2021-02-28   -0.121787</h1>
<h1 id="2021-03-31-0507905_1">2021-03-31    0.507905</h1>
<h1 id="freq-m-dtype-float64_6">Freq: M, dtype: float64</h1>
<pre><code>




## 时区处理

时区通常被表示为UTC的偏置。
在Python语言中，时区信息来源于第三方库pytz（可以使用pip或conda安装），其中公开了Olson数据库，这是世界时区信息的汇编。
pandas封装了pytz的功能。
</code></pre>
<p>from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from pandas.tseries.offsets import Hour, Minute, Day, MonthEnd
import pytz</p>
<pre><code>
#### common_timezones

</code></pre>
<p>tz = pytz.common_timezones[-5:]  # 读取common_timezones这个列表的最后5个元素
print(tz)</p>
<h1 id="useastern-ushawaii-usmountain-uspacific-utc">['US/Eastern', 'US/Hawaii', 'US/Mountain', 'US/Pacific', 'UTC']</h1>
<pre><code>要获得pytz的时区对象，可使用pytz.timezone：
</code></pre>
<p>tz = pytz.timezone('Asia/Shanghai')
print(tz)</p>
<pre><code>


#### 时区的本地化和转换

默认情况下，pandas中的时间序列是时区简单型的。
</code></pre>
<p>rng = pd.date_range('2021/1/1 9:30', periods=6, freq='D')
ts = pd.Series(np.random.randn(len(rng)), index=rng)</p>
<p>print(rng)</p>
<h1 id="datetimeindex2021-01-01-093000-2021-01-02-093000">DatetimeIndex(['2021-01-01 09:30:00', '2021-01-02 09:30:00',</h1>
<h1 id="2021-01-03-093000-2021-01-04-093000">'2021-01-03 09:30:00', '2021-01-04 09:30:00',</h1>
<h1 id="2021-01-05-093000-2021-01-06-093000">'2021-01-05 09:30:00', '2021-01-06 09:30:00'],</h1>
<h1 id="dtypedatetime64ns-freqd">dtype='datetime64[ns]', freq='D')</h1>
<p>print(ts)</p>
<h1 id="2021-01-01-093000-0339822">2021-01-01 09:30:00    0.339822</h1>
<h1 id="2021-01-02-093000-1356382">2021-01-02 09:30:00    1.356382</h1>
<h1 id="2021-01-03-093000-0475429">2021-01-03 09:30:00    0.475429</h1>
<h1 id="2021-01-04-093000-1826654">2021-01-04 09:30:00    1.826654</h1>
<h1 id="2021-01-05-093000-0245510">2021-01-05 09:30:00   -0.245510</h1>
<h1 id="2021-01-06-093000-0705274">2021-01-06 09:30:00    0.705274</h1>
<h1 id="freq-d-dtype-float64">Freq: D, dtype: float64</h1>
<p>print(ts.index.tz)  # 索引的tz属性是None</p>
<h1 id="none">None</h1>
<pre><code>
日期范围可以通过时区集合来生成：
</code></pre>
<p>rng = pd.date_range('2021/3/1', periods=10, freq='D', tz='UTC')
print(rng)</p>
<h1 id="datetimeindex2021-03-01-0000000000-2021-03-02-0000000000">DatetimeIndex(['2021-03-01 00:00:00+00:00', '2021-03-02 00:00:00+00:00',</h1>
<h1 id="2021-03-03-0000000000-2021-03-04-0000000000">'2021-03-03 00:00:00+00:00', '2021-03-04 00:00:00+00:00',</h1>
<h1 id="2021-03-05-0000000000-2021-03-06-0000000000">'2021-03-05 00:00:00+00:00', '2021-03-06 00:00:00+00:00',</h1>
<h1 id="2021-03-07-0000000000-2021-03-08-0000000000">'2021-03-07 00:00:00+00:00', '2021-03-08 00:00:00+00:00',</h1>
<h1 id="2021-03-09-0000000000-2021-03-10-0000000000">'2021-03-09 00:00:00+00:00', '2021-03-10 00:00:00+00:00'],</h1>
<h1 id="dtypedatetime64ns-utc-freqd">dtype='datetime64[ns, UTC]', freq='D')</h1>
<pre><code>
使用`tz_localize`方法可以从简单时区转换到本地化时区：
</code></pre>
<p>print(ts)</p>
<h1 id="2021-01-01-093000-0294647">2021-01-01 09:30:00    0.294647</h1>
<h1 id="2021-01-02-093000-0958414">2021-01-02 09:30:00    0.958414</h1>
<h1 id="2021-01-03-093000-0424235">2021-01-03 09:30:00    0.424235</h1>
<h1 id="2021-01-04-093000-1714333">2021-01-04 09:30:00   -1.714333</h1>
<h1 id="2021-01-05-093000-0030319">2021-01-05 09:30:00   -0.030319</h1>
<h1 id="2021-01-06-093000-0744940">2021-01-06 09:30:00   -0.744940</h1>
<h1 id="freq-d-dtype-float64_1">Freq: D, dtype: float64</h1>
<p>print(ts.tz_localize('UTC'))</p>
<h1 id="2021-01-01-0930000000-0294647">2021-01-01 09:30:00+00:00    0.294647</h1>
<h1 id="2021-01-02-0930000000-0958414">2021-01-02 09:30:00+00:00    0.958414</h1>
<h1 id="2021-01-03-0930000000-0424235">2021-01-03 09:30:00+00:00    0.424235</h1>
<h1 id="2021-01-04-0930000000-1714333">2021-01-04 09:30:00+00:00   -1.714333</h1>
<h1 id="2021-01-05-0930000000-0030319">2021-01-05 09:30:00+00:00   -0.030319</h1>
<h1 id="2021-01-06-0930000000-0744940">2021-01-06 09:30:00+00:00   -0.744940</h1>
<h1 id="freq-d-dtype-float64_2">Freq: D, dtype: float64</h1>
<p>print(ts.tz_localize('Asia/Shanghai'))</p>
<h1 id="2021-01-01-0930000800-0052521">2021-01-01 09:30:00+08:00    0.052521</h1>
<h1 id="2021-01-02-0930000800-0305417">2021-01-02 09:30:00+08:00   -0.305417</h1>
<h1 id="2021-01-03-0930000800-0150215">2021-01-03 09:30:00+08:00    0.150215</h1>
<h1 id="2021-01-04-0930000800-0953715">2021-01-04 09:30:00+08:00   -0.953715</h1>
<h1 id="2021-01-05-0930000800-0543622">2021-01-05 09:30:00+08:00    0.543622</h1>
<h1 id="2021-01-06-0930000800-0222422">2021-01-06 09:30:00+08:00    0.222422</h1>
<h1 id="dtype-float64_3">dtype: float64</h1>
<p>print(ts.tz_localize('Asia/Shanghai').index)</p>
<h1 id="datetimeindex2021-01-01-0930000800-2021-01-02-0930000800">DatetimeIndex(['2021-01-01 09:30:00+08:00', '2021-01-02 09:30:00+08:00',</h1>
<h1 id="2021-01-03-0930000800-2021-01-04-0930000800">'2021-01-03 09:30:00+08:00', '2021-01-04 09:30:00+08:00',</h1>
<h1 id="2021-01-05-0930000800-2021-01-06-0930000800">'2021-01-05 09:30:00+08:00', '2021-01-06 09:30:00+08:00'],</h1>
<h1 id="dtypedatetime64ns-asiashanghai-freqnone">dtype='datetime64[ns, Asia/Shanghai]', freq=None)</h1>
<pre><code>
一旦时间序列被本地化为某个特定的时区，则可以通过`tz_convert`将其转换为另一个时区：
</code></pre>
<p>tz_sha = ts.tz_localize('Asia/Shanghai')
tz_utc = tz_sha.tz_convert('UTC')
print(tz_sha)</p>
<h1 id="2021-01-01-0930000800-0095689">2021-01-01 09:30:00+08:00    0.095689</h1>
<h1 id="2021-01-02-0930000800-0392730">2021-01-02 09:30:00+08:00   -0.392730</h1>
<h1 id="2021-01-03-0930000800-0151468">2021-01-03 09:30:00+08:00    0.151468</h1>
<h1 id="2021-01-04-0930000800-0027467">2021-01-04 09:30:00+08:00    0.027467</h1>
<h1 id="2021-01-05-0930000800-0393709">2021-01-05 09:30:00+08:00    0.393709</h1>
<h1 id="2021-01-06-0930000800-0872914">2021-01-06 09:30:00+08:00    0.872914</h1>
<h1 id="dtype-float64_4">dtype: float64</h1>
<p>print(tz_utc)</p>
<h1 id="2021-01-01-0130000000-0095689">2021-01-01 01:30:00+00:00    0.095689</h1>
<h1 id="2021-01-02-0130000000-0392730">2021-01-02 01:30:00+00:00   -0.392730</h1>
<h1 id="2021-01-03-0130000000-0151468">2021-01-03 01:30:00+00:00    0.151468</h1>
<h1 id="2021-01-04-0130000000-0027467">2021-01-04 01:30:00+00:00    0.027467</h1>
<h1 id="2021-01-05-0130000000-0393709">2021-01-05 01:30:00+00:00    0.393709</h1>
<h1 id="2021-01-06-0130000000-0872914">2021-01-06 01:30:00+00:00    0.872914</h1>
<h1 id="dtype-float64_5">dtype: float64</h1>
<h1 id="tz_localizetz_convertdatetimeindex">tz_localize和tz_convert也是DatetimeIndex的实例方法：</h1>
<p>print(ts.index.tz_localize('Asia/Shanghai'))</p>
<h1 id="datetimeindex2021-01-01-0930000800-2021-01-02-0930000800_1">DatetimeIndex(['2021-01-01 09:30:00+08:00', '2021-01-02 09:30:00+08:00',</h1>
<h1 id="2021-01-03-0930000800-2021-01-04-0930000800_1">'2021-01-03 09:30:00+08:00', '2021-01-04 09:30:00+08:00',</h1>
<h1 id="2021-01-05-0930000800-2021-01-06-0930000800_1">'2021-01-05 09:30:00+08:00', '2021-01-06 09:30:00+08:00'],</h1>
<h1 id="dtypedatetime64ns-asiashanghai-freqnone_1">dtype='datetime64[ns, Asia/Shanghai]', freq=None)</h1>
<pre><code>



### 时区感知时间戳对象的操作

与时间序列和日期范围类似，单独的`Timestamp`对象也可以从简单时间戳本地化为时区感知时间戳，并从一个时区转换为另一个时区：
</code></pre>
<p>stamp = pd.Timestamp('2021-5-1 05:30')
print(stamp)</p>
<h1 id="2021-05-01-053000">2021-05-01 05:30:00</h1>
<p>stamp_utc = stamp.tz_localize('utc')
print(stamp_utc)</p>
<h1 id="2021-05-01-0530000000">2021-05-01 05:30:00+00:00</h1>
<p>stamp_sha = stamp_utc.tz_convert('Asia/Shanghai')
print(stamp_sha)</p>
<h1 id="2021-05-01-1330000800">2021-05-01 13:30:00+08:00</h1>
<pre><code>
也可以在创建`Timestamp`的时候传递一个时区：
</code></pre>
<p>stamp_sha = pd.Timestamp('2021-5-1 05:30', tz='Asia/Shanghai')
print(stamp_sha)</p>
<h1 id="2021-05-01-0530000800">2021-05-01 05:30:00+08:00</h1>
<pre><code>
`Timestamp`对象内部存储了一个Unix纪元(1970年1月1日)至今的纳秒数量UTC时间戳数值，该数值在时区转换中是不变的：
</code></pre>
<p>print(stamp_utc.value)</p>
<h1 id="1619847000000000000">1619847000000000000</h1>
<p>print(stamp_utc.tz_convert('Asia/Shanghai').value)</p>
<h1 id="1619847000000000000_1">1619847000000000000</h1>
<pre><code>
在使用pandas的`DateOffset`进行时间算术时，pandas尽可能遵从夏时制。

首先，构造转换到DST之前的30分钟的时间：
</code></pre>
<p>stamp = pd.Timestamp('2012-3-12 1:30', tz='US/Eastern')
print(stamp)</p>
<h1 id="2012-03-12-013000-0400">2012-03-12 01:30:00-04:00</h1>
<p>print(stamp + Hour())</p>
<h1 id="2012-03-12-023000-0400">2012-03-12 02:30:00-04:00</h1>
<pre><code>
之后，构建从DST进行转换前的90分钟：
</code></pre>
<p>stamp = pd.Timestamp('2012-11-04 0:30-04:00', tz='US/Eastern')
print(stamp)</p>
<h1 id="2012-11-04-003000-0400">2012-11-04 00:30:00-04:00</h1>
<p>print(stamp + 2 * Hour())  # 只增加了一小时</p>
<h1 id="2012-11-04-013000-0500">2012-11-04 01:30:00-05:00</h1>
<pre><code>


### 不同时区间的操作

如果两个时区不同的时间序列需要联合，那么结果将是UTC时间的，因为时间戳以UTC格式存储。
</code></pre>
<p>rng = pd.date_range('2021/1/1 9:30', periods=9, freq='B')
ts = pd.Series(np.random.randn(len(rng)), index=rng)
print(ts)</p>
<h1 id="2021-01-01-093000-0715681">2021-01-01 09:30:00    0.715681</h1>
<h1 id="2021-01-04-093000-0524563">2021-01-04 09:30:00    0.524563</h1>
<h1 id="2021-01-05-093000-0482199">2021-01-05 09:30:00   -0.482199</h1>
<h1 id="2021-01-06-093000-0661303">2021-01-06 09:30:00   -0.661303</h1>
<h1 id="2021-01-07-093000-1750010">2021-01-07 09:30:00    1.750010</h1>
<h1 id="2021-01-08-093000-0251478">2021-01-08 09:30:00    0.251478</h1>
<h1 id="2021-01-11-093000-1487268">2021-01-11 09:30:00   -1.487268</h1>
<h1 id="2021-01-12-093000-0224024">2021-01-12 09:30:00   -0.224024</h1>
<h1 id="2021-01-13-093000-1621853">2021-01-13 09:30:00   -1.621853</h1>
<h1 id="freq-b-dtype-float64">Freq: B, dtype: float64</h1>
<p>ts1 = ts[:7].tz_localize('Europe/London')
ts2 = ts1[2:].tz_convert('Europe/Moscow')
result = ts1 + ts2
print(ts1)</p>
<h1 id="2021-01-01-0930000000-1393445">2021-01-01 09:30:00+00:00   -1.393445</h1>
<h1 id="2021-01-04-0930000000-1179614">2021-01-04 09:30:00+00:00   -1.179614</h1>
<h1 id="2021-01-05-0930000000-0716669">2021-01-05 09:30:00+00:00    0.716669</h1>
<h1 id="2021-01-06-0930000000-0485656">2021-01-06 09:30:00+00:00   -0.485656</h1>
<h1 id="2021-01-07-0930000000-0433000">2021-01-07 09:30:00+00:00    0.433000</h1>
<h1 id="2021-01-08-0930000000-1540745">2021-01-08 09:30:00+00:00    1.540745</h1>
<h1 id="2021-01-11-0930000000-0343751">2021-01-11 09:30:00+00:00    0.343751</h1>
<h1 id="dtype-float64_6">dtype: float64</h1>
<p>print(ts2)</p>
<h1 id="2021-01-05-1230000300-0716669">2021-01-05 12:30:00+03:00    0.716669</h1>
<h1 id="2021-01-06-1230000300-0485656">2021-01-06 12:30:00+03:00   -0.485656</h1>
<h1 id="2021-01-07-1230000300-0433000">2021-01-07 12:30:00+03:00    0.433000</h1>
<h1 id="2021-01-08-1230000300-1540745">2021-01-08 12:30:00+03:00    1.540745</h1>
<h1 id="2021-01-11-1230000300-0343751">2021-01-11 12:30:00+03:00    0.343751</h1>
<h1 id="dtype-float64_7">dtype: float64</h1>
<p>print(result)</p>
<h1 id="2021-01-01-0930000000-nan">2021-01-01 09:30:00+00:00         NaN</h1>
<h1 id="2021-01-04-0930000000-nan">2021-01-04 09:30:00+00:00         NaN</h1>
<h1 id="2021-01-05-0930000000-1433337">2021-01-05 09:30:00+00:00    1.433337</h1>
<h1 id="2021-01-06-0930000000-0971312">2021-01-06 09:30:00+00:00   -0.971312</h1>
<h1 id="2021-01-07-0930000000-0866000">2021-01-07 09:30:00+00:00    0.866000</h1>
<h1 id="2021-01-08-0930000000-3081489">2021-01-08 09:30:00+00:00    3.081489</h1>
<h1 id="2021-01-11-0930000000-0687502">2021-01-11 09:30:00+00:00    0.687502</h1>
<h1 id="dtype-float64_8">dtype: float64</h1>
<pre><code>




## 时间区间和区间算术

</code></pre>
<p>from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from pandas.tseries.offsets import Hour, Minute, Day, MonthEnd
import pytz</p>
<pre><code>
时间区间表示的是时间范围通过原索引1~202，把`year`和`quarter`联合起来，生成新索引，并替换原索引，比如一些天、一些月、一些季度或者是一些年。

`Period`类表示的正是这种数据类型，需要一个字符串或数字以及频率。
在这个例子中，`Period`对象表示的是从2007年1月1日到2007年12月31日（包含在内）的时间段。
在时间段上增加或减去整数可以方便地根据它们的频率进行移位。
</code></pre>
<p>p = pd.Period(2020, freq='A-DEC')
print(p)</p>
<h1 id="2020">2020</h1>
<p>print(p + 5)</p>
<h1 id="2025">2025</h1>
<p>print(p - 5)</p>
<h1 id="2015">2015</h1>
<pre><code>
如果两个区间拥有相同的频率，则它们的差是它们之间的单位数。
</code></pre>
<p>p1 = pd.Period(2020, freq='A-DEC')
p2 = pd.Period(2010, freq='A-DEC')
print(p1 - p2)</p>
<h1 id="10-yearends-month12">&lt;10 * YearEnds: month=12&gt;</h1>
<p>p1 = pd.Period(2020, freq='Q-DEC')
p2 = pd.Period(2010, freq='Q-DEC')
print(p1 - p2)</p>
<h1 id="40-quarterends-startingmonth12">&lt;40 * QuarterEnds: startingMonth=12&gt;</h1>
<pre><code>
使用`period_range`函数可以构造规则区间序列。`PeriodIndex`类存储的是区间的序列，可以作为任意pandas数据结构的轴索引。
</code></pre>
<p>data = np.random.randn(6)
strings = ['2021Q1', '2021Q2', '2021Q3', '2021Q4', '2022Q1', '2022Q2']</p>
<p>rng = pd.period_range('2001-1-1', '2001-6-30', freq='M')
ts = pd.Series(data, index=rng)
print(ts)</p>
<h1 id="2001-01-0481408">2001-01   -0.481408</h1>
<h1 id="2001-02-0297590">2001-02   -0.297590</h1>
<h1 id="2001-03-0860354">2001-03   -0.860354</h1>
<h1 id="2001-04-1281540">2001-04    1.281540</h1>
<h1 id="2001-05-1036551">2001-05    1.036551</h1>
<h1 id="2001-06-0522592">2001-06   -0.522592</h1>
<h1 id="freq-m-dtype-float64_7">Freq: M, dtype: float64</h1>
<p>rng = pd.PeriodIndex(strings, freq='Q-DEC')  # 字符串数组也可以使用PeriodIndex类
ts = pd.Series(data, index=rng)
print(ts)</p>
<h1 id="2021q1-2077200">2021Q1   -2.077200</h1>
<h1 id="2021q2-0948796">2021Q2   -0.948796</h1>
<h1 id="2021q3-1104737">2021Q3   -1.104737</h1>
<h1 id="2021q4-0090281">2021Q4    0.090281</h1>
<h1 id="2022q1-0431517">2022Q1    0.431517</h1>
<h1 id="2022q2-1537045">2022Q2    1.537045</h1>
<h1 id="freq-q-dec-dtype-float64">Freq: Q-DEC, dtype: float64</h1>
<pre><code>


### 区间频率转换

使用`asfreq`可以将区间和`PeriodIndex`对象转换为其他的频率。

例如，假设我们有一个年度区间，并且想要在一年的开始或结束时将其转换为月度区间。
可以将`Period('2020', 'A-DEC')`看作一段时间中的一种游标，将时间按月份划分。
</code></pre>
<p>p = pd.Period(2020, freq='A-DEC')
print(p.asfreq('M', how='start'))</p>
<h1 id="2020-01">2020-01</h1>
<p>print(p.asfreq('M', how='end'))</p>
<h1 id="2020-12">2020-12</h1>
<pre><code>
如果财年结束不在12月，则每月分期会自动调整。
按当年财年结束计算，起始年份就是上一年了。
</code></pre>
<p>p = pd.Period(2020, freq='A-JUN')
print(p.asfreq('M', how='start'))</p>
<h1 id="2019-07">2019-07</h1>
<p>print(p.asfreq('M', how='end'))</p>
<h1 id="2020-06">2020-06</h1>
<pre><code>
当从高频率向低频率转换时，pandas根据子区间的&quot;所属&quot;来决定父区间。
例如，在A-JUN频率中，Aug-2020是2020区间的一部分：
</code></pre>
<p>print(p.asfreq('A-JUN'))</p>
<pre><code>
2020通过原索引1~202，把`year`和`quarter`联合起来，生成新索引，并替换原索引。

完整的`PeriodIndex`对象或时间序列可以按照相同的语义进行转换：
</code></pre>
<p>rng = pd.period_range('2018', '2021', freq='A-DEC')
data = np.random.randn(len(rng))
ts = pd.Series(data, index=rng)</p>
<p>print(ts)</p>
<h1 id="2018-0221634">2018    0.221634</h1>
<h1 id="2019-0392724">2019   -0.392724</h1>
<h1 id="2020-0355022">2020   -0.355022</h1>
<h1 id="2021-0114000">2021    0.114000</h1>
<h1 id="freq-a-dec-dtype-float64">Freq: A-DEC, dtype: float64</h1>
<pre><code>
下面年度区间将通过`asfreq`被替换为对应于每个年度区间内的第一个月的月度区间。
</code></pre>
<p>print(ts.asfreq('M', how='start'))</p>
<h1 id="2018-01-0681874">2018-01    0.681874</h1>
<h1 id="2019-01-1006585">2019-01   -1.006585</h1>
<h1 id="2020-01-0619142">2020-01   -0.619142</h1>
<h1 id="2021-01-1445820">2021-01    1.445820</h1>
<h1 id="freq-m-dtype-float64_8">Freq: M, dtype: float64</h1>
<pre><code>
如果我们想要每年最后一个工作日，我们可以使用`B`频率来表示我们想要的是区间的末端。
</code></pre>
<p>print(ts.asfreq('B', how='end'))</p>
<h1 id="2018-12-31-1520316">2018-12-31   -1.520316</h1>
<h1 id="2019-12-31-0425544">2019-12-31   -0.425544</h1>
<h1 id="2020-12-31-0658073">2020-12-31   -0.658073</h1>
<h1 id="2021-12-31-1206881">2021-12-31    1.206881</h1>
<h1 id="freq-b-dtype-float64_1">Freq: B, dtype: float64</h1>
<pre><code>



### 季度区间频率

季度数据是会计、金融和其他领域的标准。
很多季度数据是在财年结尾报告的，通常是一年12个月中的最后一个日历日或工作日。
pandas支持所有的可能的12个季度频率从Q-JAN到Q-DEC：

下例中，财年结束于1月，2020Q4行时间为上一年11月至当年1月。可以通过转换为每日频率（asfreq）进行检查。
</code></pre>
<p>p = pd.Period('2020Q4', freq='Q-JAN')
print(p)</p>
<h1 id="2020q4">2020Q4</h1>
<p>print(p.asfreq('D', 'start'))</p>
<h1 id="2019-11-01">2019-11-01</h1>
<p>print(p.asfreq('D', 'end'))</p>
<h1 id="2020-01-31">2020-01-31</h1>
<pre><code>
假如财年结束于2月，2020Q4行时间为上一年12月至当年2月。
</code></pre>
<p>p = pd.Period('2020Q4', freq='Q-FEB')
print(p)</p>
<h1 id="2020q4_1">2020Q4</h1>
<p>print(p.asfreq('D', 'start'))</p>
<h1 id="2019-11-01_1">2019-11-01</h1>
<p>print(p.asfreq('D', 'end'))</p>
<h1 id="2020-01-31_1">2020-01-31</h1>
<pre><code>
假如财年结束于4月，2020Q4行时间为上一年12月至当年2月。
</code></pre>
<p>p = pd.Period('2020Q4', freq='Q-APR')
print(p)</p>
<h1 id="2020q4_2">2020Q4</h1>
<p>print(p.asfreq('D', 'start'))</p>
<h1 id="2020-02-01">2020-02-01</h1>
<p>print(p.asfreq('D', 'end'))</p>
<h1 id="2020-04-30">2020-04-30</h1>
<pre><code>
可以对区间数据做算术操作。例如，要获取在季度倒数第二个工作日下午4点的时间戳，可以这么做：(疑问：这里的参数e代表什么 ???)
</code></pre>
<p>p4pm = (p.asfreq('B', 'e') - 1).asfreq('T', 's') + 16 * 60
print(p4pm)</p>
<h1 id="2020-04-29-1600">2020-04-29 16:00</h1>
<p>print(p4pm.to_timestamp())</p>
<h1 id="2020-04-29-160000">2020-04-29 16:00:00</h1>
<pre><code>
可以使用`peroid_range`生成季度序列。它的算术也是一样的：
</code></pre>
<p>rng = pd.period_range('2000Q3', '2001Q4', freq='Q-JAN')
ts = pd.Series(np.arange(len(rng)), index=rng)
print(ts)</p>
<h1 id="2000q3-0">2000Q3    0</h1>
<h1 id="2000q4-1">2000Q4    1</h1>
<h1 id="2001q1-2">2001Q1    2</h1>
<h1 id="2001q2-3">2001Q2    3</h1>
<h1 id="2001q3-4">2001Q3    4</h1>
<h1 id="2001q4-5">2001Q4    5</h1>
<h1 id="freq-q-jan-dtype-int64">Freq: Q-JAN, dtype: int64</h1>
<p>new_rng = (rng.asfreq('B', 'e') - 1).asfreq('T', 's') + 16 * 60
ts.index = new_rng.to_timestamp()
print(ts)</p>
<h1 id="1999-10-28-160000-0">1999-10-28 16:00:00    0</h1>
<h1 id="2000-01-28-160000-1">2000-01-28 16:00:00    1</h1>
<h1 id="2000-04-27-160000-2">2000-04-27 16:00:00    2</h1>
<h1 id="2000-07-28-160000-3">2000-07-28 16:00:00    3</h1>
<h1 id="2000-10-30-160000-4">2000-10-30 16:00:00    4</h1>
<h1 id="2001-01-30-160000-5">2001-01-30 16:00:00    5</h1>
<h1 id="dtype-int64">dtype: int64</h1>
<pre><code>



### 将时间戳转换为区间（以及逆转换）

通过时间戳索引的Series和DataFrame可以被`to_period`方法转换为区间：
</code></pre>
<p>rng = pd.date_range('2020-01-01', periods=3, freq='M')
ts = pd.Series(np.random.randn(3), index=rng)
print(ts)</p>
<h1 id="2020-01-31-0567097">2020-01-31   -0.567097</h1>
<h1 id="2020-02-29-0634521202yearquarter2">2020-02-29    0.63452通过原索引1~202，把year和quarter联合起来，生成新索引，并替换原索引2</h1>
<h1 id="2020-03-31-0297777">2020-03-31    0.297777</h1>
<h1 id="freq-m-dtype-float64_9">Freq: M, dtype: float64</h1>
<p>pts = ts.to_period()
print(pts)</p>
<h1 id="2020-01-0567097">2020-01   -0.567097</h1>
<h1 id="2020-02-0634522">2020-02    0.634522</h1>
<h1 id="2020-03-0297777">2020-03    0.297777</h1>
<h1 id="freq-m-dtype-float64_10">Freq: M, dtype: float64</h1>
<pre><code>
由于区间是非重叠时间范围，一个时间戳只能属于给定频率的单个区间。
尽管默认情况下根据时间戳推断出新`PeriodIndex`的频率，但可以指定任何想要的频率。
在结果中包含重复的区间也是没有问题的。
</code></pre>
<p>rng = pd.date_range('2020-01-01', periods=6, freq='D')
ts = pd.Series(np.random.randn(6), index=rng)
print(ts)</p>
<h1 id="2020-01-01-0111287">2020-01-01   -0.111287</h1>
<h1 id="2020-01-02-1442234">2020-01-02    1.442234</h1>
<h1 id="2020-01-03-0767553">2020-01-03   -0.767553</h1>
<h1 id="2020-01-04-0265064">2020-01-04   -0.265064</h1>
<h1 id="2020-01-05-1200312">2020-01-05    1.200312</h1>
<h1 id="2020-01-06-1782557">2020-01-06   -1.782557</h1>
<h1 id="freq-d-dtype-float64_3">Freq: D, dtype: float64</h1>
<p>ts_m = ts.to_period('M')  # 指定period的频率（M）,输出结果包含重复period
print(ts_m)</p>
<h1 id="2020-01-0111287">2020-01   -0.111287</h1>
<h1 id="2020-01-1442234">2020-01    1.442234</h1>
<h1 id="2020-01-0767553">2020-01   -0.767553</h1>
<h1 id="2020-01-0265064">2020-01   -0.265064</h1>
<h1 id="2020-01-1200312">2020-01    1.200312</h1>
<h1 id="2020-01-1782557">2020-01   -1.782557</h1>
<h1 id="freq-m-dtype-float64_11">Freq: M, dtype: float64</h1>
<pre><code>
使用`to_timestamp`可以将区间再转换为时间戳：
</code></pre>
<p>print(ts_m.to_timestamp(how='end'))</p>
<h1 id="2020-01-31-235959999999999-0111287">2020-01-31 23:59:59.999999999   -0.111287</h1>
<h1 id="2020-01-31-235959999999999-1442234">2020-01-31 23:59:59.999999999    1.442234</h1>
<h1 id="2020-01-31-235959999999999-0767553">2020-01-31 23:59:59.999999999   -0.767553</h1>
<h1 id="2020-01-31-235959999999999-0265064">2020-01-31 23:59:59.999999999   -0.265064</h1>
<h1 id="2020-01-31-235959999999999-1200312">2020-01-31 23:59:59.999999999    1.200312</h1>
<h1 id="2020-01-31-235959999999999-1782557">2020-01-31 23:59:59.999999999   -1.782557</h1>
<h1 id="dtype-float64_9">dtype: float64</h1>
<p>print(ts_m.to_timestamp(how='start'))</p>
<h1 id="2020-01-01-0111287_1">2020-01-01   -0.111287</h1>
<h1 id="2020-01-01-1442234">2020-01-01    1.442234</h1>
<h1 id="2020-01-01-0767553">2020-01-01   -0.767553</h1>
<h1 id="2020-01-01-0265064">2020-01-01   -0.265064</h1>
<h1 id="2020-01-01-1200312">2020-01-01    1.200312</h1>
<h1 id="2020-01-01-1782557">2020-01-01   -1.782557</h1>
<h1 id="dtype-float64_10">dtype: float64</h1>
<pre><code>


### 从数组生成PeriodIndex

固定频率数据集有时存储在跨越多列的时间范围信息中。例如，在这个宏观经济数据集中，年份和季度在不同列中：
</code></pre>
<p>data = pd.read_csv('../examples/macrodata.csv')
print(data.head(5))</p>
<h1 id="year-quarter-realgdp-realcons-unemp-pop-infl-realint">year  quarter   realgdp  realcons  ...  unemp      pop  infl  realint</h1>
<h1 id="0-19590-10-2710349-17074-58-177146-000-000">0  1959.0      1.0  2710.349    1707.4  ...    5.8  177.146  0.00     0.00</h1>
<h1 id="1-19590-20-2778801-17337-51-177830-234-074">1  1959.0      2.0  2778.801    1733.7  ...    5.1  177.830  2.34     0.74</h1>
<h1 id="2-19590-30-2775488-17518-53-178657-274-109">2  1959.0      3.0  2775.488    1751.8  ...    5.3  178.657  2.74     1.09</h1>
<h1 id="3-19590-40-2785204-17537-56-179386-027-406">3  1959.0      4.0  2785.204    1753.7  ...    5.6  179.386  0.27     4.06</h1>
<h1 id="4-19600-10-2847699-17705-52-180007-231-119">4  1960.0      1.0  2847.699    1770.5  ...    5.2  180.007  2.31     1.19</h1>
<p>print(data.year)</p>
<h1 id="0-19590">0      1959.0</h1>
<h1 id="1-19590">1      1959.0</h1>
<h1 id="2-19590">2      1959.0</h1>
<h1 id="3-19590">3      1959.0</h1>
<h1 id="4-19600">4      1960.0</h1>
<h1 id="_10">...</h1>
<h1 id="198-20080">198    2008.0</h1>
<h1 id="199-20080">199    2008.0</h1>
<h1 id="200-20090">200    2009.0</h1>
<h1 id="201-20090">201    2009.0</h1>
<h1 id="202-20090">202    2009.0</h1>
<h1 id="name-year-length-203-dtype-float64">Name: year, Length: 203, dtype: float64</h1>
<p>print(data.quarter)</p>
<h1 id="0-10">0      1.0</h1>
<h1 id="1-20">1      2.0</h1>
<h1 id="2-30">2      3.0</h1>
<h1 id="3-40">3      4.0</h1>
<h1 id="4-10">4      1.0</h1>
<h1 id="_11">...</h1>
<h1 id="198-30">198    3.0</h1>
<h1 id="199-40">199    4.0</h1>
<h1 id="200-10">200    1.0</h1>
<h1 id="201-20">201    2.0</h1>
<h1 id="202-30">202    3.0</h1>
<h1 id="name-quarter-length-203-dtype-float64">Name: quarter, Length: 203, dtype: float64</h1>
<pre><code>
通过将这些数组和频率传递给`PeriodIndex`，可以联合形成DataFrame的索引
</code></pre>
<p>index = pd.PeriodIndex(year=data.year, quarter=data.quarter, freq='Q-DEC')
print(index)</p>
<h1 id="periodindex1959q1-1959q2-1959q3-1959q4-1960q1-1960q2">PeriodIndex(['1959Q1', '1959Q2', '1959Q3', '1959Q4', '1960Q1', '1960Q2',</h1>
<h1 id="1960q3-1960q4-1961q1-1961q2">'1960Q3', '1960Q4', '1961Q1', '1961Q2',</h1>
<h1 id="_12">...</h1>
<h1 id="2007q2-2007q3-2007q4-2008q1-2008q2-2008q3">'2007Q2', '2007Q3', '2007Q4', '2008Q1', '2008Q2', '2008Q3',</h1>
<h1 id="2008q4-2009q1-2009q2-2009q3">'2008Q4', '2009Q1', '2009Q2', '2009Q3'],</h1>
<h1 id="dtypeperiodq-dec-length203">dtype='period[Q-DEC]', length=203)</h1>
<p>data.index = index  # 通过原索引1~202，把year和quarter联合起来，生成新索引，并替换原索引
print(data.infl)</p>
<h1 id="1959q1-000">1959Q1    0.00</h1>
<h1 id="1959q2-234">1959Q2    2.34</h1>
<h1 id="1959q3-274">1959Q3    2.74</h1>
<h1 id="1959q4-027">1959Q4    0.27</h1>
<h1 id="1960q1-231">1960Q1    2.31</h1>
<h1 id="_13">...</h1>
<h1 id="2008q3-316">2008Q3   -3.16</h1>
<h1 id="2008q4-879">2008Q4   -8.79</h1>
<h1 id="2009q1-094">2009Q1    0.94</h1>
<h1 id="2009q2-337">2009Q2    3.37</h1>
<h1 id="2009q3-356">2009Q3    3.56</h1>
<h1 id="freq-q-dec-name-infl-length-203-dtype-float64">Freq: Q-DEC, Name: infl, Length: 203, dtype: float64</h1>
<pre><code>



## 重新采样频率转换

</code></pre>
<p>import pandas as pd
import numpy as np
from pandas.tseries.frequencies import to_offset</p>
<pre><code>
重新采样是指将时间序列从一个频率转换为另一个频率的过程。
将更高频率的数据聚合到低频率被称为向下采样，而从低频率转换到高频率称为向上采样。
并不是所有的重新采样都属于上面说的两类。例如，将W-WED（weekly on Wednesday，每周三）转换到W-FRI（每周五）既不是向上采样也不是向下采样。

pandas对象都配有`resample`方法，该方法是所有频率转换的工具函数。`resample`拥有类似于`groupby`的API；调用`resample`对数据分组，之后再调用聚合函数：

### resample方法参数

参数

* freq: 表示重采样频率，例如‘M'、‘5min'，Second(15)
* how='mean': 用于产生聚合值的函数名或数组函数，例如‘mean'、‘ohlc'、np.max等，默认是‘mean'，其他常用的值由：‘first'、‘last'、‘median'、‘max'、‘min'
* axis=0: 默认是纵轴，横轴设置axis=1
* fill_method = None: 升采样时如何插值，比如‘ffill'、‘bfill'等
* closed = ‘right': 在降采样时，各时间段的哪一段是闭合的，‘right'或‘left'，默认‘right'
* label= ‘right': 在降采样时，如何设置聚合值的标签，例如，9：30-9：35会被标记成9：30还是9：35,默认9：35
* loffset = None: 面元标签的时间校正值，比如‘-1s'或Second(-1)用于将聚合标签调早1秒
* limit=None: 在向前或向后填充时，允许填充的最大时期数
* kind = None: 聚合到时期（‘period'）或时间戳（‘timestamp'），默认聚合到时间序列的索引类型
* convention = None: 当重采样时期时，将低频率转换到高频率所采用的约定（start或end）。默认‘end'

</code></pre>
<p>rng = pd.date_range('2020-1-1', periods=100, freq='D')
ts = pd.Series(np.random.randn(len(rng)), index=rng)
print(ts)</p>
<h1 id="2020-01-01-0802409">2020-01-01    0.802409</h1>
<h1 id="2020-01-02-1147130">2020-01-02   -1.147130</h1>
<h1 id="2020-01-03-1076115">2020-01-03   -1.076115</h1>
<h1 id="2020-01-04-2097443">2020-01-04   -2.097443</h1>
<h1 id="2020-01-05-0577671">2020-01-05    0.577671</h1>
<h1 id="_14">...</h1>
<h1 id="2020-04-05-0110747">2020-04-05   -0.110747</h1>
<h1 id="2020-04-06-0132867">2020-04-06    0.132867</h1>
<h1 id="2020-04-07-0294061">2020-04-07   -0.294061</h1>
<h1 id="2020-04-08-0246155">2020-04-08   -0.246155</h1>
<h1 id="2020-04-09-0927194">2020-04-09    0.927194</h1>
<h1 id="freq-d-length-100-dtype-float64">Freq: D, Length: 100, dtype: float64</h1>
<p>print(ts.resample('M'))</p>
<h1 id="datetimeindexresampler-freq-axis0-closedright-labelright-conventionstart-originstart_day">DatetimeIndexResampler [freq=<MonthEnd>, axis=0, closed=right, label=right, convention=start, origin=start_day]</h1>
<p>print(ts.resample('M').mean())  # 把100天的数据按月groupby，并输出月末最后一天，计算平均值</p>
<h1 id="2020-01-31-0311714">2020-01-31   -0.311714</h1>
<h1 id="2020-02-29-0121526">2020-02-29    0.121526</h1>
<h1 id="2020-03-31-0051131">2020-03-31   -0.051131</h1>
<h1 id="2020-04-30-0273113">2020-04-30   -0.273113</h1>
<h1 id="freq-m-dtype-float64_12">Freq: M, dtype: float64</h1>
<p>print(ts.resample('M', kind='period').mean())  # # 把100天的数据按月groupby，并输出月份（参数period），计算平均值</p>
<h1 id="2020-01-0311714">2020-01   -0.311714</h1>
<h1 id="2020-02-0121526">2020-02    0.121526</h1>
<h1 id="2020-03-0051131">2020-03   -0.051131</h1>
<h1 id="2020-04-0273113">2020-04   -0.273113</h1>
<h1 id="freq-m-dtype-float64_13">Freq: M, dtype: float64</h1>
<pre><code>



### 向下采样

将数据聚合到一个规则的低频率上是一个常见的时间序列任务。
要聚合的数据不必是固定频率的。
期望的频率定义了用于对时间序列切片以聚合的箱体边界。例如，要将时间转换为每月，`M`或`BM`，则需要将数据分成一个月的时间间隔。
每个间隔是半闭合的，一个数据点只能属于一个时间间隔，时间间隔的并集必须是整个时间帧。

在使用resample进行向下采样数据时有些事情需要考虑：

* 每段间隔的哪一边是闭合的。
* 如何在间隔的起始或结束位置标记每个已聚合的箱体。

</code></pre>
<p>rng = pd.date_range('2020-1-1', periods=12, freq='T')
ts = pd.Series(np.arange(12), index=rng)
print(ts)</p>
<h1 id="2020-01-01-000000-0">2020-01-01 00:00:00     0</h1>
<h1 id="2020-01-01-000100-1">2020-01-01 00:01:00     1</h1>
<h1 id="2020-01-01-000200-2">2020-01-01 00:02:00     2</h1>
<h1 id="2020-01-01-000300-3">2020-01-01 00:03:00     3</h1>
<h1 id="2020-01-01-000400-4">2020-01-01 00:04:00     4</h1>
<h1 id="2020-01-01-000500-5">2020-01-01 00:05:00     5</h1>
<h1 id="2020-01-01-000600-6">2020-01-01 00:06:00     6</h1>
<h1 id="2020-01-01-000700-7">2020-01-01 00:07:00     7</h1>
<h1 id="2020-01-01-000800-8">2020-01-01 00:08:00     8</h1>
<h1 id="2020-01-01-000900-9">2020-01-01 00:09:00     9</h1>
<h1 id="2020-01-01-001000-10">2020-01-01 00:10:00    10</h1>
<h1 id="2020-01-01-001100-11">2020-01-01 00:11:00    11</h1>
<h1 id="freq-t-dtype-int64">Freq: T, dtype: int64</h1>
<pre><code>
按五分钟频率聚合分组，计算每一组的加和。频率按五分钟的增量定义了箱体边界。
默认情况下，左箱体边界是包含的，因此00:00的值是包含在00:00到00:05间隔内的。
传递`closed='right'`将间隔的闭合端改为了右边。

分组：

* left: [00:00,00:01,00:02,00:03,00:04],[00:05,00:06,00:07,00:08,00:09],[00:10,00:11]
* right:[00:00],[00:01,00:02,00:03,00:04,00:05],[00:06,00:07,00:08,00:09,00:10],[00:11]

</code></pre>
<p>result = ts.resample('5min', closed='right').sum()
print(result)</p>
<h1 id="2019-12-31-235500-0">2019-12-31 23:55:00     0</h1>
<h1 id="2020-01-01-000000-15">2020-01-01 00:00:00    15</h1>
<h1 id="2020-01-01-000500-40">2020-01-01 00:05:00    40</h1>
<h1 id="2020-01-01-001000-11">2020-01-01 00:10:00    11</h1>
<h1 id="freq-5t-dtype-int64">Freq: 5T, dtype: int64</h1>
<p>result = ts.resample('5min', closed='left').sum()
print(result)</p>
<h1 id="2020-01-01-000000-10">2020-01-01 00:00:00    10</h1>
<h1 id="2020-01-01-000500-35">2020-01-01 00:05:00    35</h1>
<h1 id="2020-01-01-001000-21">2020-01-01 00:10:00    21</h1>
<h1 id="freq-5t-dtype-int64_1">Freq: 5T, dtype: int64</h1>
<pre><code>
最后，将结果索引移动一定的数量，例如从右边缘减去一秒，以使其更清楚地表明时间戳所指的间隔。
要实现这个功能，向`loffset`传递字符串或日期偏置：
</code></pre>
<p>result = ts.resample('5min', closed='right', label='right', loffset='-1s').sum()
print(result)</p>
<h1 id="2019-12-31-235959-0">2019-12-31 23:59:59     0</h1>
<h1 id="2020-01-01-000459-15">2020-01-01 00:04:59    15</h1>
<h1 id="2020-01-01-000959-40">2020-01-01 00:09:59    40</h1>
<h1 id="2020-01-01-001459-11">2020-01-01 00:14:59    11</h1>
<h1 id="freq-5t-dtype-int64_2">Freq: 5T, dtype: int64</h1>
<h1 id="futurewarning-loffset-in-resample-and-in-grouper-is-deprecated">FutureWarning: 'loffset' in .resample() and in Grouper() is deprecated.</h1>
<h1 id="dfresamplefreq3s-loffset8h">&gt;&gt;&gt; df.resample(freq="3s", loffset="8H")</h1>
<h1 id="becomes">becomes:</h1>
<h1 id="from-pandastseriesfrequencies-import-to_offset">&gt;&gt;&gt; from pandas.tseries.frequencies import to_offset</h1>
<h1 id="df-dfresamplefreq3smean">&gt;&gt;&gt; df = df.resample(freq="3s").mean()</h1>
<h1 id="dfindex-dfindexto_timestamp-to_offset8h">&gt;&gt;&gt; df.index = df.index.to_timestamp() + to_offset("8H")</h1>
<pre><code>

#### 开端-峰值-谷值-结束（OHLC）重新采样

在金融中，为每个数据桶计算四个值是一种流行的时间序列聚合方法：第一个值（开端）、最后一个值（结束）、最大值（峰值）和最小值（谷值）。
通过使用`ohlc`聚合函数取得包含四种聚合值列的DataFrame，这些值在数据的单次扫描中被高效计算：
</code></pre>
<p>result = ts.resample('5min').ohlc()
print(result)</p>
<h1 id="open-high-low-close">open  high  low  close</h1>
<h1 id="2020-01-01-000000-0-4-0-4">2020-01-01 00:00:00     0     4    0      4</h1>
<h1 id="2020-01-01-000500-5-9-5-9">2020-01-01 00:05:00     5     9    5      9</h1>
<h1 id="2020-01-01-001000-10-11-10-11">2020-01-01 00:10:00    10    11   10     11</h1>
<pre><code>





### 向上采样与插值

当从低频率转换为高频率时，并不需要任何聚合。
</code></pre>
<p>df = pd.DataFrame(
    np.random.randn(2, 4),
    index=pd.date_range('2020/1/1', periods=2, freq='W-WED'),
    columns=['Colorado', 'Texas', 'New York', 'Ohio']
)
print(df)</p>
<h1 id="colorado-texas-new-york-ohio">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020-01-01-0228758-0758718-0025410-1001819">2020-01-01 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-08-0704541-0261414-0863335-0267101">2020-01-08 -0.704541 -0.261414 -0.863335  0.267101</h1>
<p>df_daily = df.resample('W-WED').sum()
print(df_daily)</p>
<h1 id="colorado-texas-new-york-ohio_1">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020-01-01-0228758-0758718-0025410-1001819_1">2020-01-01 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-08-0704541-0261414-0863335-0267101_1">2020-01-08 -0.704541 -0.261414 -0.863335  0.267101</h1>
<p>df_daily = df.resample('D').sum()
print(df_daily)</p>
<h1 id="colorado-texas-new-york-ohio_2">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020-01-01-0228758-0758718-0025410-1001819_2">2020-01-01 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-02-0000000-0000000-0000000-0000000">2020-01-02  0.000000  0.000000  0.000000  0.000000</h1>
<h1 id="2020-01-03-0000000-0000000-0000000-0000000">2020-01-03  0.000000  0.000000  0.000000  0.000000</h1>
<h1 id="2020-01-04-0000000-0000000-0000000-0000000">2020-01-04  0.000000  0.000000  0.000000  0.000000</h1>
<h1 id="2020-01-05-0000000-0000000-0000000-0000000">2020-01-05  0.000000  0.000000  0.000000  0.000000</h1>
<h1 id="2020-01-06-0000000-0000000-0000000-0000000">2020-01-06  0.000000  0.000000  0.000000  0.000000</h1>
<h1 id="2020-01-07-0000000-0000000-0000000-0000000">2020-01-07  0.000000  0.000000  0.000000  0.000000</h1>
<h1 id="2020-01-08-0704541-0261414-0863335-0267101_2">2020-01-08 -0.704541 -0.261414 -0.863335  0.267101</h1>
<pre><code>
当对这些数据使用聚合函数时，每一组只有一个值，并且会在间隙中产生缺失值。
使用`asfreq`方法在不聚合的情况下转换到高频率：
</code></pre>
<p>df_daily = df.resample('D').asfreq()
print(df_daily)</p>
<h1 id="colorado-texas-new-york-ohio_3">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020-01-01-0228758-0758718-0025410-1001819_3">2020-01-01 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-02-nan-nan-nan-nan">2020-01-02       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-03-nan-nan-nan-nan">2020-01-03       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-04-nan-nan-nan-nan">2020-01-04       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-05-nan-nan-nan-nan">2020-01-05       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-06-nan-nan-nan-nan">2020-01-06       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-07-nan-nan-nan-nan">2020-01-07       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-08-0704541-0261414-0863335-0267101_3">2020-01-08 -0.704541 -0.261414 -0.863335  0.267101</h1>
<pre><code>
在非星期三的日期上向前填充每周数值。`fillna`和`reindex`方法中可用的填充或插值方法可用于重采样：
</code></pre>
<p>df_daily = df.resample('D').ffill()
print(df_daily)</p>
<h1 id="colorado-texas-new-york-ohio_4">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020-01-01-0228758-0758718-0025410-1001819_4">2020-01-01 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-02-0228758-0758718-0025410-1001819">2020-01-02 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-03-0228758-0758718-0025410-1001819">2020-01-03 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-04-0228758-0758718-0025410-1001819">2020-01-04 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-05-0228758-0758718-0025410-1001819">2020-01-05 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-06-0228758-0758718-0025410-1001819">2020-01-06 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-07-0228758-0758718-0025410-1001819">2020-01-07 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-08-0704541-0261414-0863335-0267101_4">2020-01-08 -0.704541 -0.261414 -0.863335  0.267101</h1>
<pre><code>
可以同样选择仅向前填充一定数量的区间，以限制继续使用观测值的时距：
</code></pre>
<p>df_daily = df.resample('D').ffill(limit=2)
print(df_daily)</p>
<h1 id="colorado-texas-new-york-ohio_5">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020-01-01-0228758-0758718-0025410-1001819_5">2020-01-01 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-02-0228758-0758718-0025410-1001819_1">2020-01-02 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-03-0228758-0758718-0025410-1001819_1">2020-01-03 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-04-nan-nan-nan-nan_1">2020-01-04       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-05-nan-nan-nan-nan_1">2020-01-05       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-06-nan-nan-nan-nan_1">2020-01-06       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-07-nan-nan-nan-nan_1">2020-01-07       NaN       NaN       NaN       NaN</h1>
<h1 id="2020-01-08-0704541-0261414-0863335-0267101_5">2020-01-08 -0.704541 -0.261414 -0.863335  0.267101</h1>
<pre><code>
注意，新的日期索引不需要与旧的索引重叠，和原来`df`的值一样，只是日期索引变了。
</code></pre>
<p>df_new = df.resample('W-THU').ffill()
print(df_new)</p>
<h1 id="colorado-texas-new-york-ohio_6">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020-01-02-0228758-0758718-0025410-1001819_2">2020-01-02 -0.228758 -0.758718 -0.025410 -1.001819</h1>
<h1 id="2020-01-09-0704541-0261414-0863335-0267101">2020-01-09 -0.704541 -0.261414 -0.863335  0.267101</h1>
<pre><code>


### 使用区间进行重新采样

对以区间为索引的数据进行采样与时间戳的情况类似：
</code></pre>
<p>df = pd.DataFrame(
    np.random.randn(24, 4),
    index=pd.period_range('2020-1', periods=24, freq='M'),
    columns=['Colorado', 'Texas', 'New York', 'Ohio']
)
print(df)</p>
<h1 id="2020-01-0721395-1492674-0707410-1641890">2020-01  0.721395 -1.492674  0.707410  1.641890</h1>
<h1 id="2020-02-0894880-0032823-0676158-0029203">2020-02 -0.894880  0.032823 -0.676158  0.029203</h1>
<h1 id="2020-03-2147365-0176796-0562695-0747656">2020-03  2.147365 -0.176796  0.562695 -0.747656</h1>
<h1 id="2020-04-1496037-0797119-0495601-0774147">2020-04  1.496037 -0.797119 -0.495601  0.774147</h1>
<h1 id="2020-05-0309839-0502563-0237244-0910624">2020-05 -0.309839  0.502563  0.237244  0.910624</h1>
<h1 id="2020-06-1231869-0105227-1315759-0217701">2020-06  1.231869 -0.105227  1.315759  0.217701</h1>
<h1 id="2020-07-1447419-0263876-0342045-0768907">2020-07  1.447419  0.263876 -0.342045 -0.768907</h1>
<h1 id="2020-08-2567162-1008827-0391085-1259560">2020-08 -2.567162 -1.008827  0.391085  1.259560</h1>
<h1 id="2020-09-0772501-1183532-0450374-0450714">2020-09 -0.772501  1.183532  0.450374  0.450714</h1>
<h1 id="2020-10-0228974-0461224-1393178-0175243">2020-10  0.228974  0.461224  1.393178  0.175243</h1>
<h1 id="2020-11-0725193-1544131-1372029-0659224">2020-11 -0.725193 -1.544131  1.372029 -0.659224</h1>
<h1 id="2020-12-0718195-0862024-0166460-0940191">2020-12  0.718195  0.862024 -0.166460 -0.940191</h1>
<h1 id="2021-01-0617054-0887312-0338451-1392838">2021-01 -0.617054 -0.887312  0.338451 -1.392838</h1>
<h1 id="2021-02-0081140-0634730-0868051-1277167">2021-02 -0.081140  0.634730 -0.868051 -1.277167</h1>
<h1 id="2021-03-0999642-1959715-0930662-0748687">2021-03 -0.999642 -1.959715 -0.930662  0.748687</h1>
<h1 id="2021-04-1851453-1561669-0688822-0371255">2021-04  1.851453  1.561669 -0.688822 -0.371255</h1>
<h1 id="2021-05-0540777-0890403-1204188-0243480">2021-05 -0.540777 -0.890403 -1.204188  0.243480</h1>
<h1 id="2021-06-1318905-1247457-0518969-0799793">2021-06  1.318905  1.247457  0.518969  0.799793</h1>
<h1 id="2021-07-0223238-0747177-0410889-0904593">2021-07  0.223238  0.747177 -0.410889  0.904593</h1>
<h1 id="2021-08-0652551-0254351-0464604-0676923">2021-08 -0.652551 -0.254351 -0.464604 -0.676923</h1>
<h1 id="2021-09-0562312-0182099-0018617-0573331">2021-09  0.562312  0.182099  0.018617  0.573331</h1>
<h1 id="2021-10-0429490-0045959-0356292-0295776">2021-10  0.429490 -0.045959 -0.356292 -0.295776</h1>
<h1 id="2021-11-2552155-0801299-1378421-1232792">2021-11  2.552155  0.801299  1.378421  1.232792</h1>
<h1 id="2021-12-1102288-0850280-0767015-0519840">2021-12  1.102288  0.850280 -0.767015 -0.519840</h1>
<p>df_annual = df.resample('A-DEC').mean()
print(df_annual)</p>
<h1 id="colorado-texas-new-york-ohio_7">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020-0226807-0151561-0395793-0195259">2020  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021-0429056-0165581-0286339-0002594">2021  0.429056  0.165581 -0.286339 -0.002594</h1>
<pre><code>
向上采样更为细致，因为必须在重新采样前决定新频率中在时间段的哪一端放置数值，就像asfreq方法一样。
`convention`参数默认值是`start`，但也可以是`end`：
</code></pre>
<p>result = df_annual.resample('Q-DEC').ffill()
print(result)</p>
<h1 id="colorado-texas-new-york-ohio_8">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020q1-0226807-0151561-0395793-0195259">2020Q1  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2020q2-0226807-0151561-0395793-0195259">2020Q2  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2020q3-0226807-0151561-0395793-0195259">2020Q3  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2020q4-0226807-0151561-0395793-0195259">2020Q4  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q1-0429056-0165581-0286339-0002594">2021Q1  0.429056  0.165581 -0.286339 -0.002594</h1>
<h1 id="2021q2-0429056-0165581-0286339-0002594">2021Q2  0.429056  0.165581 -0.286339 -0.002594</h1>
<h1 id="2021q3-0429056-0165581-0286339-0002594">2021Q3  0.429056  0.165581 -0.286339 -0.002594</h1>
<h1 id="2021q4-0429056-0165581-0286339-0002594">2021Q4  0.429056  0.165581 -0.286339 -0.002594</h1>
<p>result = df_annual.resample('Q-DEC', convention='end').ffill()
print(result)</p>
<h1 id="colorado-texas-new-york-ohio_9">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020q4-0226807-0151561-0395793-0195259_1">2020Q4  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q1-0226807-0151561-0395793-0195259">2021Q1  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q2-0226807-0151561-0395793-0195259">2021Q2  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q3-0226807-0151561-0395793-0195259">2021Q3  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q4-0429056-0165581-0286339-0002594_1">2021Q4  0.429056  0.165581 -0.286339 -0.002594</h1>
<pre><code>
由于区间涉及时间范围，向上采样和向下采样就更为严格：

* 在向下采样中，目标频率必须是原频率的子区间。
* 在向上采样中，目标频率必须是原频率的父区间。

如果不满足这些规则，将会引起异常。这主要会影响每季度、每年和每周的频率。

例如，根据Q-MAR定义的时间范围将只和A-MAR、A-JUN、A-SEP和A-DEC保持一致：
</code></pre>
<p>result = df_annual.resample('Q-MAR').ffill()
print(result)</p>
<h1 id="colorado-texas-new-york-ohio_10">Colorado     Texas  New York      Ohio</h1>
<h1 id="2020q4-0226807-0151561-0395793-0195259_2">2020Q4  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q1-0226807-0151561-0395793-0195259_1">2021Q1  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q2-0226807-0151561-0395793-0195259_1">2021Q2  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q3-0226807-0151561-0395793-0195259_1">2021Q3  0.226807 -0.151561  0.395793  0.195259</h1>
<h1 id="2021q4-0429056-0165581-0286339-0002594_2">2021Q4  0.429056  0.165581 -0.286339 -0.002594</h1>
<h1 id="2022q1-0429056-0165581-0286339-0002594">2022Q1  0.429056  0.165581 -0.286339 -0.002594</h1>
<h1 id="2022q2-0429056-0165581-0286339-0002594">2022Q2  0.429056  0.165581 -0.286339 -0.002594</h1>
<h1 id="2022q3-0429056-0165581-0286339-0002594">2022Q3  0.429056  0.165581 -0.286339 -0.002594</h1>
<pre><code>



## 移动窗口函数

统计那些通过移动窗口或指数衰减而运行的函数，是用于时间序列操作的数组变换的一个重要类别。
这对平滑噪声或粗糙的数据非常有用。称这些函数为移动窗口函数，尽管它也包含了一些没有固定长度窗口的函数，比如指数加权移动平均。
与其他的统计函数类似，这些函数会自动排除缺失数据。
</code></pre>
<p>import matplotlib.pyplot as plt
import pandas as pd
from scipy.stats import percentileofscore
import numpy as np
from pandas.tseries.offsets import Hour, Minute, Day, MonthEnd
import pytz</p>
<pre><code>
在深入了解之前，我们可以先载入一些时间序列数据并按照工作日频率进行重新采样：
</code></pre>
<p>close_px_all = pd.read_csv(
    '../examples/stock_px_2.csv',
    parse_dates = True,
    index_col=0
)
print(close_px_all.head(5))</p>
<h1 id="aapl-msft-xom-spx">AAPL   MSFT    XOM     SPX</h1>
<h1 id="2003-01-02-740-2111-2922-90903">2003-01-02  7.40  21.11  29.22  909.03</h1>
<h1 id="2003-01-03-745-2114-2924-90859">2003-01-03  7.45  21.14  29.24  908.59</h1>
<h1 id="2003-01-06-745-2152-2996-92901">2003-01-06  7.45  21.52  29.96  929.01</h1>
<h1 id="2003-01-07-743-2193-2895-92293">2003-01-07  7.43  21.93  28.95  922.93</h1>
<h1 id="2003-01-08-728-2131-2883-90993">2003-01-08  7.28  21.31  28.83  909.93</h1>
<p>close_px = close_px_all[
    ['AAPL', 'MSFT', 'XOM']
]
close_px = close_px.resample('B').ffill()
print(close_px)</p>
<h1 id="aapl-msft-xom">AAPL   MSFT    XOM</h1>
<h1 id="2003-01-02-740-2111-2922">2003-01-02    7.40  21.11  29.22</h1>
<h1 id="2003-01-03-745-2114-2924">2003-01-03    7.45  21.14  29.24</h1>
<h1 id="_15">...            ...    ...    ...</h1>
<h1 id="2011-10-13-40843-2718-7637">2011-10-13  408.43  27.18  76.37</h1>
<h1 id="2011-10-14-42200-2727-7811">2011-10-14  422.00  27.27  78.11</h1>
<h1 id="2292-rows-x-3-columns">[2292 rows x 3 columns]</h1>
<pre><code>
`rolling`算子，它的行为与`resample`和`groupby`类似。
`rolling`可以在Series或DataFrame上通过一个window（以一个区间的数字来表示）进行调用。
</code></pre>
<p>close_px.AAPL.plot()</p>
<pre><code>
表达式`rolling(250)`与`groupby`的行为类似，但是它创建的对象是根据250日滑动窗口分组的而不是直接分组。
因此这里我们获得了苹果公司股票价格的250日移动窗口平均值。
</code></pre>
<p>close_px.AAPL.rolling(250).mean().plot()
plt.show()</p>
<pre><code>
默认情况下，滚动函数需要窗口中所有的值必须是非`NA`值。
由于存在缺失值这种行为会发生改变，尤其是在时间序列的起始位置你拥有的数据是少于窗口区间的
</code></pre>
<p>apple_std250 = close_px.AAPL.rolling(250, min_periods=10).std()  # 苹果公司250日每日返回标准差
print(apple_std250[5:12])</p>
<h1 id="2003-01-09-nan">2003-01-09         NaN</h1>
<h1 id="2003-01-10-nan">2003-01-10         NaN</h1>
<h1 id="2003-01-13-nan">2003-01-13         NaN</h1>
<h1 id="2003-01-14-nan">2003-01-14         NaN</h1>
<h1 id="2003-01-15-0077496">2003-01-15    0.077496</h1>
<h1 id="2003-01-16-0074760">2003-01-16    0.074760</h1>
<h1 id="2003-01-17-0112368">2003-01-17    0.112368</h1>
<h1 id="freq-b-name-aapl-dtype-float64">Freq: B, Name: AAPL, dtype: float64</h1>
<p>apple_std250.plot()
plt.show()</p>
<p>expanding_mean = apple_std250.expanding().mean()
print(expanding_mean[5:12])</p>
<h1 id="2003-01-09-nan_1">2003-01-09         NaN</h1>
<h1 id="2003-01-10-nan_1">2003-01-10         NaN</h1>
<h1 id="2003-01-13-nan_1">2003-01-13         NaN</h1>
<h1 id="2003-01-14-nan_1">2003-01-14         NaN</h1>
<h1 id="2003-01-15-0077496_1">2003-01-15    0.077496</h1>
<h1 id="2003-01-16-0076128">2003-01-16    0.076128</h1>
<h1 id="2003-01-17-0088208">2003-01-17    0.088208</h1>
<h1 id="freq-b-name-aapl-dtype-float64_1">Freq: B, Name: AAPL, dtype: float64</h1>
<p>expanding_mean.plot()
plt.show()</p>
<pre><code>
在DataFrame上调用一个移动窗口函数会将变换应用到每一列上:
</code></pre>
<p>close_px.rolling(60).mean().plot(logy=True)  # 股票价格60日MA（Y轴取对数）
plt.show()</p>
<pre><code>
`rolling`函数也接收表示固定大小的时间偏置字符串，而不只是一个区间的集合数字。
对不规则时间序列使用注释非常有用。这些字符串可以传递给`resample`。

例如，我们可以像这样计算20天的滚动平均值：
</code></pre>
<p>result = close_px.rolling('20D').mean()
print(result)</p>
<h1 id="aapl-msft-xom_1">AAPL       MSFT        XOM</h1>
<h1 id="2003-01-02-7400000-21110000-29220000">2003-01-02    7.400000  21.110000  29.220000</h1>
<h1 id="_16">...                ...        ...        ...</h1>
<h1 id="2011-10-14-391038000-26048667-74185333">2011-10-14  391.038000  26.048667  74.185333</h1>
<h1 id="2292-rows-x-3-columns_1">[2292 rows x 3 columns]</h1>
<p>result.plot()
plt.show()</p>
<pre><code>

### 指数加权函数

指定一个常数衰减因子以向更多近期观测值提供更多权重，可以替代使用具有相等加权观察值的静态窗口尺寸的方法。
有多种方式可以指定衰减因子。其中一种流行的方式是使用一个span（跨度），这使得结果与窗口大小等于跨度的简单移动窗口函数。
由于指数加权统计值给更近期的观测值以更多的权重，与等权重的版本相比，它对变化“适应”得更快。

pandas拥有`ewm`算子，同`rolling`、`expanding`算子一起使用。

以下是将苹果公司股票价格的60日均线与`span=60`的EW移动平均线进行比较的例子：
</code></pre>
<p>aapl_ex = close_px.AAPL['2006':'2007']
ma60 = aapl_ex.rolling(30, min_periods=20).mean()
ewma60 = aapl_ex.ewm(span=30).mean()
ma60.plot(style='k--', label='Simple MA')
ewma60.plot(style='k-', label='EWMA')
plt.legend()
plt.show()</p>
<pre><code>




### 二元移动窗口函数

一些统计算子，例如相关度和协方差，需要操作两个时间序列。
例如，金融分析师经常对股票与基准指数（如标普500）的关联性感兴趣。
我们首先计算所有我们感兴趣的时间序列的百分比变化：
</code></pre>
<p>spx_px = close_px_all['SPX']
spx_rets = spx_px.pct_change()
returns = close_px.pct_change()</p>
<h1 id="rollingcorrspx_rets">在调用rolling后，corr聚合函数可以根据spx_rets计算滚动相关性：</h1>
<p>corr = returns.AAPL.rolling(125, min_periods=100).corr(spx_rets)  # 苹果公司与标普500的六个月的收益相关性
corr.plot()
plt.show()
corr = returns.rolling(125, min_periods=100).corr(spx_rets)  # 多只股票与标普500的六个月收益相关性
corr.plot()
plt.show()</p>
<pre><code>




### 用户自定义的移动窗口函数

在`rolling`及其相关方法上使用apply方法提供了一种在移动窗口中应用你自己设计的数组函数的方法。
唯一的要求是该函数从每个数组中产生一个单值（缩聚）。

例如，尽管我们可以使用`rolling(...).quantile(q)`计算样本的分位数，但我们可能会对样本中特定值的百分位数感兴趣。
`scipy.stats.percentileofscore`函数就是实现这个功能的：
</code></pre>
<p>score_at_2percent = lambda x: percentileofscore(x, 0.02)
result = returns.AAPL.rolling(250).apply(score_at_2percent)  # 一年窗口下苹果公司股价2%收益的百分位等级
result.plot()
plt.show()
result = returns.rolling(250).apply(score_at_2percent)  # 一年窗口下所有公司股价2%收益的百分位等级
result.plot()
plt.show()
```</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" data-md-state="hidden">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg>
            Back to top
          </a>
        
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.tracking", "navigation.top", "navigation.expand"], "search": "../../../assets/javascripts/workers/search.fcfe8b6d.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.b1047164.min.js"></script>
      
    
  </body>
</html>
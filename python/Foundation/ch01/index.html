<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://huyuhui001.github.io/mySite/python/Foundation/ch01/ rel=canonical><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.3.0, mkdocs-material-7.3.6"><title>Python语言基础 - MEMO</title><link rel=stylesheet href=../../../assets/stylesheets/main.a57b2b03.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.3f5d1f46.min.css><meta name=theme-color content=#009485><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style><link rel=stylesheet href=../../../extra.css></head> <body dir=ltr data-md-color-scheme data-md-color-primary=teal data-md-color-accent=green> <script>function __prefix(e){return new URL("../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#python class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MEMO class="md-header__button md-logo" aria-label=MEMO data-md-component=logo> <img src=../../../assets/logo.jpg alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MEMO </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Python语言基础 </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/huyuhui001/mySite title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> huyuhui001/mySite </div> </a> </div> </nav> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../k8s/installation/single-local/ class=md-tabs__link> Kubernetes </a> </li> <li class=md-tabs__item> <a href=../../../linux/Administration/linux_admin/ class=md-tabs__link> Linux </a> </li> <li class=md-tabs__item> <a href=../python_foundation_index/ class=md-tabs__link> Python </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MEMO class="md-nav__button md-logo" aria-label=MEMO data-md-component=logo> <img src=../../../assets/logo.jpg alt=logo> </a> MEMO </label> <div class=md-nav__source> <a href=https://github.com/huyuhui001/mySite title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> huyuhui001/mySite </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1 type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1> Kubernetes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Kubernetes data-md-level=1> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> Kubernetes </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_1 type=checkbox id=__nav_1_1> <label class=md-nav__link for=__nav_1_1> Installation <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Installation data-md-level=2> <label class=md-nav__title for=__nav_1_1> <span class="md-nav__icon md-icon"></span> Installation </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/installation/single-local/ class=md-nav__link> Single Node Installation </a> </li> <li class=md-nav__item> <a href=../../../k8s/installation/multiple-local/ class=md-nav__link> Multiple Nodes Installation </a> </li> <li class=md-nav__item> <a href=../../../k8s/installation/aliyun-opensuse/ class=md-nav__link> Installation on Aliyun openSUSE </a> </li> <li class=md-nav__item> <a href=../../../k8s/installation/aliyun-ubuntu/ class=md-nav__link> Installation on Aliyun Ubuntu </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_2 type=checkbox id=__nav_1_2> <label class=md-nav__link for=__nav_1_2> Docker <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Docker data-md-level=2> <label class=md-nav__title for=__nav_1_2> <span class="md-nav__icon md-icon"></span> Docker </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/docker/ class=md-nav__link> Fundamentals </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_3 type=checkbox id=__nav_1_3> <label class=md-nav__link for=__nav_1_3> Foundamentals <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Foundamentals data-md-level=2> <label class=md-nav__title for=__nav_1_3> <span class="md-nav__icon md-icon"></span> Foundamentals </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/memo/ class=md-nav__link> Memo </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/overview/ class=md-nav__link> Overview </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/basics/ class=md-nav__link> kubectl basics </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_4 type=checkbox id=__nav_1_4> <label class=md-nav__link for=__nav_1_4> Core Kubernetes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Core Kubernetes" data-md-level=2> <label class=md-nav__title for=__nav_1_4> <span class="md-nav__icon md-icon"></span> Core Kubernetes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/pod/ class=md-nav__link> Pod </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/deployment/ class=md-nav__link> Deployment </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/service/ class=md-nav__link> Service </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_5 type=checkbox id=__nav_1_5> <label class=md-nav__link for=__nav_1_5> Application Modelling <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Application Modelling" data-md-level=2> <label class=md-nav__title for=__nav_1_5> <span class="md-nav__icon md-icon"></span> Application Modelling </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/namespace/ class=md-nav__link> Namespace </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/statefulset/ class=md-nav__link> StatefulSet </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/daemonset/ class=md-nav__link> DaemonSet </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/job/ class=md-nav__link> Job and Cronjob </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/configuration/ class=md-nav__link> Configuration </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/secrets/ class=md-nav__link> Secrets </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/persistence/ class=md-nav__link> Persistence </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/rbac/ class=md-nav__link> Role Based Access Control (RBAC) </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/ingress/ class=md-nav__link> Ingress </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_6 type=checkbox id=__nav_1_6> <label class=md-nav__link for=__nav_1_6> Advanced Kubernetes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Advanced Kubernetes" data-md-level=2> <label class=md-nav__title for=__nav_1_6> <span class="md-nav__icon md-icon"></span> Advanced Kubernetes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/scheduling/ class=md-nav__link> Scheduling </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/hpa/ class=md-nav__link> Horizontal Pod Autoscaling </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/policy/ class=md-nav__link> Policy </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/networkpolicy/ class=md-nav__link> Network Policy </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/clustermgt/ class=md-nav__link> Cluster Management </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_7 type=checkbox id=__nav_1_7> <label class=md-nav__link for=__nav_1_7> Operating Kubernetes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Operating Kubernetes" data-md-level=2> <label class=md-nav__title for=__nav_1_7> <span class="md-nav__icon md-icon"></span> Operating Kubernetes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/troubleshooting/ class=md-nav__link> Troubleshooting </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/healthcheck/ class=md-nav__link> Health Check </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/helming/ class=md-nav__link> Helming </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_8 type=checkbox id=__nav_1_8> <label class=md-nav__link for=__nav_1_8> Case Study <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Case Study" data-md-level=2> <label class=md-nav__title for=__nav_1_8> <span class="md-nav__icon md-icon"></span> Case Study </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../k8s/foundamentals/casestudy-operation-resources/ class=md-nav__link> Operations on Resources </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/casestudy-health-check/ class=md-nav__link> Health Check </a> </li> <li class=md-nav__item> <a href=../../../k8s/foundamentals/casestudy-calico/ class=md-nav__link> Calico Installation </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2> Linux <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Linux data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Linux </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../linux/Administration/linux_admin/ class=md-nav__link> SUSE Linux Administration </a> </li> <li class=md-nav__item> <a href=../../../linux/SES/linux_ses/ class=md-nav__link> SUSE Enterprise Storage Foundation </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3> Python <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Python data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Python </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../python_foundation_index/ class=md-nav__link> Python Foundamentals </a> </li> <li class=md-nav__item> <a href=../../DataAnalysis/python_data_analysis_index/ class=md-nav__link> Data Analysis </a> </li> <li class=md-nav__item> <a href=../../Demo/python_demo_index/ class=md-nav__link> Demos </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#1-python6 class=md-nav__link> 1. Python数据类型（6个） </a> <nav class=md-nav aria-label="1. Python数据类型（6个）"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#11-number class=md-nav__link> 1.1 数值型（number） </a> </li> <li class=md-nav__item> <a href=#12-string class=md-nav__link> 1.2 字符型（string） </a> <nav class=md-nav aria-label="1.2 字符型（string）"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 字符串常用方法 </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 转义字符 </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> 可迭代性 </a> </li> <li class=md-nav__item> <a href=#f-string class=md-nav__link> f-string </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#13-list class=md-nav__link> 1.3 列表（list） </a> </li> <li class=md-nav__item> <a href=#14-dictionary class=md-nav__link> 1.4 字典（dictionary） </a> </li> <li class=md-nav__item> <a href=#15-set class=md-nav__link> 1.5 集合（set） </a> </li> <li class=md-nav__item> <a href=#16-tuple class=md-nav__link> 1.6 元组（tuple） </a> </li> <li class=md-nav__item> <a href=#17-memoryview class=md-nav__link> 1.7 内存视图Memoryview </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#2 class=md-nav__link> 2. 动态引用、强类型 </a> </li> <li class=md-nav__item> <a href=#3 class=md-nav__link> 3. 二元运算符和比较运算 </a> </li> <li class=md-nav__item> <a href=#4 class=md-nav__link> 4. 标量类型 </a> </li> <li class=md-nav__item> <a href=#5 class=md-nav__link> 5. 三元表达式 </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <a href=https://github.com/huyuhui001/mySite/edit/main/docs/python/Foundation/ch01.md title="Edit this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg> </a> <h1 id=python>Python语言基础<a class=headerlink href=#python title="Permanent link"> ¶</a></h1> <h2 id=1-python6>1. Python数据类型（6个）<a class=headerlink href=#1-python6 title="Permanent link"> ¶</a></h2> <ul> <li>数值型（number）：表示数据组成为数字</li> <li>整型（int）<ul> <li>十进制</li> <li>八进制</li> <li>十六进制</li> </ul> </li> <li>浮点型（float）</li> <li>布尔型（bool）</li> <li>复数性（complex）</li> <li>字符型（string）：表示数据组成是字符</li> <li>列表（list）：用来表示一组有序元素，后期数据可以修改 ['A','B','C']</li> <li>元组（tuple）：用来表示一组有序元素，后期数据不可修改 ('A','B','C','1')</li> <li>集合（set）：一组数据无序不重复元素 set([1,2,3,4])</li> <li>字典（dictionary）：用键值对的形式保存一组元素 {'A':7,'B':1,'C':9}</li> </ul> <p>可迭代对象（Iterable）</p> <blockquote> <p>An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as list, str, and tuple) and some non-sequence types like dict, file objects, and objects of any classes you define with an iter() method or with a getitem() method that implements Sequence semantics.</p> </blockquote> <p>序列（Sequence）</p> <blockquote> <p>An iterable which supports efficient element access using integer indices via the getitem() special method and defines a len() method that returns the length of the sequence. Some built-in sequence types are list, str, tuple, and bytes. Note that dict also supports getitem() and len(), but is considered a mapping rather than a sequence because the lookups use arbitrary immutable keys rather than integers.</p> </blockquote> <p>迭代器（Iterator）</p> <blockquote> <p>An object representing a stream of data. Repeated calls to the iterator’s next() method (or passing it to the built-in function next()) return successive items in the stream. When no more data are available a StopIteration exception is raised instead. At this point, the iterator object is exhausted and any further calls to its next() method just raise StopIteration again. Iterators are required to have an iter() method that returns the iterator object itself so every iterator is also iterable and may be used in most places where other iterables are accepted. One notable exception is code which attempts multiple iteration passes. A container object (such as a list) produces a fresh new iterator each time you pass it to the iter() function or use it in a for loop. Attempting this with an iterator will just return the same exhausted iterator object used in the previous iteration pass, making it appear like an empty container.</p> </blockquote> <p>可变数据（immutable）：</p> <ul> <li>列表（list）</li> <li>字典（dictionary）</li> <li>集合（set）。</li> </ul> <p>不可变数据（immutable）：</p> <ul> <li>数字（number）</li> <li>字符（string）</li> <li>元组（tuple）</li> </ul> <p>可迭代（iterable）：</p> <ul> <li>字符（string）</li> <li>元组（tuple）</li> <li>列表（list）</li> <li>字典（dictionary）</li> <li>集合（set）</li> </ul> <p>序列：</p> <ul> <li>有序序列：字符（string），元组（tuple），列表（list）</li> <li>无序序列：字典（dictionary），集合（set）</li> </ul> <p>Python序列类型最常见的分类就是可变和不可变序列。但另外一种分类方式也很有用，那就是把它们分为**扁平序列**和**容器序列**。前者的体积更小、速度更快而且用起来更简单，但是它只能保存一些原子性的数据，比如数字、字符和字节。容器序列则比较灵活，但是当容器序列遇到可变对象时，就需要格外小心，因为这种组合时常会出现一些“意外”，特别是带嵌套的数据结构出现时，更需要验证代码的正确性。</p> <p><strong>Python中的变量、常量和字面量</strong></p> <ul> <li>变量<ul> <li>变量是用于在内存中存储数据的命名位置。可以将变量视为保存数据的容器，这些数据可以在后面程序中进行更改。例如：<code>number = 10</code>。从例子中可以看到，Python使用赋值运算符<code>=</code>为变量赋值。</li> </ul> </li> <li>常量<ul> <li>常量也是一种变量，只是其值一旦赋予后无法更改。可以将常量视为保存了以后无法更改的信息的容器。</li> <li>在Python中，常量通常是在模块中声明和分配的。在这里，模块是一个包含变量，函数等的新文件，该文件被导入到主文件中。在模块内部，用所有大写字母写的常量和下划线将单词分开。实际上，我们不在Python中使用常量。用大写字母命名它们是一种将其与普通变量分开的一种约定，但是，实际上并不能阻止重新分配。</li> </ul> </li> <li>字面量（literal）<ul> <li>字面量是以变量或常量给出的原始数据（其实就是指变量的常数值，字面上所看到的值）。在Python中字面量类型如下：<ul> <li>数字字面量。数字字面量是不可变的（不可更改）。数字字面量可以属于3种不同的数值类型：Integer，Float 和 Complex。例如：<code>float_1 = 10.5</code>是属于Float字面量。</li> <li>字符串字面量是由引号括起来的一系列字符。我们可以对字符串使用单引号，双引号 或 三引号。并且，字符字面量是用单引号或双引号引起来的单个字符。例如：<code>strings = "This is Python"</code>。</li> <li>布尔字面量。布尔字面量可以具有两个值中的任何一个：<code>True</code> 或 <code>False</code>。例如：<code>a = True + 4</code>。</li> <li>特殊字面量。Python包含一个特殊字面量，即 <code>None</code>。</li> <li>字面量集。有四种不同的字面量集合：列表字面量，元组字面量，字典字面量 和 集合字面量。</li> </ul> </li> </ul> </li> </ul> <h3 id=11-number>1.1 数值型（number）<a class=headerlink href=#11-number title="Permanent link"> ¶</a></h3> <p>例子：</p> <div class=highlight><pre><span></span><code>a, b, c, d = 20, 5.5, True, 4+3j

print(a, b, c, d)
# 20 5.5 True (4+3j)

print(type(a), type(b), type(c), type(d))
# &lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class &#39;bool&#39;&gt; &lt;class &#39;complex&#39;&gt;
</code></pre></div> <p>Python也可以这样赋值：</p> <div class=highlight><pre><span></span><code>a = b = c = d = 1
print(a, b, c, d)
# 1 1 1 1
</code></pre></div> <p>进制转换：</p> <div class=highlight><pre><span></span><code>a = -15
print(f&#39;{a}对应的十进制是{a}, 二进制是{a:b}, 八进制是{a:o}, 十六进制是{a:x}&#39;)
</code></pre></div> <h3 id=12-string>1.2 字符型（string）<a class=headerlink href=#12-string title="Permanent link"> ¶</a></h3> <p>单引号：内容中包含大量双引号</p> <p>双引号：内容中包含大量单引号</p> <p>三引号：内容中同时包含单双引号，三个单引号比较好。</p> <div class=highlight><pre><span></span><code>a = &#39;string is &quot;special&quot;&#39;

b = &quot;string&#39;s value&quot;

c = &#39;&#39;&#39;string&#39;s value is 
&quot;special&quot;&#39;&#39;&#39;

d = &quot;&quot;&quot;string&#39;s 
context
&quot;&quot;&quot;
</code></pre></div> <h4 id=_1>字符串常用方法<a class=headerlink href=#_1 title="Permanent link"> ¶</a></h4> <ul> <li>字符串切片</li> </ul> <div class=highlight><pre><span></span><code>s = &#39;Python is very good&#39;

print(s[2:4])
# th
print(s[5])
# n
print(s[-1])
# d
print(s[-3:-1])
# oo

# 非迭代型，不可修改
s[3] = &#39;b&#39;
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# TypeError: &#39;str&#39; object does not support item assignment
</code></pre></div> <ul> <li>字符串合并</li> </ul> <div class=highlight><pre><span></span><code>print(s + &#39;!!!&#39;)
# Python is very good!!!
</code></pre></div> <ul> <li>replace( a,b 将字符串中的 a 替换成 b</li> </ul> <div class=highlight><pre><span></span><code>print(s.replace(&#39;is&#39;, &#39;we&#39;))
# Python we very good
</code></pre></div> <ul> <li>find(str) : 返回 str 出现的索引位置，如果找不到该值，则 find() 方法将返回 -1。</li> </ul> <div class=highlight><pre><span></span><code>print(s.find(&#39;a&#39;))
# -1

print(s.find(&#39;s&#39;))
# 8
</code></pre></div> <ul> <li>str.index(a): 查找指定值的首次出现。如果找不到该值，index() 方法将引发异常。</li> </ul> <div class=highlight><pre><span></span><code>print(s.index(&#39;s&#39;))
# 8

print(s.index(&#39;a&#39;))
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# ValueError: substring not found
</code></pre></div> <ul> <li>str.count(a): 统计字符串中 a 出现的次数</li> </ul> <div class=highlight><pre><span></span><code>print(s.count(&#39;a&#39;))
# 0
print(s.count(&#39;o&#39;))
# 3
</code></pre></div> <ul> <li>split: 对字符串进行分割。如果参数 num 有指定值，则分隔 num+1 个子字符串。</li> </ul> <div class=highlight><pre><span></span><code># 按空格分割
print(s.split(&#39; &#39;))
# [&#39;Python&#39;, &#39;is&#39;, &#39;very&#39;, &#39;good&#39;]

# 按空格分割成2个子字符串
print(s.split(&#39; &#39;, 1))
# [&#39;Python&#39;, &#39;is very good&#39;]
</code></pre></div> <ul> <li>strip: 移除字符串首尾指定的字符 默认为空格。该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。</li> </ul> <div class=highlight><pre><span></span><code>print(s)
# Python is very good

# 移除末尾字符d
print(s.strip(&#39;d&#39;))
# Python is very goo
</code></pre></div> <ul> <li>endswith (str): 判断字符串是否以 str 结尾</li> </ul> <div class=highlight><pre><span></span><code>print(s.endswith(&#39;d&#39;))
# True

print(s.endswith(&#39;a&#39;))
# False
</code></pre></div> <ul> <li>startswith (str): 判断字符串是否以 str 开头</li> </ul> <div class=highlight><pre><span></span><code>print(s.startswith(&#39;p&#39;))
# False

print(s.startswith(&#39;P&#39;))
# True
</code></pre></div> <ul> <li>isdigit ：判断字符串是否全为数字</li> </ul> <div class=highlight><pre><span></span><code>d = &#39;+86-123&#39;

print(d.isdigit())
# False

d = &#39;86123&#39;
print(d.isdigit())
# True
</code></pre></div> <ul> <li>isalpha ：判断字符串是否全为字母</li> </ul> <div class=highlight><pre><span></span><code>b = &#39;Ab?&#39;

print(b.isalpha())
# False

c = &#39;Ab&#39;
print()c.isalpha()
# True
</code></pre></div> <h4 id=_2>转义字符<a class=headerlink href=#_2 title="Permanent link"> ¶</a></h4> <p>使用反斜杠\表示转义字符。反斜杠前面加r代表原始字符。</p> <div class=highlight><pre><span></span><code>a = &#39;str\ning&#39;
print(a)
# str
# ing

a = r&#39;str\ning&#39;
print(a)
# str\ning
</code></pre></div> <table> <thead> <tr> <th>转义符</th> <th>描述</th> </tr> </thead> <tbody> <tr> <td>\在行尾</td> <td>续行符</td> </tr> <tr> <td>\\</td> <td>反斜杠符号\</td> </tr> <tr> <td>\'</td> <td>单引号</td> </tr> <tr> <td>\b</td> <td>退格(Backspace)</td> </tr> <tr> <td>\000</td> <td>空</td> </tr> <tr> <td>\n</td> <td>换行</td> </tr> <tr> <td>\v</td> <td>纵向制表符</td> </tr> <tr> <td>\t</td> <td>横向制表符</td> </tr> <tr> <td>\r</td> <td>回车，将 \r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \r 后面的内容完全替换完成。</td> </tr> <tr> <td>\yyy</td> <td>八进制数，y 代表 0~7 的字符</td> </tr> <tr> <td>\xyy</td> <td>十六进制数，以 \x 开头，y 代表的字符</td> </tr> </tbody> </table> <h4 id=_3>可迭代性<a class=headerlink href=#_3 title="Permanent link"> ¶</a></h4> <p>字符串是可迭代的。索引值从0开始，-1代表从末尾开始。索引区间是左闭右开。</p> <div class=highlight><pre><span></span><code>a = &#39;string is &quot;special&quot;&#39;
print(a[2:4])
&#39;ri&#39;
print(a[-4:-1])
# ial
</code></pre></div> <h4 id=f-string>f-string<a class=headerlink href=#f-string title="Permanent link"> ¶</a></h4> <p>f-string是Python3.6推出的新功能。看下面的例子，对比传统表示方法和f-string的方法。</p> <div class=highlight><pre><span></span><code>age = 32
name = &#39;Tom&#39;
fstring = f&#39;My name is {name} and I am {age} years old.&#39;
print(fstring)
# My name is Tom and I am 32 years old.
</code></pre></div> <p>在f-string中使用表达式。</p> <div class=highlight><pre><span></span><code>height = 2
base = 3
fstring = f&#39;The area of the triangle is {base*height/2}.&#39;
print(fstring)
# The area of the triangle is 3.0.
</code></pre></div> <p>通过f-string对字典进行操作。</p> <div class=highlight><pre><span></span><code>person1 = {
    &#39;name&#39;: &#39;Tom&#39;,
    &#39;age&#39;: 20,
    &#39;gender&#39;: &#39;male&#39;
}

person2 = {
    &#39;name&#39;: &#39;Jerry&#39;,
    &#39;age&#39;: 20,
    &#39;gender&#39;: &#39;female&#39;
}

# 读取字典
fstring = f&#39;{person1.get(&quot;name&quot;)} is {person1.get(&quot;age&quot;)} and is {person1.get(&quot;ender&quot;)}&#39;
print(fstring)
# Tom is 20 and is None

# 遍历字典
people = [person1, person2]

for person in people:
    fstring = f&#39;{person.get(&quot;name&quot;)} is {person.get(&quot;age&quot;)} and is {person.get(&quot;ender&quot;)}&#39;
    print(fstring)

# Tom is 20 and is None
# Jerry is 20 and is None
</code></pre></div> <p>在f-string中使用条件。</p> <div class=highlight><pre><span></span><code>person1 = {
    &#39;name&#39;: &#39;Tom&#39;,
    &#39;age&#39;: 20,
    &#39;gender&#39;: &#39;male&#39;
}

person2 = {
    &#39;name&#39;: &#39;Jerry&#39;,
    &#39;age&#39;: 20,
    &#39;gender&#39;: &#39;female&#39;
}

people = [person1, person2]

for person in people:
    fstring = f&#39;{&quot;She&quot; if person.get(&quot;gender&quot;) == &quot;female&quot; else &quot;He&quot;} is watching TV.&#39;
    print(fstring)

# He is watching TV.
# She is watching TV.
</code></pre></div> <p>使用f-string格式化输出。</p> <ul> <li>左对齐：&lt;</li> <li>右对齐：&gt; </li> <li>居中对齐：^</li> </ul> <div class=highlight><pre><span></span><code>print(f&#39;{&quot;apple&quot;: &gt;30}&#39;)
print(f&#39;{&quot;apple&quot;: ^30}&#39;)
print(f&#39;{&quot;apple&quot;: &lt;30}&#39;)
#                          apple
#             apple             
# apple
</code></pre></div> <p>使用f-string格式化数字。</p> <div class=highlight><pre><span></span><code>number = 0.9124325345

# 百分比
fstring = f&#39;Percentage format for number with two decimal places: {number:.2%}&#39;
print(fstring)
# Percentage format for number with two decimal places: 91.24%

# 保留小数点后3位
fstring = f&#39;Fixed point format for number with three decimal places: {number:.3f}&#39;
print(fstring)
# Fixed point format for number with three decimal places: 0.912

# 科学计数法表示
fstring = f&#39;Exponent format for number: {number:e}&#39;
print(fstring)
# Exponent format for number: 9.124325e-01

# 带货币符号
number = 123456.78921
fstring = f&#39;Currency format for number with two decimal places: ${number:.2f}&#39;
print(fstring)
# Currency format for number with two decimal places: $123456.79

# 带货币符号和千分位
number = 123456.78921
fstring = f&#39;Currency format for number with two decimal places and comma seperators: ${number:,.2f}&#39;
print(fstring)
# Currency format for number with two decimal places and comma seperators: $123,456.79

# 输出数值带正负符合
numbers = [1, -3, 5]

for number in numbers:
    fstring = f&#39;The number is {number:+}&#39;
    print(fstring)

# The number is +1
# The number is -3
# The number is +5


# Debug调试
number = 2
print(f&#39;{number = }&#39;)
# number = 2
</code></pre></div> <h3 id=13-list>1.3 列表（list）<a class=headerlink href=#13-list title="Permanent link"> ¶</a></h3> <p>列表是 Python 内置的一种数据结构，是一种有序的集合，用来存储一连串元素的容器。列表中元素类型可以不相同，它支持数字、字符串等。</p> <p>列表的每个值都有对应的索引值，索引值从0开始。</p> <p>列表切片：</p> <p>使用切片符号可以对大多数序列类型选取其子集。</p> <p>起始位置start的索引是包含的，而结束位置stop的索引并不包含（左闭右开）。</p> <p>步进值step可以在第二个冒号后面使用，意思是每隔多少个数取一个值 。</p> <div class=highlight><pre><span></span><code>color = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;white&#39;, &#39;black&#39;]

# 从0开始统计，读取第1，2位
print(color[1: 3])
# [&#39;green&#39;, &#39;blue&#39;]

# 从0开始统计，读取从第1位到倒数第3位
print(color[1: -2])
# [&#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;]

# 从0开始统计，读取从倒数第4位到倒数第3位
print(color[-4: -2])
# [&#39;blue&#39;, &#39;yellow&#39;]

# 如果写成下面这样，则无输出。
print(color[-2: -4])
# []

print(color[::2])
# [&#39;red&#39;, &#39;blue&#39;, &#39;white&#39;]
</code></pre></div> <p>对于类似下面<code>invoice</code>格式的纯文本解析，使用有名字的切片比用上面所列举的硬编码的数字区间要方便得多。</p> <div class=highlight><pre><span></span><code>invoice = &quot;&quot;&quot;
0     6                                 40           52   55
1909  Primoroni PiBrella                $17.50       3    $52.50
1489  6mm Tactile Switch x20            $4.19        2    $9.90
1510  Panavise JR.-PV-201               $28.00       1    $28.00
1601  PiTFT Mini Kit 320x240            $34.95       1    $34.95
&quot;&quot;&quot;

SKU = slice(0, 6)
DESCRIPTION = slice(6, 40)
UNIT_PRICE = slice(40, 52)
QUANTITY = slice(52, 55)
ITEM_TOTAL = slice(55, None)

line_items = invoice.split(&#39;\n&#39;)[2:]  # 按上面invoice的格式，第0和1行舍弃

for item in line_items:
    print(item[UNIT_PRICE], item[DESCRIPTION])

# $17.50       Primoroni PiBrella                
# $4.19        6mm Tactile Switch x20            
# $28.00       Panavise JR.-PV-201               
# $34.95       PiTFT Mini Kit 320x240
</code></pre></div> <p>Python内置的序列类型都是一维的，因此它们只支持单一的索引，成对出现的索引是没有用的。</p> <p>**省略（ellipsis）**的正确书写方法是三个英语句号（...），而不是Unicdoe码位U+2026表示的半个省略号（...）。 省略在Python解析器眼里是一个符号，而实际上它是<code>Ellipsis</code>对象的别名，而<code>Ellipsis</code>对象又是<code>ellipsis</code>类的单一实例。 它可以当作切片规范的一部分，也可以用在函数的参数清单中，比如<code>f(a, ..., z)</code>，或<code>a[i:...]</code>。</p> <p>在NumPy中，<code>...</code>用作多维数组切片的快捷方式。如果<code>`x是四维数组，那么</code>x[i, ...]<code>就是</code>x[i, :, :, :]`的缩写。如果想了解更多，请参见“Tentative NumPy Tutorial”。</p> <p>列表常用方法：</p> <table> <thead> <tr> <th>方法名称</th> <th>作用</th> </tr> </thead> <tbody> <tr> <td>a.index()</td> <td>返回a中首个匹配项的位置</td> </tr> <tr> <td>a.pop()</td> <td>删除指定位置的元素</td> </tr> <tr> <td>a.insert()</td> <td>向指定位置插入元素</td> </tr> <tr> <td>a.reverse()</td> <td>反向排序</td> </tr> <tr> <td>a.append()</td> <td>向末尾添加元素</td> </tr> <tr> <td>a.sort()</td> <td>对列表进行排序</td> </tr> <tr> <td>a.remove()</td> <td>删除首个匹配项的元素</td> </tr> <tr> <td>a.extend()</td> <td>将一个列表扩展至另一个列表</td> </tr> <tr> <td>a.count()</td> <td>统计某个元素出现的次数</td> </tr> </tbody> </table> <p>创建列表list</p> <div class=highlight><pre><span></span><code>a = [1, 2, 3, 4, 5]

print(a)
# [1, 2, 3, 4, 5]

b = list(&#39;12345&#39;)

print(b)
# [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]

c = list(12345)
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# TypeError: &#39;int&#39; object is not iterable
</code></pre></div> <p>列表切片（从0开始，左闭右开）：</p> <div class=highlight><pre><span></span><code>print(a[2:3])
# [3]

print(a[:3])
# [1, 2, 3]

print(a[::-1])  # 倒序
# [5, 4, 3, 2, 1]

print(a[::])
# [1, 2, 3, 4, 5]

print(a[::1])
[1, 2, 3, 4, 5]
</code></pre></div> <p>列表是可修改的：</p> <div class=highlight><pre><span></span><code>print(a[1])
# 2

a[1] = &#39;one&#39;

print(a)
@ [1, &#39;one&#39;, 3, 4, 5]
</code></pre></div> <p>列表追加和插入。insert与append相比，计算代价更高。因为子序列元素需要在内部移动为新元素提供空间。</p> <div class=highlight><pre><span></span><code>a.append(6)  # 注意，直接修改原列表，不是创建副本。

print(a)
# [1, &#39;one&#39;, 3, 4, 5, 6]

a.extend([7, 8, 9])

print(a)
# [1, &#39;one&#39;, 3, 4, 5, 6, 7, 8, 9]

a.insert(0, &#39;Italy&#39;)

print(a)
# [&#39;Italy&#39;, 1, 3, 5, 6, 7, 8]
</code></pre></div> <p>列表删除元素，默认删除最后一个。insert的反操作是pop。</p> <div class=highlight><pre><span></span><code>a.pop()
# 9

print(a)
# [1, &#39;one&#39;, 3, 4, 5, 6, 7, 8]

a.pop(3)
# 4

print(a)
# [1, &#39;one&#39;, 3, 5, 6, 7, 8]
</code></pre></div> <p>删除列表中某个元素。</p> <div class=highlight><pre><span></span><code>print(a[1])
# one

del a[1]

print(a)
[1, 3, 5, 6, 7, 8]
</code></pre></div> <p>删除列表中某个元素。remove方法会定位第一个符合要求的值并移除</p> <div class=highlight><pre><span></span><code>a.remove(&#39;Italy&#39;)

print(a)
# [1, 3, 5, 6, 7, 8]
</code></pre></div> <p>统计某个元素出现的次数。</p> <div class=highlight><pre><span></span><code>print(a.count(1))
# 1
</code></pre></div> <p>返回列表中匹配项的索引位置。匹配不到抛出异常。</p> <div class=highlight><pre><span></span><code>print(a.index(2))
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# ValueError: 2 is not in list

print(a.index(3))
# 1
</code></pre></div> <p>判断元素是否存在于列表。</p> <div class=highlight><pre><span></span><code>print(3 in a)
# True

print(&#39;3&#39; in a)
# False
</code></pre></div> <p>反向输出列表。</p> <div class=highlight><pre><span></span><code>a.reverse()

print(a)
# [8, 7, 6, 5, 3, 1]
</code></pre></div> <p>取列表中最大值、最小值。</p> <div class=highlight><pre><span></span><code>print(min(a))
# 1

print(max(a))
# 78
</code></pre></div> <p>计算列表长度。</p> <div class=highlight><pre><span></span><code>print(len(a))
# 6
</code></pre></div> <p>列表扩展：</p> <div class=highlight><pre><span></span><code>a = [1, 2, 3]
b = [4, 5, 6]

print(a + b)
# [1, 2, 3, 4, 5, 6]

a.extend(b)  # a列表被修改
print(a)
# [1, 2, 3, 4, 5, 6]

print(b)
# [4, 5, 6]
</code></pre></div> <p>使用extend添加元素比使用加号（+）连接效率更高。因为使用加号（+）连接过程中创建了新列表，并且还要复制对象。</p> <div class=highlight><pre><span></span><code>a_list = [4, None, &#39;foo&#39;]
b_list = [7, 8, (2, 3)]
print(a_list + b_list)  # [4, None, &#39;foo&#39;, 7, 8, (2, 3)]  使用+号连接
a_list.extend(b_list)
print(a_list)  # [4, None, &#39;foo&#39;, 7, 8, (2, 3)]
</code></pre></div> <p>Python的一个惯例：如果一个函数或者方法对对象进行的是就地改动，那它就应该返回None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。</p> <p>下面是排序的例子<code>list.sort()</code>和<code>sorted(list)</code>的区别。</p> <div class=highlight><pre><span></span><code>list1 = [&#39;1&#39;, &#39;one&#39;, &#39;3&#39;, &#39;Four&#39;, &#39;5&#39;, &#39;two&#39;, &#39;apple&#39;, &#39;8&#39;, &#39;9&#39;]
print(list1)
# [&#39;1&#39;, &#39;one&#39;, &#39;3&#39;, &#39;Four&#39;, &#39;5&#39;, &#39;two&#39;, &#39;apple&#39;, &#39;8&#39;, &#39;9&#39;]

# 下面的操作不改变原列表
print(sorted(list1))
# [&#39;1&#39;, &#39;3&#39;, &#39;5&#39;, &#39;8&#39;, &#39;9&#39;, &#39;Four&#39;, &#39;apple&#39;, &#39;one&#39;, &#39;two&#39;]
print(sorted(list1, reverse=True))
# [&#39;two&#39;, &#39;one&#39;, &#39;apple&#39;, &#39;Four&#39;, &#39;9&#39;, &#39;8&#39;, &#39;5&#39;, &#39;3&#39;, &#39;1&#39;]
print(sorted(list1, key=len))
# [&#39;1&#39;, &#39;3&#39;, &#39;5&#39;, &#39;8&#39;, &#39;9&#39;, &#39;one&#39;, &#39;two&#39;, &#39;Four&#39;, &#39;apple&#39;]
print(list1)
# [&#39;1&#39;, &#39;one&#39;, &#39;3&#39;, &#39;Four&#39;, &#39;5&#39;, &#39;two&#39;, &#39;apple&#39;, &#39;8&#39;, &#39;9&#39;]


# 下面的操作直接修改原列表，返回值是None
print(list1.sort())
# None
print(list1)
# [&#39;1&#39;, &#39;3&#39;, &#39;5&#39;, &#39;8&#39;, &#39;9&#39;, &#39;Four&#39;, &#39;apple&#39;, &#39;one&#39;, &#39;two&#39;]
</code></pre></div> <p>列表复制，<code>+</code>和<code>*</code>的操作都是不修改原有的操作对象，而是构建一个全新的列表。</p> <div class=highlight><pre><span></span><code>c = list(&#39;Python&#39;)

print(a + c)
# [1, 2, 3, 4, 5, 6, &#39;P&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;]

print(a * 3)
# [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]
</code></pre></div> <p>如果在<code>a * n</code>这个语句中，序列<code>a</code>里的元素是对其他可变对象的引用的话，就需要格外注意了，因为这个式子的结果可能会出乎意料。</p> <p>比如，我们想用<code>my_list=[[]] * 3</code>来初始化一个由列表组成的列表，但是我们实际得到的列表里包含的3个元素其实是3个引用，而且这3个引用指向的都是*同一个*列表。看下面例子。</p> <div class=highlight><pre><span></span><code># 做法1
board = [[&#39;_&#39;] * 3 for i in range(3)]
print(board)
# [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]]

board[1][2] = &#39;X&#39;
print(board)
# [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;X&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]]


# 做法2
board = [[&#39;_&#39;] * 3] * 3
print(board)
# [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]]

board[1][2] = &#39;X&#39;
print(board)
# [[&#39;_&#39;, &#39;_&#39;, &#39;X&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;X&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;X&#39;]]
</code></pre></div> <p>下面也是同样的问题。</p> <div class=highlight><pre><span></span><code># 方法1
row = [&#39;_&#39;] * 3
board = []

for i in range(3):
    board.append(row)

print(board)
# [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]]

board[2][0] = &#39;X&#39;
print(board)
# [[&#39;X&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;X&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;X&#39;, &#39;_&#39;, &#39;_&#39;]]


# 方法2
row = []
board = []

for i in range(3):
    row = [&#39;_&#39;] * 3
    board.append(row)

print(board)
# [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]]

board[2][0] = &#39;X&#39;
print(board)
# [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;X&#39;, &#39;_&#39;, &#39;_&#39;]]
</code></pre></div> <p><strong>双端队列collections.deque</strong>，可以满足列表头尾部都增加的要求。</p> <p><code>deque()</code>中<code>maxlen</code>是一个可选参数，代表这个队列可以容纳的元素的数量，而且一旦设定，这个属性就不能修改了。</p> <p>当试图对一个已满<code>len(d)==d.maxlen</code>的队列做头部添加操作的时候，它尾部的元素会被删除掉。</p> <p><code>extendleft(iter)</code>方法会把迭代器里的元素逐个添加到双向队列的左边，因此迭代器里的元素会逆序出现在队列里。</p> <p>队列的旋转操作<code>rotate</code>接受一个参数n，当n &gt; 0时，队列的最右边的n个元素会被移动到队列的左边。当n &lt; 0时，最左边的n个元素会被移动到右边。</p> <div class=highlight><pre><span></span><code>from collections import deque

d = deque([1, 2, 3])
print(d)
# deque([1, 2, 3])

# 注意插入顺序
d.extendleft([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
print(d)
# deque([&#39;c&#39;, &#39;b&#39;, &#39;a&#39;, 1, 2, 3])

print(len(d))
# 6
print(d[-2])
# 2

# 统计字符a出现的次数
print(d.count(&#39;a&#39;))
# 1

# 返回字符a的索引值
print(d.index(&#39;a&#39;))
# 2

# 第0位插入数字1，其余顺移
d.insert(0, 1)
print(d)
# deque([1, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, 1, 2, 3])

# 把右边2个元素放到左边，注意顺序，和extendleft不一样
d.rotate(2)
print(d)
# deque([2, 3, 1, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, 1])

d.rotate(-2)
print(d)
# deque([1, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, 1, 2, 3])
</code></pre></div> <p>下表总结了列表和双向队列的方法（不包括由对象实现的方法）。</p> <p><img alt=列表和双向队列的方法 src=../assets/python_foundation_03.png></p> <p>列表排序。排序对列表元素的数据类型是有要求的。</p> <div class=highlight><pre><span></span><code>a_list = [4, None, &#39;foo&#39;, 7, 8, (2, 3)]
a_list.sort() 
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# TypeError: &#39;&lt;&#39; not supported between instances of &#39;NoneType&#39; and &#39;int&#39;

b_list = [7, 8, (2, 3)]
b_list.sort()
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# TypeError: &#39;&lt;&#39; not supported between instances of &#39;tuple&#39; and &#39;int&#39;

a_list = [7, 2, 5, 1, 3]
a_list.sort()  # 按数值大小排序
print(a_list)  # [1, 2, 3, 5, 7]

b_list = [&#39;saw&#39;, &#39;small&#39;, &#39;He&#39;, &#39;foxes&#39;, &#39;six&#39;]
b_list.sort(key=len)  # 通过字符串的长度进行排序
print(b_list)  # [&#39;He&#39;, &#39;saw&#39;, &#39;six&#39;, &#39;small&#39;, &#39;foxes&#39;]
</code></pre></div> <p>列表二分搜索和已排序列表的维护</p> <ul> <li>bisect 返回要插入元素在列表中的下标。假定列表是有序的。</li> <li>bisect_left 与 bisect 类似，只不过其默认将元素插到左边，所以返回的是插入到左边的下标</li> <li>bisect_right与 bisect_left 相反。</li> </ul> <p>以上方法若列表无序，那么会返回插入到列表最后一个合适的位置。</p> <p>insort 会在列表中插入元素到正确位置，假定列表有序。如果列表无序，那么会返回空。默认插入到右边。</p> <p>insort_left 和insort_right 类似。</p> <div class=highlight><pre><span></span><code>import bisect

c = [1, 2, 3, 4, 7]
print(bisect.bisect(c, 2))  # 2 bisect会找到第一个2,并把新的2插入它后面

bisect.insort(c, 2)  # [1, 2, 2, 3, 4, 7]
print(bisect.bisect(c, 5))  # 5 bisect会找到第一个4,并把新的5插入它后面

bisect.insort(c, 5)
print(bisect.bisect(c, 6))  # 6 bisect会找到第一个5,并把新的6插入它后面

bisect.insort(c, 6)
print(c)  # [1, 2, 2, 3, 4, 5, 6, 7]
</code></pre></div> <p>bisect可以用来建立一个用数字作为索引的查询表格，如下例，把分数和成绩对应起来，根据一个分数，找到它所对应的成绩。 <div class=highlight><pre><span></span><code>import bisect

def grade(score, breakpoints=[60, 70, 80, 90], grades=&#39;FDCBA&#39;):
    i = bisect.bisect(breakpoints, score)
    return grades[i]

[grade(score) for score in [15, 26, 31, 62, 79, 85]]
# [&#39;F&#39;, &#39;F&#39;, &#39;F&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;]
</code></pre></div></p> <p>用bisect.insort插入新元素，并能保持seq的升序顺序。</p> <div class=highlight><pre><span></span><code>import bisect
import random

size = 7
random.seed(1729)
my_list = []

for i in range(size):
    new_item = random.randrange(size*2)
    bisect.insort(my_list, new_item)
    print(f&#39;{new_item:2d} :--&gt; {my_list}&#39;)

# 10 :--&gt; [10]
#  0 :--&gt; [0, 10]
#  6 :--&gt; [0, 6, 10]
#  8 :--&gt; [0, 6, 8, 10]
#  7 :--&gt; [0, 6, 7, 8, 10]
#  2 :--&gt; [0, 2, 6, 7, 8, 10]
# 10 :--&gt; [0, 2, 6, 7, 8, 10, 10]
</code></pre></div> <h3 id=14-dictionary>1.4 字典（dictionary）<a class=headerlink href=#14-dictionary title="Permanent link"> ¶</a></h3> <p>字典(dict)是使用键-值（key-value）存储，键是不可变对象，且不允许重复。</p> <p>dict（字典）更为常用的名字是哈希表或者是关联数组。 字典是拥有灵活尺寸的键值对集合，不是通过位置进行索引，其中键和值都是Python对象。用大括号{}是创建字典的一种方式，在字典中用逗号将键值对分隔。</p> <p>创建字典的几种方法：</p> <div class=highlight><pre><span></span><code>a = dict(one=1, two=2, three=3)
b = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}
c = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))
d = dict([(&#39;two&#39;, 2), (&#39;three&#39;, 3), (&#39;one&#39;, 1)])
e = dict({&#39;three&#39;: 3, &#39;one&#39;: 1, &#39;two&#39;: 2})

print(a == b == c == d == e)
# True
</code></pre></div> <p><strong>字典常用方法</strong></p> <table> <thead> <tr> <th>方法名称</th> <th>作用</th> </tr> </thead> <tbody> <tr> <td>a.items()</td> <td>返回a中所有键值对</td> </tr> <tr> <td>a.values()</td> <td>返回a中所有值</td> </tr> <tr> <td>a.keys()</td> <td>返回a中所有键</td> </tr> <tr> <td>a.get()</td> <td>通过键来查值，返回对应的值</td> </tr> <tr> <td>a.clear()</td> <td>清空字典a的值</td> </tr> <tr> <td>a.setdefault</td> <td>通过键值来查找值，找不到则插入</td> </tr> <tr> <td>a.update()</td> <td>键和值更新到新的字典</td> </tr> <tr> <td>a.pop()</td> <td>删除指定位置的元素</td> </tr> </tbody> </table> <p>生成一个字典</p> <div class=highlight><pre><span></span><code>dict_a = {&#39;name&#39;: &#39;Ming&#39;, &#39;id&#39;: 1001, &#39;age&#39;: 35}

print(type(dict_a))
# &lt;class &#39;dict&#39;&gt;

dict_b = dict(city=&#39;Shanghai&#39;, strict=&#39;Xuhui&#39;, zip=&#39;200000&#39;)

print(type(dict_b))
# &lt;class &#39;dict&#39;&gt;
</code></pre></div> <p>通过键查询值，查询不到抛出异常</p> <div class=highlight><pre><span></span><code>print(dict_a[&#39;name&#39;])
# Ming

print(dict_a[&#39;Name&#39;])
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# KeyError: &#39;Name&#39;
</code></pre></div> <p>插入新的键值对</p> <div class=highlight><pre><span></span><code>dict_a[&#39;city&#39;] = &#39;Chengdu&#39;

print(dict_a)
# {&#39;name&#39;: &#39;Ming&#39;, &#39;id&#39;: 1001, &#39;city&#39;: &#39;Chengdu&#39;}
</code></pre></div> <p>删除某个键值对。pop方法会在删除的同时返回被删的值，并删除键。</p> <div class=highlight><pre><span></span><code>dict_a.pop(&#39;city&#39;)
# Chengdu

print(dict_a)
# {&#39;name&#39;: &#39;Ming&#39;, &#39;id&#39;: 1001}
</code></pre></div> <p>另一种方式删除某个键值对 </p> <div class=highlight><pre><span></span><code>del dict_a[&#39;age&#39;]
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# KeyError: &#39;age&#39;

del dict_a[&#39;id&#39;]

print(dict_a)
# {&#39;name&#39;: &#39;Ming&#39;}
</code></pre></div> <p>判断键是否存在</p> <div class=highlight><pre><span></span><code>dict_a[23] = &#39;Hello World&#39;

print(dict_a)
# {&#39;name&#39;: &#39;Ming&#39;, 23: &#39;Hello World&#39;}

print(23 in dict_a)
# True

print(35 in dict_a)
# False
</code></pre></div> <p>通过键查询值的另一种方式，查询不到不抛异常</p> <div class=highlight><pre><span></span><code>dict_a.get(&#39;hai&#39;)

dict_a.get(&#39;hai&#39;, 1)
# 1

dict_a.get(&#39;name&#39;, 1)
# Ming

dict_a[&#39;hai&#39;]
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# KeyError: &#39;hai&#39;
</code></pre></div> <p>通过键查询值的另一种方式，查询不到则添加</p> <div class=highlight><pre><span></span><code>dict_a.setdefault(&#39;name&#39;)
# Ming

dict_a.setdefault(&#39;hai&#39;, 1)
# 1

print(dict_a)
# {&#39;name&#39;: &#39;Ming&#39;, 23: &#39;Hello World&#39;, &#39;hai&#39;: 1}

dict_a.setdefault(&#39;go&#39;)
print(dict_a)
# {&#39;name&#39;: &#39;Ming&#39;, 23: &#39;Hello World&#39;, &#39;hai&#39;: 1, &#39;go&#39;: None}
</code></pre></div> <p>读取字典所有键值对，返回的是列表形式</p> <div class=highlight><pre><span></span><code>print(dict_a.items())
# dict_items([(&#39;name&#39;, &#39;Ming&#39;), (23, &#39;Hello World&#39;), (&#39;hai&#39;, 1), (&#39;go&#39;, None)])
</code></pre></div> <p>读取字典的键</p> <div class=highlight><pre><span></span><code>print(dict_a.keys())
# dict_keys([&#39;name&#39;, 23, &#39;hai&#39;, &#39;go&#39;])
</code></pre></div> <p>读取字典的值</p> <div class=highlight><pre><span></span><code>print(dict_a.values())
# dict_values([&#39;Ming&#39;, &#39;Hello World&#39;, 1, None])
</code></pre></div> <p>将字典值转化成列表</p> <div class=highlight><pre><span></span><code>print(list(dict_a.values()))
# [&#39;Ming&#39;, &#39;Hello World&#39;, 1, None]

for key in dict_a.keys():
    print(dict_a[key])

# Ming
# Hello World
# 1
# None
</code></pre></div> <p>清空字典</p> <div class=highlight><pre><span></span><code>dict_a.clear()

print(dict_a)
# {}

print(len(dict_a))
# 0
</code></pre></div> <p>对于任何原字典中已经存在的键，如果传给update方法的数据也含有相同的键，则它的值将会被覆盖。</p> <div class=highlight><pre><span></span><code>dict_a = {&#39;name&#39;: &#39;Ming&#39;, &#39;id&#39;: 1001, &#39;age&#39;: 35}
dict_b = dict(city=&#39;Shanghai&#39;, id=2001, zip=&#39;200000&#39;)

dict_a.update(dict_b)

print(dict_a)
# {&#39;name&#39;: &#39;Ming&#39;, &#39;id&#39;: 2001, &#39;age&#39;: 35, &#39;city&#39;: &#39;Shanghai&#39;, &#39;zip&#39;: &#39;200000&#39;}
</code></pre></div> <p><strong>从列表生成字典</strong></p> <p>字典本质上是2-元组（含有2个元素的元组）的集合，字典是可以接受一个2-元组的列表作为参数的。</p> <div class=highlight><pre><span></span><code># 方法1
mapping = {}
key_list = list(range(5))
value_list = list(reversed(range(5)))

for key, value in zip(key_list, value_list):
    mapping[key] = value

print(mapping)  
# {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}

# 方法2。
mapping = {}
key_list = list(range(5))
value_list = list(reversed(range(5)))

mapping = dict(zip(key_list, value_list))  
print(mapping)  # {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
</code></pre></div> <p><strong>有效的字典键类型</strong></p> <p>尽管字典的值可以是任何Python对象，但键必须是不可变的对象，比如标量类型（整数、浮点数、字符串）或元组（且元组内对象也必须是不可变对象）。</p> <p>通过hash函数可以检查一个对象是否可以哈希化（即是否可以用作字典的键），术语叫作哈希化。</p> <div class=highlight><pre><span></span><code>print(hash(&#39;string&#39;))  
# -4368784820203065343

print(hash((1, 2, (2, 3))))  
# -9209053662355515447

print(hash((1, 2, [2, 3])))  
# TypeError: unhashable type: &#39;list&#39;

print(hash((1, 2, tuple([2, 3]))))  
# -9209053662355515447  为了将列表作为键，一种方式就是将其转换为元组
</code></pre></div> <p><strong>字典默认值</strong></p> <p>下面的例子，实现了将一个单词组成的列表，转换成单词首字母和单词为键值对的字典。先用传统方法实现，再用字典的setdefault方法进行改写。</p> <p>先看传统方法。</p> <div class=highlight><pre><span></span><code>words = [&#39;apple&#39;, &#39;bat&#39;, &#39;bar&#39;, &#39;atom&#39;, &#39;book&#39;]

by_letter = {}

for word in words:
    letter = word[0]  # word[0]把列表words的每个元素列表化，并取首字母。输出的是a, b, b, a, b这5个列表元素的首字母
    if letter not in by_letter:
        # 生成第一个键值对
        print(letter)
        by_letter[letter] = [word]  # 对比[word]和word[]的用法
        print(by_letter)
        # a
        # {&#39;a&#39;: [&#39;apple&#39;]}
        # b
        # {&#39;a&#39;: [&#39;apple&#39;], &#39;b&#39;: [&#39;bat&#39;]}
    else:
        # append其他键值对
        print(letter)
        by_letter[letter].append(word)
        print(by_letter)
        # b
        # {&#39;a&#39;: [&#39;apple&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;]}
        # a
        # {&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;]}
        # b
        # {&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]}

print(by_letter)  
# {&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]}
</code></pre></div> <p>用字典的setdefault方法，上述的for循环语句可以被写为如下。</p> <div class=highlight><pre><span></span><code>words = [&#39;apple&#39;, &#39;bat&#39;, &#39;bar&#39;, &#39;atom&#39;, &#39;book&#39;]

by_letter = {}

for word in words:
    letter = word[0]  # word[0]的输出依然是5个列表元素的首字母a, b, b, a, b
    by_letter.setdefault(letter, []).append(word)  # 如果letter不在[]则通过append添加word

print(by_letter)  
# {&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]}
</code></pre></div> <p>如果改写为<code>by_letter.setdefault(letter, ['a']).append(word)</code> ，则输出<code>by_letter</code>是 <code>{'a': ['a', 'apple', 'atom'], 'b': ['a', 'bat', 'bar', 'book']}</code>。</p> <div class=highlight><pre><span></span><code>words = [&#39;apple&#39;, &#39;bat&#39;, &#39;bar&#39;, &#39;atom&#39;, &#39;book&#39;]

by_letter = {}

for word in words:
    letter = word[0]  # word[0]的输出依然是5个列表元素的首字母a, b, b, a, b
    by_letter.setdefault(letter, [&#39;a&#39;]).append(word)

print(by_letter)  
# {&#39;a&#39;: [&#39;a&#39;, &#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;a&#39;, &#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]}
</code></pre></div> <p>体会setdefault()的注释“Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.”</p> <p>通过defaultdict类使得上述目的实现更为简单。</p> <div class=highlight><pre><span></span><code>from collections import defaultdict

by_letter = defaultdict(list)  # list是内置的可变序列(Built-in mutable sequence)

print(dict(by_letter))  
# {}

for word in words:
    by_letter[word[0]].append(word)

print(by_letter)  
# defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]})

print(dict(by_letter))  
# {&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]}
</code></pre></div> <p>下表展示了<code>dict</code>、<code>defaultdict</code>和<code>OrderedDict</code>的常见方法，后面两个数据类型是<code>dict</code>的变种，位于<code>collections</code>模块内。</p> <p><img alt=dict、collections.defaultdict和collections.OrderedDict这三种映射类型的方法列表 src=../assets/python_foundation_04.png></p> <p>* <code>default_factory</code>并不是一个方法，而是一个可调用对象（callable），它的值在<code>defaultdict</code>初始化的时候由用户设定。</p> <p># <code>OrderedDict.popitem()</code>会移除字典里最先插入的元素（先进先出）；同时这个方法还有一个可选的last参数，若为真，则会移除最后插入的元素（后进先出）。</p> <p>上面的表格中，update方法处理参数m的方式，是典型的“鸭子类型”。函数首先检查m是否有keys方法，如果有，那么update函数就把它当作映射对象来处理。否则，函数会退一步，转而把m当作包含了键值对(key, value)元素的迭代器。Python里大多数映射类型的构造方法都采用了类似的逻辑，因此你既可以用一个映射对象来新建一个映射对象，也可以用包含(key, value)元素的可迭代对象来初始化一个映射对象。</p> <p><strong>字典的变种</strong></p> <p>collections.OrderedDict</p> <p>这个类型在添加键的时候会保持顺序，因此键的迭代次序总是一致的。OrderedDict的popitem方法默认删除并返回的是字典里的最后一个元素，但是如果像my_odict.popitem(last=False)这样调用它，那么它删除并返回第一个被添加进去的元素。</p> <p>collections.ChainMap</p> <p>该类型可以容纳数个不同的映射对象，然后在进行键查找操作的时候，这些对象会被当作一个整体被逐个查找，直到键被找到为止。这个功能在给有嵌套作用域的语言做解释器的时候很有用，可以用一个映射对象来代表一个作用域的上下文。</p> <p>collections.Counter</p> <p>这个映射类型会给键准备一个整数计数器。每次更新一个键的时候都会增加这个计数器。所以这个类型可以用来给可散列表对象计数，或者是当成多重集来用——多重集合就是集合里的元素可以出现不止一次。Counter实现了+和-运算符用来合并记录，还有像most_common([n])这类很有用的方法。most_common([n])会按照次序返回映射里最常见的n个键和它们的计数</p> <p>下面的例子利用Counter来计算单词中各个字母出现的次数：</p> <div class=highlight><pre><span></span><code>str = &#39;abracadabra&#39;
ct = collections.Counter(str)

print(ct)
# Counter({&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;r&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1})
</code></pre></div> <p>collections.UserDict</p> <p>这个类其实就是把标准dict用纯Python又实现了一遍。跟OrderedDict、ChainMap和Counter这些开箱即用的类型不同，UserDict是让用户继承写子类的。</p> <p><strong>不可变映射类型</strong></p> <p>标准库里所有的映射类型都是可变的，但有时候你会有这样的需求，比如不能让用户错误地修改某个映射。</p> <p>从Python 3.3开始，types模块中引入了一个封装类名叫MappingProxyType。如果给这个类一个映射，它会返回一个只读的映射视图。虽然是个只读视图，但是它是动态的。这意味着如果对原映射做出了改动，我们通过这个视图可以观察到，但是无法通过这个视图对原映射做出修改。</p> <p>通过下例可以看出，<code>d</code>中的内容可以通过<code>d_proxy</code>看到。但是通过<code>d_proxy</code>并不能做任何修改。<code>d_proxy</code>是动态的，也就是说对<code>d</code>所做的任何改动都会反馈到它上面。</p> <div class=highlight><pre><span></span><code>from types import MappingProxyType

d = {1: &#39;A&#39;}
d_proxy = MappingProxyType(d)

print(d)
# {1: &#39;A&#39;}
print(d_proxy)
# {1: &#39;A&#39;}

print(d[1])
# A
print(d_proxy[1])
# A


d[2] = &#39;W&#39;
print(d)
# {1: &#39;A&#39;, 2: &#39;W&#39;}

d_proxy[2] = &#39;W&#39;
# TypeError: &#39;mappingproxy&#39; object does not support item assignment

print(d_proxy)
# {1: &#39;A&#39;, 2: &#39;W&#39;}
</code></pre></div> <h3 id=15-set>1.5 集合（set）<a class=headerlink href=#15-set title="Permanent link"> ¶</a></h3> <p>“集”这个概念在Python中算是比较年轻的，同时它的使用率也比较低。set和它的不可变的姊妹类型frozenset直到Python 2.3才首次以模块的形式出现，然后在Python 2.6中它们升级成为内置类型。</p> <p><strong>集合(set)</strong>，包含不可变的集合（frozenset），是一种无序且元素唯一的序列，所以集合的本质是许多唯一对象的聚集。</p> <p>和字典类似，集合的元素是不可变的。可以认为集合也像字典，但是只有键没有值。基本功能是进行成员关系测试和删除重复元素。所以集合另一个用途是去重复。</p> <p>集合中的元素必须是可散列的，set类型本身是不可散列的，但是frozenset可以。因此可以创建一个包含不同frozenset的set。</p> <p>集合可以有两种创建方式：通过set()函数或者{}来创建（用大括号括住的内容，Python3自动定义为集合）。</p> <p>集合不属于序列类数据， 集合不支持通过索引访问指定元素，但可以增加和删除元素。</p> <p>面的例子是求<code>haystacke</code>和<code>needles</code>两个集合的交集元素个数。</p> <div class=highlight><pre><span></span><code>haystacke = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;}
needles = {&#39;c&#39;, &#39;h&#39;, &#39;w&#39;}

type(haystacke)
# &lt;class &#39;set&#39;&gt;
type(needles)
# &lt;class &#39;set&#39;&gt;

# 传统方法
found = 0

for i in needles:
    if i in haystacke:
        found += 1

print(found)
# 2


# 集合方法一
found = len(needles &amp; haystacke)
print(found)
# 2

# 集合方法二
found = len(needles.intersection(haystacke))
print(found)
# 2
</code></pre></div> <p>集合实现了很多基础的中缀运算符，比如，集合支持数学上的集合操作：并集、交集、差集、对称差集。</p> <table> <thead> <tr> <th>方法名称</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>add()</td> <td>为集合添加元素</td> </tr> <tr> <td>update()</td> <td>给集合添加元素</td> </tr> <tr> <td>clear()</td> <td>移除集合中的所有元素</td> </tr> <tr> <td>copy()</td> <td>拷贝一个集合</td> </tr> <tr> <td>remove()</td> <td>移除指定元素</td> </tr> <tr> <td>pop()</td> <td>随机移除元素</td> </tr> <tr> <td>discard()</td> <td>删除集合中指定的元素</td> </tr> <tr> <td>&lt; 或者issubset()</td> <td>判断指定集合是否为该方法参数集合的子集</td> </tr> <tr> <td>| 或者union()</td> <td>返回两个集合的并集</td> </tr> <tr> <td>&amp; 或者intersection()</td> <td>返回集合的交集</td> </tr> <tr> <td>intersection_update()</td> <td>返回集合的交集</td> </tr> <tr> <td>- 或者difference()</td> <td>返回多个集合的差集</td> </tr> <tr> <td>difference_update()</td> <td>移除集合中的元素，该元素在指定的集合也存在</td> </tr> <tr> <td>^ 或者symmetric_difference()</td> <td>返回两个集合中不重复的元素集合(两集合除去交集部分的元素)</td> </tr> <tr> <td>symmetric_difference_update()</td> <td>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中</td> </tr> <tr> <td>isdisjoint()</td> <td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False</td> </tr> <tr> <td>issuperset()</td> <td>判断该方法的参数集合是否为指定集合的子集</td> </tr> </tbody> </table> <p>举例</p> <div class=highlight><pre><span></span><code>a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2}
b = {1, &#39;c&#39;, &#39;d&#39;}
</code></pre></div> <p>并集(a和b中的所有不同元素)</p> <div class=highlight><pre><span></span><code>print(a.union(b))  # {&#39;c&#39;, 1, 2, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;}
print(a | b)  # {&#39;c&#39;, 1, 2, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;}
</code></pre></div> <p>交集(a、b中同时包含的元素)</p> <div class=highlight><pre><span></span><code>print(a.intersection(b))  # {&#39;c&#39;, 1}
print(a &amp; b)  # {&#39;c&#39;, 1}
</code></pre></div> <p>将a的内容设置为a和b的交集</p> <div class=highlight><pre><span></span><code>a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2}
b = {1, &#39;c&#39;, &#39;d&#39;}
a.intersection_update(b)
print(a)  # {1, &#39;c&#39;}
</code></pre></div> <p>在a不在b的元素</p> <div class=highlight><pre><span></span><code>print(a.difference(b))  # {&#39;a&#39;, 2, &#39;b&#39;}
print(a - b)  # {2, &#39;a&#39;, &#39;b&#39;}
</code></pre></div> <p>将a的内容设为在a不在b的元素</p> <div class=highlight><pre><span></span><code>a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2}
b = {1, &#39;c&#39;, &#39;d&#39;}
a.difference_update(b)
print(a)  # {2, &#39;b&#39;, &#39;a&#39;}
a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2}
b = {1, &#39;c&#39;, &#39;d&#39;}
a -= b
print(a)  # {2, &#39;a&#39;, &#39;b&#39;}
</code></pre></div> <p>将元素加入集合a</p> <div class=highlight><pre><span></span><code>a.add(7)
print(a)  # {1, 2, &#39;c&#39;, 7, &#39;a&#39;, &#39;b&#39;} 每次输出的顺序是不一样的
</code></pre></div> <p>从集合a移除某个元素</p> <div class=highlight><pre><span></span><code>a.remove(7)
print(a)  # {1, 2, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;}  如果a被清空，则报错 KeyError: 7
</code></pre></div> <p>所有在a或b中，但不是同时在a、b中的元素</p> <div class=highlight><pre><span></span><code>print(a.symmetric_difference(b))  # {2, &#39;d&#39;, &#39;b&#39;, &#39;a&#39;}
print(a ^ b)  # {2, &#39;d&#39;, &#39;b&#39;, &#39;a&#39;}
</code></pre></div> <p>将a的内容设为所有在a或b中，但不是同时在a、b中的元素</p> <div class=highlight><pre><span></span><code>a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2}
b = {1, &#39;c&#39;, &#39;d&#39;}
a.symmetric_difference_update(b)
print(a)  # {&#39;a&#39;, 2, &#39;d&#39;, &#39;b&#39;}
a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2}
b = {1, &#39;c&#39;, &#39;d&#39;}
a ^= b
print(a)  # {2, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;}
</code></pre></div> <p>如果a包含于b，返回Ture</p> <div class=highlight><pre><span></span><code>print(a.issubset(b))  # False
</code></pre></div> <p>将a的内容设置为a和b的并集</p> <div class=highlight><pre><span></span><code>print(a)  # {&#39;a&#39;, 2, &#39;d&#39;, &#39;b&#39;}
a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2}
a.update(b)
print(a)  # {1, 2, &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;c&#39;}
</code></pre></div> <p>移除任意元素，如果集合是空的，抛出keyError</p> <div class=highlight><pre><span></span><code>a.pop()  # 随机移除某个元素，没有输入变量，如果集合是空的，抛出KeyError: &#39;pop from an empty set&#39;
print(a)  # {2, 1, &#39;d&#39;, &#39;b&#39;, &#39;a&#39;}
</code></pre></div> <p>将集合重置为空，清空所有元素</p> <div class=highlight><pre><span></span><code>a.clear()
print(a)  # set()
</code></pre></div> <p>集合的元素必须是不可变的，如果想要包含列表型的元素，必须先转换为元组</p> <div class=highlight><pre><span></span><code>my_data1 = [1, 2, 3, 4]
my_data2 = [3, 4, 5, 6]
my_set = {tuple(my_data1), tuple(my_data2)}
print(my_set)  # {(1, 2, 3, 4), (3, 4, 5, 6)}
</code></pre></div> <h3 id=16-tuple>1.6 元组（tuple）<a class=headerlink href=#16-tuple title="Permanent link"> ¶</a></h3> <p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p> <p>元组使用小括号( )，列表使用方括号[ ]。</p> <p>元组中只包含一个元素时，需要在元素后面添加逗号 ，否则括号会被当作运算符使用。</p> <p>元组可以使用下标索引来访问元组中的值。</p> <p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合。</p> <p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组。</p> <div class=highlight><pre><span></span><code># 此处括号被解析为运算符，需要在后面加上逗号才会被解释为元组
tup1 = (10)
print(type(tup1))
# &lt;class &#39;int&#39;&gt;
tup1 = (10,)
print(type(tup1))
# &lt;class &#39;tuple&#39;&gt;
</code></pre></div> <p>创建元组最简单的办法就是用逗号分隔序列值。元组对数据类型没有一致性要求。</p> <div class=highlight><pre><span></span><code>tup = 4, 5, 6
print(tup)  # (4, 5, 6)

nested_tup = (4, 5, 6), (7, 8)
print(nested_tup)  # # ((4, 5, 6), (7, 8))

tup = (&#39;a&#39;, &#39;b&#39;, {&#39;one&#39;: 1})
print(type(tup))
# &lt;class &#39;tuple&#39;&gt;
</code></pre></div> <p>使用加号（+）进行元组连接合并。</p> <div class=highlight><pre><span></span><code>tup = tuple((4, None, &#39;fool&#39;) + (6, 0) + (&#39;bar&#39;,))
print(tup)  # (4, None, &#39;fool&#39;, 6, 0, &#39;bar&#39;)
</code></pre></div> <p>元组的不可变指的是**元组所指向的内存中的内容不可变**。</p> <div class=highlight><pre><span></span><code>tup = (&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;)
print(id(tup))
# 139820353350208

tup = (1, 2, 3, 4, 5)
print(id(tup))
# 139820353298896

tup[0] = &#39;x&#39;
# Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# TypeError: &#39;tuple&#39; object does not support item assignment
</code></pre></div> <p>将元组乘以整数，则会和列表一样，生成含有多份拷贝的元组。对象自身并没有复制，只是指向它们的引用进行了复制。</p> <div class=highlight><pre><span></span><code>tup = tuple((&#39;fool&#39;, &#39;bar&#39;) * 4)
print(tup)  # (&#39;fool&#39;, &#39;bar&#39;, &#39;fool&#39;, &#39;bar&#39;, &#39;fool&#39;, &#39;bar&#39;, &#39;fool&#39;, &#39;bar&#39;)
</code></pre></div> <p>如果元组中的一个对象是可变的，例如列表，你可以在它内部进行修改</p> <div class=highlight><pre><span></span><code>tup = tuple([&#39;foo&#39;, [4, 5, 6], True])
tup[1].append(0)
print(tup)  # (&#39;foo&#39;, [4, 5, 6, 0], True)
tup[1].append([9])
print(tup)  # (&#39;foo&#39;, [4, 5, 6, 0, [9]], True)
</code></pre></div> <p>使用tuple函数将任意序列或迭代器转换为元组</p> <div class=highlight><pre><span></span><code>tup = tuple([4, 5, 6])
print(tup)  # (4, 5, 6)
tup = tuple(&#39;string&#39;)
print(tup)  # (&#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;)
print(tup[2])  # r  # 元组的元素可以通过中括号[]来获取
</code></pre></div> <p>如果要将元组型的表达式赋值给变量，Python会对等号右边的值进行<a href=../ch03/ >拆包</a></p> <div class=highlight><pre><span></span><code>tup = (9, 5, (8, 7))
a, b, c = tup
print(a)  # 9
print(b)  # 5
print(c)  # (8, 7)
a, b, (c, d) = tup
print(a)  # 9
print(b)  # 5
print(c)  # 8
print(d)  # 7

tup = (9, 5, (8, 7))
a, b, c = tup
c, a = a, c  # 利用拆包实现交换
print(a)  # (8, 7)
print(b)  # 5
print(c)  # 9
</code></pre></div> <p>利用拆包实现遍历元组或列表组成的序列</p> <div class=highlight><pre><span></span><code>seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
for a, b, c in seq:
    print(&#39;a={0}, b={0}, c={0}&#39;.format(a, b, c))  # 列表每个元素的取值顺序
    # a=1, b=1, c=1
    # a=4, b=4, c=4
    # a=7, b=7, c=7
    print(&#39;a={0}, b={1}, c={2}&#39;.format(a, b, c))
    # a=1, b=2, c=3
    # a=4, b=5, c=6
    # a=7, b=8, c=9
    print(&#39;a={2}, b={0}, c={1}&#39;.format(a, b, c))
    # a=3, b=1, c=2
    # a=6, b=4, c=5
    # a=9, b=7, c=8
</code></pre></div> <p>元组拆包功能还包括特殊的语法*rest。很多Python编程者会使用下划线（_）来表示不想要的变量 </p> <div class=highlight><pre><span></span><code>values = 1, 2, 3, 4, 5
a, b, *rest = values
print(a)  # 1
print(b)  # 2
print(*rest)  # 3 4 5
a, b, *_ = values
print(*_)  # 3 4 5
</code></pre></div> <p><strong>具名元组</strong></p> <p><code>collections.namedtuple</code>是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。 用namedtuple构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。</p> <p>创建一个具名元组需要两个参数，一个是类名(<code>City</code>)，另一个是类的各个字段的名字(<code>'name country population coordinates'</code>)。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。</p> <p>存放在对应字段里的数据要以一串参数的形式传入到构造函数中（注意，元组的构造函数却只接受单一的可迭代对象）。</p> <p>具名元组还有一些自己专有的属性。下面展示了几个最有用的：<code>_fields</code>类属性、类方法<code>_make(iterable)</code>和实例方法<code>_asdict()</code>。</p> <p><code>_fields</code>属性是一个包含这个类所有字段名称的元组。</p> <p>用<code>_make()</code>通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟<code>City(*delhi_data)</code>是一样的。</p> <p><code>_asdict()</code>把具名元组以<code>collections.OrderedDict</code>的形式返回，我们可以利用它来把元组里的信息友好地呈现出来。</p> <div class=highlight><pre><span></span><code>from collections import namedtuple

City = namedtuple(&#39;City&#39;, &#39;name country population coordinates&#39;)

tokyo = City(&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139691667))

print(tokyo)
# City(name=&#39;Tokyo&#39;, country=&#39;JP&#39;, population=36.933, coordinates=(35.689722, 139691667))

print(tokyo.population)
# 36.933

print(tokyo[3])
# (35.689722, 139691667)

print(City._fields)
# (&#39;name&#39;, &#39;country&#39;, &#39;population&#39;, &#39;coordinates&#39;)



LatLong = namedtuple(&#39;LatLong&#39;, &#39;lat long&#39;)
delhi_data = (&#39;Delhi NCR&#39;, &#39;IN&#39;, 21.935, LatLong(28.613899, 77.208889))
delhi = City._make(delhi_data)

print(delhi)
# City(name=&#39;Delhi NCR&#39;, country=&#39;IN&#39;, population=21.935, coordinates=LatLong(lat=28.613899, long=77.208889))

print(delhi._asdict())
# OrderedDict([(&#39;name&#39;, &#39;Delhi NCR&#39;), (&#39;country&#39;, &#39;IN&#39;), (&#39;population&#39;, 21.935), (&#39;coordinates&#39;, LatLong(lat=28.613899, long=77.208889))])

for key, value in delhi._asdict().items():
    print(key + &#39;:&#39;, value)

# name: Delhi NCR
# country: IN
# population: 21.935
# coordinates: LatLong(lat=28.613899, long=77.208889)
</code></pre></div> <p>元组还有第二重功能：作为不可变列表的元组。</p> <p>下面是列表或元组的方法和属性对比。除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。还有一个例外，元组没有__reversed__方法。</p> <p><img alt=列表或元组的方法和属性对比 src=../assets/python_foundation_01.png></p> <p><strong>一个关于+=和*=的谜题</strong></p> <p>下面的例子展示了<code>*=</code>在可变和不可变序列上的作用。列表的ID没变，新元素追加到列表上，但执行增量乘法后，新的元组被创建。 <div class=highlight><pre><span></span><code>list1 = [1, 2, 3, 4]
id(list1)
# 140409777308808

list1 *= 2
print(list1)
# [1, 2, 3, 4, 1, 2, 3, 4]
id(list1)
# 140409777308808


tuple1 = (1, 2, 3, 4)
id(tuple1)
# 140409777230536

tuple1 *= 2
print(tuple1)
# (1, 2, 3, 4, 1, 2, 3, 4)
id(tuple1)
# 140409780104888
</code></pre></div></p> <p>但对于下面的例子，虽然<code>tuple1[2] += [50, 60]</code>执行时有异常抛出，但<code>tuple1</code>却被修改了。</p> <div class=highlight><pre><span></span><code>t = (1, 2, [10, 20])

t[2] += [50, 60]
# TypeError: &#39;tuple&#39; object does not support item assignment

print(t)
# (1, 2, [10, 20, 50, 60])
</code></pre></div> <p>下图大致描述了上述执行过程。</p> <p><img alt=元组赋值之谜 src=../assets/python_foundation_02.png></p> <p>为了避免上面情况的发生，我们**不要把可变对象放在元组里面**。增量赋值不是一个原子操作，它虽然抛出了异常，但还是完成了操作。</p> <h3 id=17-memoryview>1.7 内存视图Memoryview<a class=headerlink href=#17-memoryview title="Permanent link"> ¶</a></h3> <p>memoryview是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。 内存视图其实是泛化和去数学化的NumPy数组。它让你在不需要复制内容的前提下，在数据结构之间共享内存。 其中数据结构可以是任何形式，比如PIL图片、SQLite数据库和NumPy的数组，等等。这个功能在处理大型数据集合的时候非常重要。</p> <p>memoryview.cast的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且内容字节不会随意移动。这跟C语言中类型转换的概念差不多。 memoryview.cast会把同一块内存里的内容打包成一个全新的memoryview对象给你。</p> <p><code>array</code>里面的Type code：</p> <ul> <li>'b' signed integer 1 </li> <li>'B' unsigned integer 1 </li> <li>'u' Unicode character 2 (see note) </li> <li>'h' signed integer 2 </li> <li>'H' unsigned integer 2 </li> <li>'i' signed integer 2 </li> <li>'I' unsigned integer 2 </li> <li>'l' signed integer 4 </li> <li>'L' unsigned integer 4 </li> <li>'q' signed integer 8 (see note) </li> <li>'Q' unsigned integer 8 (see note) </li> <li>'f' floating point 4 </li> <li>'d' floating point 8</li> </ul> <div class=highlight><pre><span></span><code>numbers = array(&#39;h&#39;, [-2, -1, 0, 1, 2])
# array(&#39;h&#39;, [-2, -1, 0, 1, 2])

# 用5个短整型有符号整数的数组（类型码是&#39;h&#39;）创建一个memoryview。
memv = memoryview(numbers)

# memv里的5个元素跟数组里的没有区别。
print(len(memv))
# 5
print(memv[0])
# -2
print(memv.tolist())
# [-2, -1, 0, 1, 2]


# 创建一个memv_oct，这一次是把memv里的内容转换成&#39;B&#39;类型，也就是无符号字符。
memv_oct = memv.cast(&#39;B&#39;)
print(memv_oct.tolist())
# [254, 255, 255, 255, 0, 0, 1, 0, 2, 0]

# 把位于位置5的字节赋值成4。因为我们把占2个字节的整数的高位字节改成了4，所以这个有符号整数的值就变成了1024。
memv_oct[5] = 4
print(numbers)
# array(&#39;h&#39;, [-2, -1, 1024, 1, 2])
</code></pre></div> <h2 id=2>2. 动态引用、强类型<a class=headerlink href=#2 title="Permanent link"> ¶</a></h2> <p>星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数</p> <div class=highlight><pre><span></span><code>def printinfo(arg1, *vartuple):
    print(&quot;输出任何传入的参数: &quot;)
    print(arg1)
    print(vartuple)

    for var in vartuple:
        print(var)
    return

printinfo(10)
# 10
# ()

printinfo(70, 60, 50)
# 70
# (60, 50)
# 60
# 50
</code></pre></div> <p>两个星号 ** 的参数会以字典的形式导入</p> <div class=highlight><pre><span></span><code>def printinfo(arg1, **vardict):
    print(&quot;输出任何传入的参数: &quot;)
    print(arg1)
    print(vardict)

printinfo(1, a=2, b=3)
# 1
# {&#39;a&#39;: 2, &#39;b&#39;: 3}  字典格式输出
</code></pre></div> <p>Python中的对象引用并不涉及类型。变量对于对象来说只是特定命名空间中的名称；类型信息是存储在对象自身之中。</p> <div class=highlight><pre><span></span><code>a = 5
print(type(a))  
# &lt;class &#39;int&#39;&gt;

a = &#39;foo&#39;
print(type(a))  
# &lt;class &#39;str&#39;&gt;
</code></pre></div> <p>Python是强类型语言，所有的对象都拥有一个指定的类型（或类），隐式的转换只在某些特定、明显的情况下发生。</p> <div class=highlight><pre><span></span><code>a = 4.5
b = 2
print(&#39;a is {0}, b is {1}&#39;.format(type(a), type(b)))  
# a is &lt;class &#39;float&#39;&gt;, b is &lt;class &#39;int&#39;&gt; 字串格式化，用于后续访问

print(a / b)  
# 2.25
</code></pre></div> <p>使用isinstance函数来检查一个对象是否是特定类型的实例。isinstance接受一个包含类型的元组，可以检查对象的类型是否在元组中的类型中。</p> <div class=highlight><pre><span></span><code>a = 5
b = 4.5
c = &#39;foo&#39;
print(isinstance(a, int))  
# True
print(isinstance(b, str))  
# False
print(isinstance(c, (str, int)))  
# True
print(isinstance(c, (float, int)))  
# False
</code></pre></div> <p>属性和方法也可以通过getattr函数获得。在其他的语言中，通过变量名访问对象通常被称为“反射”。</p> <div class=highlight><pre><span></span><code>b = &#39;foo&#39;
print(getattr(b, &#39;split&#39;))  
# &lt;built-in method split of str object at 0x7f1d603ba430&gt;
</code></pre></div> <h2 id=3>3. 二元运算符和比较运算<a class=headerlink href=#3 title="Permanent link"> ¶</a></h2> <p>检查两个引用是否指向同一个对象，可以使用is关键字。</p> <p>is和is not的常用之处是检查一个变量是否为None，因为None只有一个实例。</p> <div class=highlight><pre><span></span><code>a = [1, 2, 3]
b = a
c = list(a)  # list函数总是创建一个新的Python列表（即一份拷贝）

print(a is b)  
# True

print(a is not c)  
# True 

print(a == c)  
# True

d = None
print(d is None)  
# True   
</code></pre></div> <p>Python中的大部分对象，例如列表、字典、NumPy数组都是可变对象，大多数用户定义的类型（类）也是可变的。</p> <p>可变对象中包含的对象和值是可以被修改的。还有其他一些对象是不可变的，比如字符串、元组。</p> <div class=highlight><pre><span></span><code>a_list = [&#39;foo&#39;, 2, [4, 5]]  # 列表
a_list[2] = (3, 4)

print(a_list)  # [&#39;foo&#39;, 2, (3, 4)]
a_tuple = (3, 5, (4, 5))  # 元组

a_tuple[1] = &#39;four&#39;  
# TypeError: &#39;tuple&#39; object does not support item assignment 不可被修改

print(a_tuple)  
# (3, 5, (4, 5))
</code></pre></div> <h2 id=4>4. 标量类型<a class=headerlink href=#4 title="Permanent link"> ¶</a></h2> <p>Python标量类型：None, str, bytes, float, bool, int</p> <p>数值类型。</p> <p>基础的Python数字类型就是int和float。int可以存储任意大小数字。浮点数在Python中用float表示，每一个浮点数都是双精度64位数值。</p> <div class=highlight><pre><span></span><code>ival = 17338971
print(ival ** 6)  
# 27173145946003847721495630081806010734757321

fval = 17338971.0
print(fval ** 6)  
# 2.7173145946003847e+43

print(3 / 2)  
# 1.5
print(3 // 2)  
# 1
</code></pre></div> <p>字符串。</p> <p>Python的字符串是不可变的。</p> <div class=highlight><pre><span></span><code>a = 5.6
s = str(a)

print(s)  
# 5.6

b = &#39;python&#39;
print(list(b))  
# [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;]

print(b[2])  
# t

b[2] = &#39;f&#39;  
# TypeError: &#39;str&#39; object does not support item assignment 字符串是不可变的
</code></pre></div> <p>反斜杠符号\是一种转义符号，它用来指明特殊符号。</p> <p>如果你有一个不含特殊符号但含有大量反斜杠的字符串时，可以在字符串前面加一个前缀符号r，表明这些字符是原生字符，r是raw的简写，表示原生的。</p> <div class=highlight><pre><span></span><code>x = &#39;12\\34&#39;
y = r&#39;this\has\no\special\characters&#39;
print(x)  # 12\34
print(y)  # this\has\no\special\characters
</code></pre></div> <p>字符串格式化 {0:.2f}表示将第一个参数格式化为2位小数的浮点数 {1:s}表示将第二个参数格式化为字符串 {2:d}表示将第三个参数格式化整数 参考Python官方文档 https://docs.python.org/3.6/library/string.html <div class=highlight><pre><span></span><code>template = &#39;{0:.2f} {1:s} are worth US${2:d}&#39;
print(template.format(4.5560, &#39;Argentine Pesos&#39;, 1))  # 4.56 Argentine Pesos are worth US$1
</code></pre></div></p> <p>日期和时间</p> <div class=highlight><pre><span></span><code>from datetime import datetime, date, time

dt = datetime(2011, 10, 29, 20, 30, 21)

print(dt.day)  
# 29
print(dt.minute)  
# 30
print(dt.date())  
# 2011-10-29
print(dt.time())  
# 20:30:21
print(dt.replace(minute=0, second=0))  
# 2011-10-29 20:00:00  将分钟、秒替换为0
print(datetime.strptime(&#39;20091021&#39;, &#39;%Y%m%d&#39;))  
# 2009-10-21 00:00:00 字符串可以通过 strptime 函数转换为datetime对象

dt2 = datetime(2011, 11, 15, 22, 30)
delta = dt2 - dt
print(delta)  
# 17 days, 1:59:39
print(dt + delta)  
# 2011-11-15 22:30:00
</code></pre></div> <p>range函数返回一个迭代器，该迭代器生成一个等差整数序列。</p> <div class=highlight><pre><span></span><code>print(range(10))  
# range(0, 10)

print(list(range(10)))  
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(list(range(0, 20, 2)))  
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
</code></pre></div> <h2 id=5>5. 三元表达式<a class=headerlink href=#5 title="Permanent link"> ¶</a></h2> <p>value = true-expr if condition else false-expr</p> <div class=highlight><pre><span></span><code>x = 5
print(&#39;non-negative&#39; if x &gt;= 0 else &#39;negative&#39;)  # non-negative
</code></pre></div> </article> </div> </div> <a href=# class="md-top md-icon" data-md-component=top data-md-state=hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg> Back to top </a> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.instant", "navigation.top"], "search": "../../../assets/javascripts/workers/search.fcfe8b6d.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": null}</script> <script src=../../../assets/javascripts/bundle.b1047164.min.js></script> </body> </html>
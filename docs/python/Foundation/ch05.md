# 面向对象三大特性

三大特性：

* 封装
* 继承
* 多态




## 封装 Encapsulation

封装是使用特殊的语法，对成员属性和成员方法进行包装，限制一些访问和操作，达到保护和隐藏的目的。

封装机制保证了类内部数据结构的完整性，因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据，很好地避免了外部对内部数据的影响，提高了程序的可维护性。

对一个类实现良好的封装，用户只能借助暴露出来的类方法来访问数据，可以在这些暴露的方法中加入适当的控制逻辑，即可控制用户对类中属性或方法的操作。

对类进行良好的封装，主要是内部使用封装的成员，也提高了代码的复用性。 


类成员封装的级别：

* 公有的（public）
* 保护的（protected），在Python中并没有实现protected封装，属于开发者的约定俗成。
* 私有的（private），在Python中private封装是通过改名策略来实现的，并不是真正的私有化。


访问限制    | 共有的public  | 受保护的protected  | 私有的private
-----------|--------------|--------------------|---------------
在类的内部  | OK           | OK                 | OK  
在类的外部  | OK           | No (Python中可以)   | No

看下面的例子。

* `name`是共有属性，可以在外部调用tom.name。
* `_age`是受保护的属性，理论上在外部是不可调用的，但在Python中是可以调用的`tom._age`。
* `__phone`是私有属性，在外部是不可调用的，`tom.__get_phone()`报错“属性不存在”。
* 对应方法也是类似。
* 在类的内部对受保护对象和私有对象没有访问限制。`_get_age`可以调用私有属性`__phone`。

```
class Person():
    name = 'name'  # public
    _age = 0  # protected
    __phone = 'phone'  # private

    def __init__(self, n, a, p):
        self.name = n
        self._age = a
        self.__phone = p

    def get_name(self):
        print(f'My name is {self.name}')

    def _get_age(self):
        print(f'My age is {self._age}')
        print(f'My age is {self.__phone}')

    def __get_phone(self):
        print(f'My phone is {self.__phone}')


tom = Person('Tom', 18, 12345678)

tom.name
# 'Tom'
tom._age
# 18
tom.__phone
# AttributeError: 'Person' object has no attribute '__phone'

tom.get_name()
# My name is Tom

tom._get_age()
# My age is 18
# My age is 12345678

tom.__get_phone()
# AttributeError: 'Person' object has no attribute '__get_phone'
```







## 继承 Inheritance

在不指定继承的父类时，所有类都继承object类（系统提供）。

* 被其它类继承的类，称为父类，或者基类，或者超类。
* 继承其它类的类，称为子类，或者派生类（derived class）。
    * 子类继承父类后，就拥有了父类中的所有成员（除了私有成员）。
    * 子类继承父类后，并不会把父类的成员复制给子类，而是引用。
    * 子类可以直接调用父类的方法`super().BaseClassName`。如果父类方法有参数要求，子类调用时也有参数要求。
    * 子类继承父类后，可以重新定义父类中的方法，称为**重写（Override）**。
    * 子类继承父类后，定义父类中没有的方法，被称为对父类的扩展。
    * 一个父类可以被多个子类继承。


**派生类（derived class）**定义的语法如下所示:

```python
class BaseClassName():
    <statement-1>
    .
    .
    .
    <statement-N>

class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

名称`BaseClassName`必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置，例如，当基类定义在另一个模块中的时候:

```
class DerivedClassName(modname.BaseClassName):
```

派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 
如果基类本身也派生自其他某个类，则此规则将被递归地（recursively）应用。

派生类的实例化没有任何特殊之处: `DerivedClassName()`会创建该类的一个*新实例*。 
方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。

派生类可能会重写（override）其基类的方法。 
因为方法在调用同一对象的其他方法时没有特殊权限，所以调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。

在派生类中的重载方法（overriding method）实际上可能想要扩展而非简单地替换同名的基类方法。 
有一种方式可以简单地直接调用基类方法：即调用`BaseClassName.methodname(self, arguments)`。
请注意，仅当此基类可在全局作用域中以`BaseClassName`的名称被访问时方可使用此方式。

Python有两个内置函数可被用于继承机制：

* 使用`isinstance()`来检查一个实例的类型: `isinstance(obj, int)`仅会在`obj.__class__` 为`int`或某个派生自`int`的类时为`True`。
* 使用`issubclass()`来检查类的继承关系:`issubclass(bool, int)`为`True`，因为`bool`是`int`的子类。 但是，`issubclass(float, int)`为`False`，因为`float`不是`int`的子类。







### 多重继承 Multiple Inheritance

单继承（single-inheritance）：一个类只能继承一个父类方式。
```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

多继承（Multiple Inheritance）：一个类去继承多个类的方式。定义语句如下所示
```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

在最简单的情况下，搜索从父类所继承属性的操作是深度优先（depth-first）、从左至右（left-to-right）的，当层次结构中存在重叠时不会在同一个类中搜索两次。
因此，如果某一属性在`DerivedClassName`中未找到，则会到`Base1`中搜索它，然后（递归地）到`Base1`的基类中搜索，如果在那里未找到，再到`Base2`中搜索，依此类推。

真实情况更复杂；方法解析顺序会动态改变以支持对`super()`的协同调用。 
这种方式在某些其他多重继承型语言中被称为**后续方法调用（call-next-method）**，它比**单继承（single-inheritance）**语言中的`uper`调用更强大。

动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（diamond relationships）（即至少有一个父类可通过多条路径被最底层类所访问）。 
例如，所有类都是继承自`object`，因此任何多重继承的情况都提供了一条以上的路径可以通向 `object`。
为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（monotonic）（即一个类可以被子类化而不影响其父类的优先顺序）。 
总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。


看下面例子，定义了3个类和继承关系。
```
class F():

    def drink(self):
        print("Drink Beer")


class M():

    def drink(self):
        print("Drink Red Wine")


class C(F, M):

    def drink(self):
        print("Drink Water")
```

执行结果是
```
c = C()
c.drink()
# Drink Water
```

如果把`C`类改写为如下，可以调用父类，参照`C`类的mro进行，查找到`F`类。
```
class C(F, M):

    def drink(self):
        super().drink()
        print("Drink Water")


c = C()
c.drink()
# Drink Beer
# Drink Water

C.mro()
# [<class '__main__.C'>, <class '__main__.F'>, <class '__main__.M'>, <class 'object'>]
```

如果把`C`类改写为如下，可以调用`M`类。
```
class C(F, M):

    def drink(self):
        M.drink(self)
        print("Drink Water")


c = C()
c.drink()
# Drink Red Wine
# Drink Water
```

对于`mro`理解父类与子类的关系，看下面例子，类`F`中的`super().drink()`的`super()`是指谁？原则很简单，`mro`里面类`F`的上一级是类`M`，所以类`F`中的`super()`就是指类`M`。
```
class F():

    def drink(self):
        print("Drink Beer")
        super().drink()


class M():

    def drink(self):
        print("Drink Red Wine")


class C(F, M):
    pass


c = C()
c.drink()
# Drink Beer
# Drink Red Wine

C.mro()
# [<class '__main__.C'>, <class '__main__.F'>, <class '__main__.M'>, <class 'object'>]

```




### 菱形继承和继承关系检测

菱形继承的描述是，类`A`作为基类（这里基类是指非`object`类），类`B`和类`C`同时继承类`A`，然后类`D`又继承类`B`和类`C`，如下图，看起来像个钻石的形状。

```
    A
   / \
  B   C
   \ /
    D
```

在这种结构中，在调用顺序上就会出现疑惑，调用顺序究竟是以下哪一种顺序呢？

* D->B->A->C（深度优先）
* D->B->C->A（广度优先）


看下面代码，在Python3中，**菱形**的多继承关系是按照D->B->C->A**广度优先**的搜索方式。
```
class A():
    pass


class B(A):

    def test(self):
        print("init B.test()")


class C(A):
    
    def test(self):
        print("init C.test()")


class D(B, C):
    pass


d = D()
d.test()
# init B.test()


D.mro()
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

对于下面这种**非菱形**的多继承关系，查找顺序是A->B->E->C->F->D**深度优先**的搜索方式。
```
E     F
|     |
B(E) C(F)  D
|     |    |
 \    |   /
  \   |  /
   A(B,C,D)
```

代码实现：
```
class D():

    def test(self):
        print("init D.test()")


class F():

    def test(self):
        print("init F.test()")


class C(F):
    pass


class E():
    pass


class B(E):
    pass


class A(B, C, D):
    pass


a = A()
a.test()
# init F.test()

A.mro()
# [<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.F'>, <class '__main__.D'>, <class 'object'>]
```


总结：

1. 继承结构要尽量简单，不要过于复杂。
2. 推荐使用minxins机制，在多继承背景下，满足继承的什么是什么的关系（is-a）


### 多继承关系的minxins机制

看下面例子，如果在`Vehicle`类中定义了`fly`的方法，会导致`Car(Vehicle)`的继承关系出现矛盾，汽车并不会飞，但按照上述继承关系，汽车也能飞了。
但是如果民航飞机和直升机都各自写自己的飞行fly方法，又违背了代码尽可能重用的原则。
```
class Vehicle:  # 交通工具

    def fly(self):
        '''
        飞行功能相应的代码        
        '''
        print("I am flying")


# 民航飞机
class CivilAircraft(Vehicle):
    pass


# 直升飞机
class Helicopter(Vehicle):
    pass


# 汽车
class Car(Vehicle):
    pass
```

Python中没有类似Java接口interface的功能，但提供了Mixins机制。

* Python对于`Mixin`类的命名方式一般以 `Mixin`, `able`, `ible`为后缀。
* `Mixin`类必须功能单一，如果有多个功能，那就写多个Mixin类。
* 一个类可以继承多个`Mixin`类，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类
* `Mixin`类不依赖于子类的实现。
* 子类即便没有继承这个`Mixin`类类，也照样可以工作，就是缺少了某个功能。



```
# 交通工具
class Vehicle:
    pass


# 为当前类混入一些功能，不是一个单纯的类
class FlyableMixin:

    def fly(self):
        '''
        飞行功能相应的代码        
        '''
        print("I am flying")


# 民航飞机
class CivilAircraft(FlyableMixin, Vehicle):
    pass


# 直升飞机
class Helicopter(FlyableMixin, Vehicle):
    pass


# 汽车
class Car(Vehicle):
    pass
```







## 多态 Polymorphism

多态意味着相同的函数名用于不同的情形。 如下例，`len()`被用于不同的情形。

```
# len() being used for a string
print(len("geeks"))
# 5

# len() being used for a list
print(len([10, 20, 30]))
# 3

```

### 类方法的多态性

下面的代码展示了 Python 如何以相同的方式使用两种不同的类类型。 我们创建了一个遍历对象元组的 `for` 循环。 然后调用方法而不用关心每个对象是哪个类类型。 我们假设这些方法实际上存在于每个类中。 

```
class India():

    def capital(self):
        print("New Delhi is the capital of India.")

    def language(self):
        print("Hindi is the most widely spoken language of India.")

    def type(self):
        print("India is a developing country.")


class USA():

    def capital(self):
        print("Washington, D.C. is the capital of USA.")

    def language(self):
        print("English is the primary language of USA.")

    def type(self):
        print("USA is a developed country.")


obj_ind = India()
obj_usa = USA()

for country in (obj_ind, obj_usa):
    country.capital()
    country.language()
    country.type()

# New Delhi is the capital of India.
# Hindi is the most widely spoken language of India.
# India is a developing country.
# Washington, D.C. is the capital of USA.
# English is the primary language of USA.
# USA is a developed country.
```

### 继承的多态性

在 Python 中，多态允许我们在子类中定义与父类中的方法同名的方法。 在继承中，子类继承父类的方法。 但是，可以修改从父类继承的子类中的方法。 这在从父类继承的方法不太适合子类的情况下特别有用。 在这种情况下，我们在子类中重新实现该方法。 这种在子类中重新实现方法的过程称为**方法覆盖（Method Overriding）**。 

```
class Bird:

    def intro(self):
        print("There are many types of birds.")

    def flight(self):
        print("Most of the birds can fly but some cannot.")


class sparrow(Bird):

    def flight(self):
        print("Sparrows can fly.")


class ostrich(Bird):

    def flight(self):
        print("Ostriches cannot fly.")


obj_bird = Bird()
obj_spr = sparrow()
obj_ost = ostrich()

obj_bird.intro()
# There are many types of birds.

obj_bird.flight()
# Most of the birds can fly but some cannot.

obj_spr.intro()
# There are many types of birds.

obj_spr.flight()
# Sparrows can fly.

obj_ost.intro()
# There are many types of birds.

obj_ost.flight()
# Ostriches cannot fly.
```

### 函数和对象的多态性

我们也可以创建一个可以接受任何对象的函数，允许多态性。 在下面例子中，我们创建一个名为`func()`的函数，传入参数是`obj`的对象。在这种情况下，我们调用三个方法，即`capital()`、`language()`和`type()`，每个方法都定义在`India`和`USA`两个类中。 我们可以使用相同的 `func()` 函数调用它们的动作：

```
class India():

    def capital(self):
        print("New Delhi is the capital of India.")

    def language(self):
        print("Hindi is the most widely spoken language of India.")

    def type(self):
        print("India is a developing country.")


class USA():

    def capital(self):
        print("Washington, D.C. is the capital of USA.")

    def language(self):
        print("English is the primary language of USA.")

    def type(self):
        print("USA is a developed country.")


def func(obj):
    obj.capital()
    obj.language()
    obj.type()


obj_ind = India()
obj_usa = USA()

func(obj_ind)
# New Delhi is the capital of India.
# Hindi is the most widely spoken language of India.
# India is a developing country.

func(obj_usa)
# Washington, D.C. is the capital of USA.
# English is the primary language of USA.
# USA is a developed country.
```


### 鸭子类型(Ducking Typing)

鸭子类型是多态一种形式。我们可以验证，一个对象如果实现了迭代器协议，那它一定是可以迭代的。

```
def isiterable(obj):
    try:
        iter(obj)
        return True
    except TypeError:
        return False
```

只能输入一个object, 接受多种类型输入。

```
print(isiterable('a string'))  
# True
print(isiterable([1, 2, 3]))  
# True
print(isiterable(5))  
# False
```


## 私有变量 Private Variables

那种仅限从一个对象内部访问的“私有”实例变量（“Private” instance variables）在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有*一个前缀下划线*的名称 (例如`_spam`) 应该被当作是 API 的非公有（non-public）部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。

由于存在对于类私有成员（class-private members）的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为**名称改写（name mangling）**。 任何形式为`__spam`的标识符（至少带有*两个前缀下划线*，至多一个后缀下划线）的文本将被替换为 `_classname__spam`，其中 `classname` 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。

名称改写（Name mangling）有助于让子类重载方法（）override methods而不破坏类内方法（intraclass method）调用。例如:

```
class Mapping:

    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update  # private copy of original update() method


class MappingSubclass(Mapping):

    def update(self, keys, values):
        # provides new signature for update()
        # but does not break __init__()
        for item in zip(keys, values):
            self.items_list.append(item)
```

上面的示例即使在 `MappingSubclass` 引入了一个 `__update` 标识符的情况下也不会出错，因为它会在 Mapping 类中被替换为 `_Mapping__update` 而在 `MappingSubclass` 类中被替换为 `_MappingSubclass__update`。

请注意，改写规则（mangling rules）的设计主要是为了避免意外冲突；访问或修改私有变量仍然是可能的。这在特殊情况下甚至会很有用，例如在调试器（debugger）中。

请注意传递给 `exec()` 或 `eval()` 的代码不会把发起调用类的类名视作当前类；这类似于 `global` 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 `getattr()`, `setattr()` 和 `delattr()`，以及对于 `__dict__` 的直接引用。


## 迭代器 Iterators

在Python中，大多数容器对象（container object）都可以使用 for 语句:

```
for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one': 1, 'two': 2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
```

`for` 语句会在容器对象上调用 iter()。 该函数返回一个定义了 `__next__()` 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，`__next__()` 将引发 `StopIteration` 异常来通知终止 `for` 循环。 可以使用 `next()` 内置函数来调用 `__next__()` 方法；下面这个例子展示了刚刚描述的具体运行方式:

```
>>> s = 'abc'
>>> it = iter(s)
>>> it
<str_iterator object at 0x10c90e650>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
StopIteration
```

在了解了迭代器协议（iterator protocol）的机制后，给类添加迭代器就很容易了。 定义一个 `__iter__()` 方法来返回一个带有 `__next__()` 方法的对象。 如果类已定义了 `__next__()`，则 `__iter__()` 可以简单地返回 `self`:

```
class Reverse:
    """Iterator for looping over a sequence backwards."""

    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]


rev = Reverse('spam')

print(iter(rev))

for char in rev:
    print(char)

# m
# a
# p
# s
```




## 生成器 Generators

**生成器（Generators）**是一个用于创建迭代器的简单而强大的工具。 
它们的写法类似于标准的函数，但当它们要返回数据时会使用 `yield` 语句。 
每次在生成器上调用 `next()` 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 

一个创建生成器的示例如下（改写上面迭代器中所举的例子）:

```
def reverse(data):
    for index in range(len(data) - 1, -1, -1):
        yield data[index]


for char in reverse('golf'):
    print(char)

# f
# l
# o
# g
```

可以用生成器来完成的操作同样可以用前面所描述的基于类的迭代器来完成。但生成器的写法更为紧凑，因为它会自动创建 `__iter__()` 和 `__next__()` 方法。

另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 `self.index` 和 `self.data` 这种实例变量的方式更易编写且更为清晰。

除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 `StopIteration`。 




## 生成器表达式 Generator Expressions

某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 
这种表达式被设计用于生成器将立即被外层函数所使用的情况。 
生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。

示例:

```
>>> sum(i * i for i in range(10))  # sum of squares
285

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x * y for x, y in zip(xvec, yvec))  # dot product
260

>>> unique_words = set(word for line in page  for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
```

















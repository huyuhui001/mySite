# 面向对象三大特性

三大特性：

* 封装
* 继承
* 多态




## 封装 Encapsulation

封装是使用特殊的语法，对成员属性和成员方法进行包装，限制一些访问和操作，达到保护和隐藏的目的。

封装机制保证了类内部数据结构的完整性，因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据，很好地避免了外部对内部数据的影响，提高了程序的可维护性。

对一个类实现良好的封装，用户只能借助暴露出来的类方法来访问数据，可以在这些暴露的方法中加入适当的控制逻辑，即可控制用户对类中属性或方法的操作。

对类进行良好的封装，还可以提高代码的复用性。 


封装的级别：

* 公有的（Public）
* 保护的（Protected）
* 私有的（Private）





## 继承 Inheritance

如果不支持继承，就算不上真正的“类”。派生类（derived class）定义的语法如下所示:

```
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

名称`BaseClassName`必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置，例如，当基类定义在另一个模块中的时候:

```
class DerivedClassName(modname.BaseClassName):
```

派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地（recursively）应用。

派生类的实例化没有任何特殊之处: `DerivedClassName()`会创建该类的一个*新实例*。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。

派生类可能会重写（override）其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，所以调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。

在派生类中的重载方法（overriding method）实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单地直接调用基类方法：即调用`BaseClassName.methodname(self, arguments)`。请注意，仅当此基类可在全局作用域中以`BaseClassName`的名称被访问时方可使用此方式。

Python有两个内置函数可被用于继承机制：

* 使用`isinstance()`来检查一个实例的类型: `isinstance(obj, int)`仅会在`obj.__class__` 为`int`或某个派生自`int`的类时为`True`。
* 使用`issubclass()`来检查类的继承关系:`issubclass(bool, int)`为`True`，因为`bool`是`int`的子类。 但是，`issubclass(float, int)`为`False`，因为`float`不是`int`的子类。


### 多重继承 Multiple Inheritance

Python 也支持一种多重继承。 带有多个基类的类定义语句如下所示:
```
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

在最简单的情况下，搜索从父类所继承属性的操作是深度优先（depth-first）、从左至右（left-to-right）的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在`DerivedClassName`中未找到，则会到`Base1`中搜索它，然后（递归地）到`Base1`的基类中搜索，如果在那里未找到，再到`Base2`中搜索，依此类推。

真实情况更复杂；方法解析顺序会动态改变以支持对`super()`的协同调用。 这种方式在某些其他多重继承型语言中被称为**后续方法调用（call-next-method）**，它比单继承型（single-inheritance）语言中的`uper`调用更强大。

动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（diamond relationships）（即至少有一个父类可通过多条路径被最底层类所访问）。 
例如，所有类都是继承自`object`，因此任何多重继承的情况都提供了一条以上的路径可以通向 `object`。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（monotonic）（即一个类可以被子类化而不影响其父类的优先顺序）。 
总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。

### 菱形继承

### 继承关系检测






## 多态 Polymorphism

多态意味着相同的函数名用于不同的情形。 如下例，`len()`被用于不同的情形。

```
# len() being used for a string
print(len("geeks"))
# 5

# len() being used for a list
print(len([10, 20, 30]))
# 3

```

### 类方法的多态性

下面的代码展示了 Python 如何以相同的方式使用两种不同的类类型。 我们创建了一个遍历对象元组的 `for` 循环。 然后调用方法而不用关心每个对象是哪个类类型。 我们假设这些方法实际上存在于每个类中。 

```
class India():

    def capital(self):
        print("New Delhi is the capital of India.")

    def language(self):
        print("Hindi is the most widely spoken language of India.")

    def type(self):
        print("India is a developing country.")


class USA():

    def capital(self):
        print("Washington, D.C. is the capital of USA.")

    def language(self):
        print("English is the primary language of USA.")

    def type(self):
        print("USA is a developed country.")


obj_ind = India()
obj_usa = USA()

for country in (obj_ind, obj_usa):
    country.capital()
    country.language()
    country.type()

# New Delhi is the capital of India.
# Hindi is the most widely spoken language of India.
# India is a developing country.
# Washington, D.C. is the capital of USA.
# English is the primary language of USA.
# USA is a developed country.
```

### 继承的多态性

在 Python 中，多态允许我们在子类中定义与父类中的方法同名的方法。 在继承中，子类继承父类的方法。 但是，可以修改从父类继承的子类中的方法。 这在从父类继承的方法不太适合子类的情况下特别有用。 在这种情况下，我们在子类中重新实现该方法。 这种在子类中重新实现方法的过程称为**方法覆盖（Method Overriding）**。 

```
class Bird:

    def intro(self):
        print("There are many types of birds.")

    def flight(self):
        print("Most of the birds can fly but some cannot.")


class sparrow(Bird):

    def flight(self):
        print("Sparrows can fly.")


class ostrich(Bird):

    def flight(self):
        print("Ostriches cannot fly.")


obj_bird = Bird()
obj_spr = sparrow()
obj_ost = ostrich()

obj_bird.intro()
# There are many types of birds.

obj_bird.flight()
# Most of the birds can fly but some cannot.

obj_spr.intro()
# There are many types of birds.

obj_spr.flight()
# Sparrows can fly.

obj_ost.intro()
# There are many types of birds.

obj_ost.flight()
# Ostriches cannot fly.
```

### 函数和对象的多态性

我们也可以创建一个可以接受任何对象的函数，允许多态性。 在下面例子中，我们创建一个名为`func()`的函数，传入参数是`obj`的对象。在这种情况下，我们调用三个方法，即`capital()`、`language()`和`type()`，每个方法都定义在`India`和`USA`两个类中。 我们可以使用相同的 `func()` 函数调用它们的动作：

```
class India():

    def capital(self):
        print("New Delhi is the capital of India.")

    def language(self):
        print("Hindi is the most widely spoken language of India.")

    def type(self):
        print("India is a developing country.")


class USA():

    def capital(self):
        print("Washington, D.C. is the capital of USA.")

    def language(self):
        print("English is the primary language of USA.")

    def type(self):
        print("USA is a developed country.")


def func(obj):
    obj.capital()
    obj.language()
    obj.type()


obj_ind = India()
obj_usa = USA()

func(obj_ind)
# New Delhi is the capital of India.
# Hindi is the most widely spoken language of India.
# India is a developing country.

func(obj_usa)
# Washington, D.C. is the capital of USA.
# English is the primary language of USA.
# USA is a developed country.
```


### 鸭子类型(Ducking Typing)

鸭子类型是多态一种形式。我们可以验证，一个对象如果实现了迭代器协议，那它一定是可以迭代的。

```
def isiterable(obj):
    try:
        iter(obj)
        return True
    except TypeError:
        return False
```

只能输入一个object, 接受多种类型输入。

```
print(isiterable('a string'))  
# True
print(isiterable([1, 2, 3]))  
# True
print(isiterable(5))  
# False
```


## 私有变量 Private Variables

那种仅限从一个对象内部访问的“私有”实例变量（“Private” instance variables）在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有*一个前缀下划线*的名称 (例如`_spam`) 应该被当作是 API 的非公有（non-public）部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。

由于存在对于类私有成员（class-private members）的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为**名称改写（name mangling）**。 任何形式为`__spam`的标识符（至少带有*两个前缀下划线*，至多一个后缀下划线）的文本将被替换为 `_classname__spam`，其中 `classname` 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。

名称改写（Name mangling）有助于让子类重载方法（）override methods而不破坏类内方法（intraclass method）调用。例如:

```
class Mapping:

    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update  # private copy of original update() method


class MappingSubclass(Mapping):

    def update(self, keys, values):
        # provides new signature for update()
        # but does not break __init__()
        for item in zip(keys, values):
            self.items_list.append(item)
```

上面的示例即使在 `MappingSubclass` 引入了一个 `__update` 标识符的情况下也不会出错，因为它会在 Mapping 类中被替换为 `_Mapping__update` 而在 `MappingSubclass` 类中被替换为 `_MappingSubclass__update`。

请注意，改写规则（mangling rules）的设计主要是为了避免意外冲突；访问或修改私有变量仍然是可能的。这在特殊情况下甚至会很有用，例如在调试器（debugger）中。

请注意传递给 `exec()` 或 `eval()` 的代码不会把发起调用类的类名视作当前类；这类似于 `global` 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 `getattr()`, `setattr()` 和 `delattr()`，以及对于 `__dict__` 的直接引用。


## 迭代器 Iterators

在Python中，大多数容器对象（container object）都可以使用 for 语句:

```
for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one': 1, 'two': 2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
```

`for` 语句会在容器对象上调用 iter()。 该函数返回一个定义了 `__next__()` 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，`__next__()` 将引发 `StopIteration` 异常来通知终止 `for` 循环。 可以使用 `next()` 内置函数来调用 `__next__()` 方法；下面这个例子展示了刚刚描述的具体运行方式:

```
>>> s = 'abc'
>>> it = iter(s)
>>> it
<str_iterator object at 0x10c90e650>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
StopIteration
```

在了解了迭代器协议（iterator protocol）的机制后，给类添加迭代器就很容易了。 定义一个 `__iter__()` 方法来返回一个带有 `__next__()` 方法的对象。 如果类已定义了 `__next__()`，则 `__iter__()` 可以简单地返回 `self`:

```
class Reverse:
    """Iterator for looping over a sequence backwards."""

    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]


rev = Reverse('spam')

print(iter(rev))

for char in rev:
    print(char)

# m
# a
# p
# s
```




## 生成器 Generators

**生成器（Generators）**是一个用于创建迭代器的简单而强大的工具。 
它们的写法类似于标准的函数，但当它们要返回数据时会使用 `yield` 语句。 
每次在生成器上调用 `next()` 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 

一个创建生成器的示例如下（改写上面迭代器中所举的例子）:

```
def reverse(data):
    for index in range(len(data) - 1, -1, -1):
        yield data[index]


for char in reverse('golf'):
    print(char)

# f
# l
# o
# g
```

可以用生成器来完成的操作同样可以用前面所描述的基于类的迭代器来完成。但生成器的写法更为紧凑，因为它会自动创建 `__iter__()` 和 `__next__()` 方法。

另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 `self.index` 和 `self.data` 这种实例变量的方式更易编写且更为清晰。

除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 `StopIteration`。 




## 生成器表达式 Generator Expressions

某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 
这种表达式被设计用于生成器将立即被外层函数所使用的情况。 
生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。

示例:

```
>>> sum(i * i for i in range(10))  # sum of squares
285

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x * y for x, y in zip(xvec, yvec))  # dot product
260

>>> unique_words = set(word for line in page  for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
```

















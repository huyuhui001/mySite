# Python中的打包Packing和拆包Unpacking

Python 允许变量的元组（或列表）出现在赋值操作的左侧。

元组中的每个变量都可以从赋值右侧的可迭代对象（iterable）中接收一个值（或者更多，如果我们使用 * 运算符）。 Python 中的解包是指一种操作，该操作包括在单个赋值语句中将可迭代的值分配给变量的元组（或列表）。

在 Python 中，可以在赋值运算符 (=) 的左侧放置一个变量元组，在右侧放置一个值元组。 右边的值将根据它们在元组中的位置自动分配给左边的变量。 这在 Python 中通常称为元组解包。

如下示例：
```
>>> (a, b, c) = (1, 2, 3)
>>> a
1
>>> b
2
>>> c
3
>>> birthday = ('April', 5, 2001)
>>> month, day, year = birthday
>>> month
'April'
>>> day
5
>>> year
2001
```

元组解包功能在 Python 中可以扩展为适用于任何可迭代对象。 唯一的要求是可迭代的接收元组（或列表）中的每个变量恰好对应可迭代对象的一个元素（item）。

下面的示例介绍了 Python 中可迭代解包的工作原理：

```
>>> # Unpackage strings
>>> a, b, c = '123'
>>> a
'1'
>>> b
'2'
>>> c
'3'
>>> # Unpacking lists
>>> a, b, c = [1, 2, 3]
>>> a
1
>>> b
2
>>> c
3
>>> # Unpacking generators
>>> gen = (i ** 2 for i in range(3))
>>> a, b, c = gen
>>> a
0
>>> b
1
>>> c
4
>>> # Upacking dictionaries (keys, values, and items)
>>> my_dict = {'one': 1, 'two': 2, 'three': 3}
>>> a, b, c = my_dict
>>> a
'one'
>>> b
'two'
>>> c
'three'
>>> a, b, c = my_dict.values()
>>> a
1
>>> b
2
>>> c
3
>>> a, b, c = my_dict.items()
>>> a
('one', 1)
>>> b
('two', 2)
>>> c
('three', 3)
>>> # Use a tuple on the right side of assignment statement
>>> [a, b, c] = 1, 2, 3
>>> a
1
>>> b
2
>>> c
3
>>> # Use range() iterator
>>> x, y, z = range(3)
>>> x
0
>>> y
1
>>> z
2
```

As a complement, the term packing can be used when we collect several values in a single variable using the iterable unpacking operator.

The * operator is known, in this context, as the tuple (or iterable) unpacking operator. It extends the unpacking functionality to allow us to collect or pack multiple values in a single variable.

In the following example, we pack a tuple of values into a single variable by using the * operator:

打包可以理解为使用可迭代解包运算符在单个变量中收集多个值。在这种情况下， * 运算符被称为元组（或可迭代）解包运算符。 它扩展了解包功能，允许在单个变量中收集或打包多个值。

在以下示例中可以看到 * 运算符将元组值打包到单个变量中： 

```
>>> # The right side is a tuple, the left side is a list
>>> *a, = 1, 2
>>> a
[1, 2]
>>> type(a)
<class 'list'>
```

在上面的代码中，赋值的左侧必须是元组（或列表），这就是使用尾随逗号的原因。这个元组可以包含所需要的尽可能多的变量，但是，它只能包含一个星号表达式(starred expression)。 

```
>>> # Packing trailing values
>>> a, *b = 1, 2, 3
>>> a
1
>>> b
[2, 3]
>>> type(a)
<class 'int'>
>>> type(b)
<class 'list'>
>>> 
>>> *a, b, c = 1, 2, 3
>>> a
[1]
>>> b
2
>>> c
3
>>> *a, b, c, d, e = 1, 2, 3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: not enough values to unpack (expected at least 4, got 3)
>>> *a, b, c, d = 1, 2, 3
>>> a
[]
>>> b
1
>>> c
2
>>> d
3
>>> 
>>> seq = [1, 2, 3, 4]
>>> first, *body, last = seq
>>> first, body, last
(1, [2, 3], 4)
>>> first, body, *last = seq
>>> first, body, last
(1, 2, [3, 4])
>>> 
>>> ran = range(10)
>>> *r, = ran
>>> r
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

下面是一些打包和解包的例子。

```
>>> employee = ['John Doe', '40', 'Software Engineer']
>>> name = employee[0]
>>> age = employee[1]
>>> job = employee[2]
>>> name
'John Doe'
>>> age
'40'
>>> job
'Software Engineer'
>>> 
>>> name, age, job = ['John Doe', '40', 'Software Engineer']
>>> name
'John Doe'
>>> age
'40'
>>> job
'Software Engineer'
>>> 
>>> a = 100
>>> b = 200
>>> a, b = b, a
>>> a
200
>>> b
100
```

使用 * 删除不需要的值。

```
>>> a, b, *_ = 1, 2, 0, 0, 0, 0
>>> a
1
>>> b
2
>>> _
[0, 0, 0, 0]

```

在上例中，不需要的信息存储在虚拟变量 _ 中，在后续的使用中可以忽略它。

默认情况下，Python 解释器使用下划线字符 _ 来存储在交互式会话中运行的语句的结果值。 因此，在这种情况下，使用这个字符来识别虚拟变量可能是模棱两可的。

在函数中返回元组。

```
>>> def powers(num):
...     return num, num ** 2, num ** 3
... 
>>> # Packaging returned values in a tuple
>>> result = powers(3)
>>> result
(3, 9, 27)
>>> # Unpacking returned values to multiple variables
>>> number, square, cube = powers(3)
>>> number
3
>>> square
9
>>> cube
27
>>> *_, cube = powers(3)
>>> cube
27
```

Merging Iterables With the * Operator. The last two examples show that this is also a more readable and efficient way to concatenate iterables. Instead of writing list .

使用 * 运算符合并迭代变量（iterables）。上面两个例子说明，这中方法也是连接迭代变量（iterables）的一种更易读和更有效的方法。

这个方法 `(my_set) + my_list + list(my_tuple) + list(range(1, 4)) + list(my_str)`可以生成一个列表 ，也可以使用更简洁的方法 `[*my_set, *my_list, *my_tuple, *range(1, 4), *my_str]`。

```
>>> my_tuple = (1, 2, 3)
>>> (0, *my_tuple, 4)
(0, 1, 2, 3, 4)
>>> my_list = [1, 2, 3]
>>> [0, *my_list, 4]
[0, 1, 2, 3, 4]
>>> my_set = {1, 2, 3}
>>> {0, *my_set, 4}
{0, 1, 2, 3, 4}
>>> [*my_set, *my_list, *my_tuple, *range(1, 4)]
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> my_str = "123"
>>> [*my_set, *my_list, *my_tuple, *range(1, 4), *my_str]
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, '1', '2', '3']

```

Unpacking Dictionaries With the ** Operator

```
>>> numbers = {'one': 1, 'two': 2, 'three': 3}
>>> letters = {'a': 'A', 'b': 'B', 'c': 'C'}
>>> combination = {**numbers, **letters}
>>> combination
{'one': 1, 'two': 2, 'three': 3, 'a': 'A', 'b': 'B', 'c': 'C'}
```

An important point to note is that, if the dictionaries we're trying to merge have repeated or common keys, then the
values of the right-most dictionary will override the values of the left-most dictionary. Here's an example:

```
>>> letters = {'a': 'A', 'b': 'B', 'c': 'C'}
>>> vowels = {'a': 'a', 'e': 'e', 'i': 'i', 'o': 'o', 'u': 'u'}
>>> {**letters, **vowels}
{'a': 'a', 'b': 'B', 'c': 'C', 'e': 'e', 'i': 'i', 'o': 'o', 'u': 'u'}
>>> {**vowels, **letters}
{'a': 'A', 'e': 'e', 'i': 'i', 'o': 'o', 'u': 'u', 'b': 'B', 'c': 'C'}
```

Unpacking in For-Loops

We can also use iterable unpacking in the context of for loops. When we run a for loop, the loop assigns one item of its
iterable to the target variable in every iteration. If the item to be assigned is an iterable, then we can use a tuple
of target variables. The loop will unpack the iterable at hand into the tuple of target variables.

We can build a list of two-elements tuples. Each tuple will contain the name of the product, the price, and the sold
units. With this information, we want to calculate the income of each product. To do this, we can use a for loop like
this:

```
>>> sales = [('Pencle', 0.22, 1500), ('Notebook', 1.30, 550), ('Eraser', 0.75, 1000)]
>>> for items in sales:
...     print(f"Income for {item[0]} is: {item[1] * item[2]}")
... 
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
NameError: name 'item' is not defined
>>> for items in sales:
...     print(f"Income for {items[0]} is: {items[1] * items[2]}")
... 
Income for Pencle is: 330.0
Income for Notebook is: 715.0
Income for Eraser is: 750.0
```

we're using indices to get access to individual elements of each tuple. This can be difficult to read and to understand
by newcomer developers. We're now using iterable unpacking in our for loop in below sample codes, which is an
alternative implementation using unpacking in Python:

```
>>> sales = [('Pencle', 0.22, 1500), ('Notebook', 1.30, 550), ('Eraser', 0.75, 1000)]
>>> for product, price, sold_units in sales:
...     print(f"Income for {product} is: {price * sold_units}")
... 
Income for Pencle is: 330.0
Income for Notebook is: 715.0
Income for Eraser is: 750.0
```

It's also possible to use the * operator in a for loop to pack several items in a single target variable. In this for
loop, we're catching the first element of each sequence in first. Then the * operator catches a list of values in its
target variable rest.

```
>>> for first, *rest in [(1, 2, 3),(4, 5, 6)]:
...     print('First: ', first)
...     print('Rest: ', rest)
... 
First:  1
Rest:  [2, 3]
First:  4
Rest:  [5, 6]
>>> 
```

Finally, the structure of the target variables must agree with the structure of the iterable. Otherwise, we'll get an
error. Take a look at the following example:

```
>>> data = [((1, 2), 3), ((2, 3), 3)]
>>> for (a, b), c in data:
...     print(a, b, c)
... 
1 2 3
2 3 3
>>> for a, b, c in data:
...     print(a, b, c)
... 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: not enough values to unpack (expected 3, got 2)
```

Defining Functions With * and **

The below function requires at least one argument called `required`. It can accept a variable number of positional and
keyword arguments as well. In this case, the * operator *collects or packs* extra positional arguments in a tuple called
`args` and the ** operator collects or packs extra keyword arguments in a dictionary called `kwargs`. Both, `args`
and `kwargs`, are optional and automatically default to () and {} respectively.

Even though the names `args` and `kwargs` are widely used by the Python community, they're not a requirement for these
techniques to work. The syntax just requires * or ** followed by a valid identifier. So, if you can give meaningful
names to these arguments, then do it. That will certainly improve your code's readability.

```
>>> def func(required, *args, **kwargs):
...     print(required)
...     print(args)
...     print(kwargs)
... 
>>> func('Welcome to ...', 1, 2, 3, site='CloudAcademy.com')
Welcome to ...
(1, 2, 3)
{'site': 'CloudAcademy.com'}
>>> func('Welcome to ...', 1, 2, 3, 4)
Welcome to ...
(1, 2, 3, 4)
{}
>>> func('Welcome to ...', 1, 2, 3, (1, 2))
Welcome to ...
(1, 2, 3, (1, 2))
{}
>>> func('Welcome to ...', 1, 2, 3, [1, 2])
Welcome to ...
(1, 2, 3, [1, 2])
{}
>>> func('Welcome to ...', 1, 2, 3, ([2, 3], [1, 2]))
Welcome to ...
(1, 2, 3, ([2, 3], [1, 2]))
{}
```

Calling Functions With * and **

When calling functions, we can also benefit from the use of the * and ** operator to unpack collections of arguments
into separate positional or keyword arguments respectively. This is the inverse of using * and ** in the signature of a
function. In the signature, the operators mean collect or pack a variable number of arguments in one identifier. In the
call, they mean *unpack* an iterable into several arguments.

Here's a basic example of how this works. The * operator unpacks sequences like `["Welcome", "to"]` into positional
arguments. Similarly, the ** operator unpacks dictionaries into arguments whose names match the keys of the unpacked
dictionary.

```
>>> def func(welcome, to, site):
...     print(welcome, to, site
... 
... )
... 
>>> def func(welcome, to, site):
...     print(welcome, to, site)
... 
>>> func(*['Welcome', 'to'], **{'site': 'CloudAcademy.com'})
Welcome to CloudAcademy.com

```

We can also combine this technique and the one covered in the previous section to write quite flexible functions. The
use of the * and ** operators, when defining and calling Python functions, will give them extra capabilities and make
them more flexible and powerful.

Here's an example:

```
>>> def func(required, *args, **kwargs):
...     print(required)
...     print(args)
...     print(kwargs)
... 
>>> func('Welcome to...', *(1, 2, 3), **{'Site': 'CloudAcademy.com'})
Welcome to...
(1, 2, 3)
{'Site': 'CloudAcademy.com'}
```
Conclusion

Iterable unpacking turns out to be a pretty useful and popular feature in Python. This feature allows us to unpack an
iterable into several variables. On the other hand, packing consists of catching several values into one variable using
the unpacking operator, *.

In this tutorial, we've learned how to use iterable unpacking in Python to write more readable, maintainable, and
pythonic code.

With this knowledge, we are now able to use iterable unpacking in Python to solve common problems like parallel
assignment and swapping values between variables. We're also able to use this Python feature in other structures like
for loops, function calls, and function definitions.

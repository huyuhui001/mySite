# Python的类(Class)

类(class)把数据与功能绑定在一起。创建新类就是创建新的对象类型（type of object），从而创建该类型的新实例（instances）。
类实例具有多种保持自身状态的属性（attributes）。
类实例还支持（由类定义的）修改自身状态的方法（methods）。


Python的类支持所有面向对象编程（OOP）的标准特性：

* 类继承（class inheritance）机制支持多个基类（base classes）；
* 派生类（derived class）可以覆盖基类的任何方法（methods）；
* 类的方法可以调用基类中相同名称的方法
* 对象可以包含任意数量和类型的数据。
* 类（class）和模块（module）都拥有动态特性（dynamic nature）：在运行时创建，创建后也可以修改。


## 名称Names和对象Objects

对象之间相互独立，多个名称（names）（在多个作用域内）可以绑定到同一个对象。 其他语言称之为别名（alias）。
别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针；如果函数修改了作为参数传递的对象，调用者就可以看到更改。


## 作用域Scopes和命名空间Namespaces

**命名空间（namespace）**是一个从名字到对象的映射。 当前大部分命名空间都由 Python 字典实现。 

下面是几个命名空间的例子：

* 存放内置函数的集合（包含`abs()`这样的函数，和内建的异常等）；
* 模块中的全局名称；
* 函数调用中的局部名称；

从某种意义上说，对象的属性集合（the set of attributes of an object）也是一种命名空间的形式。 

关于命名空间的重要一点是，不同命名空间中的名称之间绝对没有关系；
例如，在两个不同的模块中都可以定义一个`maximize`函数而不会产生混淆，但在调用`maximize`函数时必须必须在其前面加上模块名称。

任何跟在一个点号之后的名称都称为**属性（attribute）**。例如，在表达式`z.real`中，`real`是对象`z`的一个属性。

按严格的说法，**对模块（module）中的名称的引用（reference）都属于属性引用（attribute reference）**：
在表达式`modname.funcname`中，`modname`是一个模块对象（module object）而`funcname`是它的一个属性。
在此情况下在模块的属性（module’s attribute）和模块中定义的全局名称之间正好存在一个直观的映射：它们共享相同的命名空间。
但存在一个例外。 模块对象有一个只读属性`__dict__`，它返回用于实现模块命名空间的字典；`__dict__`是属性但不是全局名称。 
使用这个将违反命名空间实现的抽象，应当仅被用于事后调试器之类的场合。

**属性（attribute）**可以是只读或者可写的，所以可以对属性进行赋值，例如`modname.the_answer = 42`。
删除属性可以用del语句，例如，`del modname.the_answer`将会从名为`modname`的对象中移除`the_answer`属性。

命名空间在不同时刻被创建，拥有不同的生存期（lifetimes）。包含内置名称（built-in names）的命名空间是在Python解释器启动时创建的，永远不会被删除。

模块的全局命名空间（global namespace）在模块定义被读入时创建；通常，模块命名空间也会持续到解释器退出。
被解释器的顶层调用（top-level invocation）执行的语句，从一个脚本文件读取或交互式地读取，被认为是`__main__`模块调用的一部分，因此它们拥有自己的全局命名空间。
内置名称（built-in names）实际上也存在于一个模块中，这个模块被称作`builtins`。

一个函数的本地命名空间（local namespace）在这个函数被调用时创建，并在函数返回或抛出一个无法在该函数内部处理的错误时被删除。
每次递归调用（recursive invocations）都会有它自己的本地命名空间。

一个**作用域（scope）**是一个命名空间可直接访问（directly accessible）的Python程序的代码区域。 
这里的 “可直接访问” 意味着不加任何限定的名称引用会在命名空间中进行查找。

虽然作用域是静态地确定的，但它们会被动态地使用。 在代码执行期间的任何时刻，会有3或4个的嵌套作用域供命名空间直接访问:

* 最先搜索的最内部作用域包含局部名称
* 从最近的封闭作用域开始搜索的任何封闭函数的作用域包含非局部名称，也包括非全局名称
* 倒数第二个作用域包含当前模块的全局名称
* 最外面的作用域（最后搜索）是包含内置名称的命名空间

如果一个名称被声明为全局变量，则所有引用和赋值将直接指向该模块全局名称所在的中间作用域。 
如果要重新绑定在最内层作用域以外的变量，可以使用`nonlocal`语句声明为非本地变量。 
如果没有被声明为非本地变量，这些变量将是只读的。给这样的变量赋新值只会在最内层作用域中创建一个*新的*局部变量，而同名的外部全局变量将保持不变。

通常，当前局部作用域（local scope）将引用当前函数作用域的名称（local name）。 在函数作用域以外，当前局部作用域将引用与全局作用域相一致的命名空间：模块的命名空间（the module’s namespace）。

定义一个类，是在本地局部命名空间内建一个新的命名空间。

在一个模块（module ）内定义的函数的作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。 
另一方面，实际的名称搜索是在运行时动态完成的。
但是，Python正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！事实上，局部变量已经是被静态确定了。

如果不存在生效的`global`或`nonlocal`语句，则对名称的赋值总是会进入最内层作用域。赋值不会复制数据，是将名称绑定到对象。 删除也是如此：语句`del x`会从局部作用域所引用的命名空间中移除对`x`的绑定。事实上，所有引入新名称的操作都是使用局部作用域。特别地，`import`语句和函数定义会在局部作用域中绑定模块或函数名称。

`global`语句可被用来表明特定变量存在于全局作用域，并且应当在全局作用域中被**重新**绑定；

`nonlocal`语句表明特定变量生存于外层作用域中，并且应当在其所处的外层作用域中被**重新**绑定。

看下面的例子：

* 局部赋值（local assignment，这是默认状态）不会改变`scope_test`对`spam`的绑定。 
* `nonlocal`赋值会改变`scope_test`对`spam`的绑定。
* `global`赋值会改变模块层级的绑定，即，`global spam`重新绑定了spam的全局定义，从`spam = "spam out of func"`变成了`spam = "global spam"`。如果注释掉def do_global()这一段代码，则`spam = "spam out of func"`起作用。

```
spam = "spam out of func"

def scope_test():

    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)


scope_test()
print("In global scope:", spam)


#  运行结果
# scope_test()
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam

# print("In global scope:", spam)
In global scope: global spam
```




## 类Class

### 类定义 Class Definition

类定义与函数定义 (def 语句) 一样必须被执行才会起作用。
```
class ClassName:
    <statement-1>
    ...
    <statement-N>
```

在实践中，类定义内的语句通常都是函数定义，但也允许有其他语句。在类内部的函数定义通常具有一种特有形式的参数列表，这是约定的方法规范（conventions for methods）。

编译过程中，进入一个类的内部，将创建一个新的命名空间，一个局部作用域。因此，所有对类内部局部变量的赋值都是在这个新的命名空间之内，包括新定义的函数名称。

当正常离开一个类时，编译过程将创建一个类对象（class object），封装了类定义所创建的命名空间里的内容。

最初的（在进入类定义之前起作用的）局部作用域将重新生效，类对象（class object）将在这里被绑定到类定义头部所声明的类名称 (在上面的示例中是`ClassName`)。


### 类对象 Class Objects

类对象支持两种操作：属性引用（attribute references）和实例化（instantiation）。

**属性引用（attribute references）** 使用Python中属性引用的标准语法: `obj.name`。 

存在于类命名空间中的所有名称，类对象被创建时同时被创建了，这些就是有效的属性名称。因此，如果类定义是如下所示，那么`MyClass.i`和`MyClass.f`就是有效的属性引用，将分别返回一个整数和一个函数对象。 

类属性也可以被赋值，因此可以通过赋值来更改`MyClass.i`的值。`__doc__`也是一个有效的属性，将返回所属类的文档字符串: "A simple example class"。

```
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

print(MyClass.i)
# 12345
print(MyClass.__doc__)
# A simple example class

MyClass.i = 10
print(MyClass.i)
# 10
```

类的**实例化（instantiation）**使用函数表示法。 可以把类对象（class object）看作是一个不带参数的函数，这个函数返回了该类的一个新实例。 

在下面的例子中，`x = MyClass()`创建了`MyClass()`这个类的一个实例，并赋值给局部变量`x`。

实例化操作（调用类对象）会创建一个空对象。许多类会创建带有特定初始状态的自定义实例。为此类定义中需要包含一个名为`__init__()`的特殊方法。

当一个类定义了`__init__()`方法时，类的实例化操作会自动为新创建的类实例调用`__init__()`。 更新上面的例子，注意`__dict__`两次返回的不同的字典。复习一下，在命名空间中提到，`__dict__`是属性但不是全局名称，返回用于实现模块命名空间的字典。

```
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

    def __init__(self):
        self.data = []


x = MyClass()
print(x.__dict__)
# {'data': []}

x.i = 10
print(x.__dict__)
# {'data': [], 'i': 10}
```

`__init__()`方法可以有额外的参数输入，在这种情况下，类实例化的参数将被传递给 `__init__()`。 如下例:

```
class Complex:

    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart


x = Complex(3.0, -4.5)

print(x.r, x.i)
# 3.0 -4.5
```



### 实例对象 Instance Objects

对实例对象唯一的操作是属性引用。有两种有效的属性名称：数据属性（data attributes）和方法（methods）。

**数据属性（data attributes）**类似于实例变量，数据属性不需要声明。像局部变量一样，数据属性将在第一次被赋值时产生。 例如，如果`x`是上面创建的`MyClass`的实例，则以下代码段将打印数值`16`，且没有留下关于`x.counter`的痕迹。

```
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

    def __init__(self):
        self.data = []


x = MyClass()

x.counter = 1

while x.counter < 10:
    x.counter = x.counter * 2

print(x.counter)
# 16

print(x.__dict__)
# {'data': [], 'counter': 16}

del x.counter
print(x.__dict__)
# {'data': []}
```

另一类实例属性引用称为**方法（methods）**。 方法是隶属于对象的**函数**。 

在Python中，方法这个术语并不是类实例所特有的，其他对象也可以有方法。 例如，列表对象（list objects）具有append, insert, remove, sort等方法。

*在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外明确说明。*

实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类定义中所包含的所有函数对象（function objects）都称为属性。

因此在上面的示例中，`x.f`是有效的方法引用，因为`MyClass.f`是一个函数，而`x.i`不是方法，因为`MyClass.i`不是函数。但是`x.f`与`MyClass.f`并不是一回事，`x.f`是一个**方法对象**，而`MyClass.f`是一个**函数对象**。差别在于`f()`是否与实例绑定，未绑定，就是函数，绑定，就是方法。

```
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

    def __init__(self):
        self.data = []


x = MyClass()

print(MyClass.f(0))
# hello world
print(x.f())
# hello world

print(MyClass.f)
# <function MyClass.f at 0x7ff9368b3488>
print(x.f)
# <bound method MyClass.f of <__main__.MyClass object at 0x7ff9368acbe0>>

print(type(MyClass.f))
# <class 'function'>
print(type(x.f))
# <class 'method'>
```

这里做个小结：

* 函数(function)是Python中一个可调用对象(callable), 方法(method)是一种特殊的函数。
* 一个可调用对象是方法和函数，和这个对象无关，仅和这个对象是否与类或实例绑定有关（bound method）。
* 静态方法没有和任何类或实例绑定，所以**静态方法是个函数**。




### 方法对象 Method Objects

在 MyClass 示例中，`x.f()`是一个方法对象，被调用后，将返回字符串`'hello world'`。可以立即调用，也可以保存起来以后再调用`xf = x.f`。

虽然`f()`的函数定义指定了一个参数，但上面例子中调用`x.f()`时并没有带参数，也没有引发异常报错。原因在于，**方法(method)的特殊之处就在于实例对象会作为函数的第一个参数被传入。**
调用`x.f()`其实就相当于`MyClass.f(x)`。 
总之，调用一个具有`n`个参数的方法(method)就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，**位置在其他参数之前**。

当一个实例的非数据属性被引用时，将搜索实例所属的类。
如果被引用的属性名称是类中一个有效的函数对象，则会创建一个抽象的对象，通过打包（parking，即指向）匹配到的实例对象和函数对象，这个抽象对象就是方法对象。
当带参数调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并使用这个新参数列表调用相应的函数对象。


### 类和实例变量 Class and Instance Variables

一般来说，**实例变量**用于每个实例的唯一数据，而**类变量**用于类的所有实例共享的属性和方法:

```
class Dog:

    kind = 'canine'  # class variable shared by all instances

    def __init__(self, name):
        self.name = name  # instance variable unique to each instance

d = Dog('Fido')
e = Dog('Buddy')

print(d.kind)  # shared by all dogs
# 'canine'

print(e.kind)  # shared by all dogs
# 'canine'

print(d.name) # unique to d instance
# 'Fido'

print(e.name) # unique to e instance
# 'Buddy'
```

下代码中的`tricks`列表不应该被用作类变量，因为所有的`Dog`实例将只共享一个单独的列表:

```
class Dog:

    kind = 'canine'  # class variable shared by all instances

    tricks = []  # mistaken use of a class variable

    def __init__(self, name):
        self.name = name  # instance variable unique to each instance

    def add_trick(self, trick):
        self.tricks.append(trick)


d = Dog('Fido')
e = Dog('Buddy')

d.add_trick('roll over')
e.add_trick('play dead')

print(d.tricks)
# ['roll over', 'play dead']
```

正确的类设计应该使用实例变量:

```
class Dog:

    kind = 'canine'  # class variable shared by all instances

    def __init__(self, name):
        self.name = name  # instance variable unique to each instance
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)


d = Dog('Fido')
e = Dog('Buddy')

d.add_trick('roll over')
e.add_trick('play dead')

print(d.tricks)
# ['roll over']

print(e.tricks)
# ['play dead']
```

如果同样的属性名称同时出现在实例和类中，则属性查找会**优先选择实例**:

```
class Warehouse:
    purpose = 'storage'
    region = 'west'

w1 = Warehouse()
print(w1.purpose, w1.region)
# storage west

w2 = Warehouse()
w2.region = 'east'  # Instance W2 has higher priority than class
print(w2.purpose, w2.region)
# storage east
```

数据属性（Data attributes）可以被方法（method）以及一个对象的普通用户（ordinary users）（“客户端Client”）所引用。 换句话说，类不能用于实现纯抽象数据类型。

方法的第一个参数常常被命名为`self`，这只是一个约定: `self`这一名称在Python中没有特殊含义。 但是遵循此约定会使得代码具有很好的可读性。

任何一个作为类属性（class attribute）的函数对象（function object）都为该类的实例定义了一个相应方法。 

函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。如下例。现在`f`,`g`和`h`都是类`C`的引用函数对象的属性，因而它们就都是类`C`的实例的方法，其中`h`完全等同于`g`。但请注意，下面这个例子的可读性非常不好。

```
# Function defined outside the class
def f1(self, x, y):
    return min(x, x + y)


class C:
    f = f1  # Assign a function object to a local variable in the class

    def g(self):
        return 'hello world'

    h = g
```

方法（methods）可以通过使用`self`参数的方法属性（method attributes）调用其他方法（method）:

```
class Bag:

    def __init__(self):
        self.data = []

    def add(self, x):
        self.data.append(x)

    def addtwice(self, x):
        self.add(x)
        self.add(x)
```

方法可以通过与普通函数相同的方式引用全局名称。 
与方法相关联的全局作用域就是包含其定义的模块。 （类永远不会被作为全局作用域。） 

虽然我们很少会有充分的理由在方法中使用全局作用域，但全局作用域存在许多合理的使用场景：举个例子，导入到全局作用域的函数和模块可以被方法所使用，在其中定义的函数和类也一样。
通常，包含该方法的类本身是在全局作用域中定义的。


## 继承 Inheritance

如果不支持继承，就算不上真正的“类”。派生类（derived class）定义的语法如下所示:

```
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

名称`BaseClassName`必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置，例如，当基类定义在另一个模块中的时候:

```
class DerivedClassName(modname.BaseClassName):
```

派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地（recursively）应用。

派生类的实例化没有任何特殊之处: `DerivedClassName()`会创建该类的一个*新实例*。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。

派生类可能会重写（override）其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，所以调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。

在派生类中的重载方法（overriding method）实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单地直接调用基类方法：即调用`BaseClassName.methodname(self, arguments)`。请注意，仅当此基类可在全局作用域中以`BaseClassName`的名称被访问时方可使用此方式。

Python有两个内置函数可被用于继承机制：

* 使用`isinstance()`来检查一个实例的类型: `isinstance(obj, int)`仅会在`obj.__class__` 为`int`或某个派生自`int`的类时为`True`。
* 使用`issubclass()`来检查类的继承关系:`issubclass(bool, int)`为`True`，因为`bool`是`int`的子类。 但是，`issubclass(float, int)`为`False`，因为`float`不是`int`的子类。


### 多重继承 Multiple Inheritance

Python 也支持一种多重继承。 带有多个基类的类定义语句如下所示:
```
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

在最简单的情况下，搜索从父类所继承属性的操作是深度优先（depth-first）、从左至右（left-to-right）的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在`DerivedClassName`中未找到，则会到`Base1`中搜索它，然后（递归地）到`Base1`的基类中搜索，如果在那里未找到，再到`Base2`中搜索，依此类推。

真实情况更复杂；方法解析顺序会动态改变以支持对`super()`的协同调用。 这种方式在某些其他多重继承型语言中被称为**后续方法调用（call-next-method）**，它比单继承型（single-inheritance）语言中的`uper`调用更强大。

动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（diamond relationships）（即至少有一个父类可通过多条路径被最底层类所访问）。 
例如，所有类都是继承自`object`，因此任何多重继承的情况都提供了一条以上的路径可以通向 `object`。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（monotonic）（即一个类可以被子类化而不影响其父类的优先顺序）。 
总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。



## 私有变量 Private Variables

那种仅限从一个对象内部访问的“私有”实例变量（“Private” instance variables）在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有*一个前缀下划线*的名称 (例如`_spam`) 应该被当作是 API 的非公有（non-public）部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。

由于存在对于类私有成员（class-private members）的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为**名称改写（name mangling）**。 任何形式为`__spam`的标识符（至少带有*两个前缀下划线*，至多一个后缀下划线）的文本将被替换为 `_classname__spam`，其中 `classname` 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。

名称改写（Name mangling）有助于让子类重载方法（）override methods而不破坏类内方法（intraclass method）调用。例如:

```
class Mapping:

    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update  # private copy of original update() method


class MappingSubclass(Mapping):

    def update(self, keys, values):
        # provides new signature for update()
        # but does not break __init__()
        for item in zip(keys, values):
            self.items_list.append(item)
```

上面的示例即使在 `MappingSubclass` 引入了一个 `__update` 标识符的情况下也不会出错，因为它会在 Mapping 类中被替换为 `_Mapping__update` 而在 `MappingSubclass` 类中被替换为 `_MappingSubclass__update`。

请注意，改写规则（mangling rules）的设计主要是为了避免意外冲突；访问或修改私有变量仍然是可能的。这在特殊情况下甚至会很有用，例如在调试器（debugger）中。

请注意传递给 `exec()` 或 `eval()` 的代码不会把发起调用类的类名视作当前类；这类似于 `global` 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 `getattr()`, `setattr()` 和 `delattr()`，以及对于 `__dict__` 的直接引用。



## 迭代器 Iterators

在Python中，大多数容器对象（container object）都可以使用 for 语句:

```
for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one': 1, 'two': 2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
```

`for` 语句会在容器对象上调用 iter()。 该函数返回一个定义了 `__next__()` 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，`__next__()` 将引发 `StopIteration` 异常来通知终止 `for` 循环。 可以使用 `next()` 内置函数来调用 `__next__()` 方法；下面这个例子展示了刚刚描述的具体运行方式:

```
>>> s = 'abc'
>>> it = iter(s)
>>> it
<str_iterator object at 0x10c90e650>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
StopIteration
```

在了解了迭代器协议（iterator protocol）的机制后，给类添加迭代器就很容易了。 定义一个 `__iter__()` 方法来返回一个带有 `__next__()` 方法的对象。 如果类已定义了 `__next__()`，则 `__iter__()` 可以简单地返回 `self`:

```
class Reverse:
    """Iterator for looping over a sequence backwards."""

    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]


rev = Reverse('spam')

print(iter(rev))

for char in rev:
    print(char)

# m
# a
# p
# s
```




## 生成器 Generators

**生成器（Generators）**是一个用于创建迭代器的简单而强大的工具。 
它们的写法类似于标准的函数，但当它们要返回数据时会使用 `yield` 语句。 
每次在生成器上调用 `next()` 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 

一个创建生成器的示例如下（改写上面迭代器中所举的例子）:

```
def reverse(data):
    for index in range(len(data) - 1, -1, -1):
        yield data[index]


for char in reverse('golf'):
    print(char)

# f
# l
# o
# g
```

可以用生成器来完成的操作同样可以用前面所描述的基于类的迭代器来完成。但生成器的写法更为紧凑，因为它会自动创建 `__iter__()` 和 `__next__()` 方法。

另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 `self.index` 和 `self.data` 这种实例变量的方式更易编写且更为清晰。

除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 `StopIteration`。 




## 生成器表达式 Generator Expressions

某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 
这种表达式被设计用于生成器将立即被外层函数所使用的情况。 
生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。

示例:

```
>>> sum(i * i for i in range(10))  # sum of squares
285

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x * y for x, y in zip(xvec, yvec))  # dot product
260

>>> unique_words = set(word for line in page  for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
```


## 多态 Polymorphism







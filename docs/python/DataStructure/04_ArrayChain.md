# 4.数组和链接结构

数据结构（data structure）或具体数据类型（concrete data type）是指一组数据的内部存储方式。

数组（array）和链接结构（linked structure）这两种数据结构是编程语言里多项集最常用的实现。

目标：

- 创建数组；
- 对数组执行各种操作；
- 确定数组相关操作的运行时和内存的使用情况；
- 基于数组在计算机内存里的不同存储方式，描述数组相关操作的成本和收益；
- 使用单向链接节点创建链接结构；
- 对由单向链接节点构成的链接结构执行各种操作；
- 基于链接结构在计算机内存里的不同存储方式，描述在链接结构上执行相关操作的成本和收益；
- 比较数组和链接结构在运行时和内存使用上的权衡；

## 4.1.数组数据结构

关于数组（array）：

- 数组是指在给定索引位置可以访问和替换的元素序列。
- Python列表的底层数据结构正是一个数组。
- Python中数组的限制要比列表更多。只能在指定位置访问和替换数组中的元素、检查数组的长度、获取它的字符串表达式；不能基于位置添加或删除元素；数组的长度也就是它的容量，在创建之后就是固定的。

### 4.1.1.随机访问和连续内存

通过下标操作或索引操作实现对数组在指定位置对元素进行存储或检索。

数组索引是随机访问（random access）操作，而在随机访问时，计算机总会执行固定的步骤来获取第`i`个元素的位置。因此，不论数组有多大，访问第一个元素所需的时间和访问最后一个元素所需要的时间都是相同的。

计算机通过分配一块连续内存（contiguous memory）单元来存储数组里的元素，从而支持对数组的随机访问。

由于数组里的元素地址都是按照数字顺序进行排列的，因此可以通过添加两个值来计算出数组元素的机器地址，它们是数组的基地址（base address）以及元素的偏移量（offset）。其中，数组的基地址就是第一个元素的机器地址，而元素的偏移量就是它的索引值再乘以一个代表数组元素所需内存单元数的常量（在Python里，这个值始终是1）。

简而言之，Python数组里的索引操作包括下面两个步骤：

- 得到数组内存块的基地址。
- 将索引值添加到这个地址并返回。

### 4.1.2.静态内存和动态内存

在比较老的编程语言（如FORTRAN或Pascal）里，数组是静态数据结构。在这种情况下，数组的长度或容量在编译时就确定了，程序员需要申请足够多的内存来满足在数组里存储可能有最大数量元素的情况，这样做会浪费大量的内存。

像Java和C++这类的现代编程语言会允许程序员创建动态数组（dynamic array），从而为这个问题提供了一种补救方法。和静态数组相似的是，动态数组也会占用一块连续内存，并支持随机访问。动态数组的长度只在运行时才知道，在动态数组实例化的时候指定它的长度。在Python里实现的Array类的行为也是这样的。

我们可以通过另一种方法在运行时根据应用程序的数据要求来调整数组的长度，这些调整会由Python列表自动进行。这时，数组有以下3种不同形式。

- 在程序启动时创建一个具有合理默认大小的数组。
- 当数组无法容纳更多数据时，创建一个更大的新数组，并把旧数组里的数据元素传输给它。
- 如果数组在浪费内存（应用程序删除了一些数据），那么用类似的方式减小数组的长度。

### 4.1.3.物理尺寸和逻辑尺寸

数组的物理尺寸（physical size）是指数组单元的总数，或者创建数组时指定其容量的那个数字；

数组的逻辑尺寸（logical size）是指当前应用程序使用的元素数量。

当数组被填满的时候，我们不需要担心它们的不同。当数组被部分填满的时候，未被填充的内存单元里的数据对当前应用程序是没有用的，我们称之垃圾内容（garbage）。在大多数应用程序里，我们是要注意对数组的物理尺寸和逻辑尺寸进行追踪。通常来说，逻辑尺寸和物理尺寸会反映出有关数组状态的几个重点。

- 如果逻辑尺寸为0，那么数组就为空。也就是说，这个数组不包含任何数据元素。
- 如果并非上述情况，在任何情况下，数组中最后一个元素的索引都是它的逻辑尺寸减1。
- 如果逻辑尺寸等于物理尺寸，那么表示数组已被填满了。

### 4.1.4.练习题

1．请说明随机访问的工作原理，以及这个操作这么快的原因。

解答：随机访问是一种计算机存储系统中的读取或写入数据的操作，其中数据可以通过直接跳转到其存储位置而不需要顺序扫描来访问。这与顺序访问不同，后者需要按顺序遍历数据以找到所需的信息。随机访问的工作原理如下：

- 存储介质：计算机内存和硬盘等存储设备都支持随机访问。这些存储介质中的数据通常被划分为块或扇区，并且每个块或扇区都有一个唯一的地址或索引。
- 访问地址：为了进行随机访问，计算机需要知道要访问的数据的地址。这个地址可以是内存中的特定位置，也可以是硬盘上的某个扇区的地址。
- 寻址和传输：计算机使用存储设备的控制器或存储器管理单元来查找数据的地址。一旦找到了正确的地址，存储设备会将数据传输到计算机的内存中供处理器使用。
- 访问速度：随机访问之所以如此快速，是因为计算机内存和现代硬盘驱动器等存储设备都经过了优化，可以快速响应访问请求。这些设备使用了高速缓存、读写头、寻道机构等技术来最小化数据访问的延迟。

原因：

- 存储设备的物理结构：计算机内存和硬盘等存储设备的物理结构被设计成可以随机访问的。内存中的每个地址都可以瞬间访问，而硬盘上的扇区也可以通过磁头寻道和旋转磁盘等机制迅速访问。
- 高速缓存：现代计算机内存和处理器都配备了高速缓存（例如，CPU缓存）。这些高速缓存存储了最近访问的数据，可以快速提供给处理器，从而降低了访问延迟。
- 存储器管理：操作系统和存储设备的控制器会管理存储器的访问，以确保数据可以高效地被访问和传输。这包括了磁盘调度算法、内存分页等策略。
- 技术进步：硬件制造技术的进步和存储设备的优化使得随机访问速度更快。例如，固态硬盘（SSD）的出现显著提高了数据的随机访问速度。

总之，随机访问之所以如此快速，是因为计算机内存和存储设备的物理和技术特性使其能够以高效、迅速的方式访问数据。这种访问速度对于计算机的性能和响应时间至关重要。

2．数组和Python列表之间有什么区别？

解答：数组和Python列表之间有几个关键区别，这些区别在数据结构、功能和用途上存在差异：

- 数据类型：
      - 数组：通常要求所有元素具有相同的数据类型。这是因为数组在内存中以紧凑的方式存储数据，需要知道每个元素的大小以便进行随机访问。
      - Python列表：Python的列表可以容纳不同数据类型的元素，因为它们是动态类型的。
- 内存管理：
      - 数组：通常在创建时需要指定固定大小，因此在内存中会分配一块连续的空间，这使得数组对于高效的随机访问非常适用。
      - Python列表：Python的列表是动态的，它们可以根据需要自动扩展或缩小。这导致了一些额外的内存开销，因为列表需要更多的空间来管理元素的添加和删除。
- 性能：
      - 数组：由于内存布局连续，因此数组通常在访问元素时更快。数组还支持更多的底层操作，如位操作。
      - Python列表：Python列表更加灵活，但在某些情况下可能会导致性能下降，特别是当涉及大量元素的插入和删除操作时。
- 操作和方法：
      - 数组：通常提供一组基本操作，如读取和写入元素，以及一些数学运算，如向量化操作。
      - Python列表：Python列表提供了更丰富的方法和操作，包括元素的插入、删除、追加、切片、连接等。
- 语言依赖性：
      - 数组：数组通常是编程语言的一部分，具有固定的语法和语义。
      - Python列表：Python的列表是Python标准库的一部分，与Python的动态特性相适应。
- 适用场景：
      - 数组：适用于需要高效随机访问的情况，如数值计算、图像处理等。
      - Python列表：适用于更广泛的应用，特别是在编写Python代码时，因为它们更灵活且易于使用。

总之，数组和Python列表都有自己的优势和适用场景。选择使用哪种数据结构取决于具体的需求和编程语言。在Python中，通常会优先选择使用列表，因为它们更方便，而在其他编程语言中，如C或Java，数组可能更为常见。

在这里需要说明一个概念。在Python中，术语"数组"通常指的是NumPy库中的数组对象，而"列表"指的是Python的内置列表（list）数据结构。这两者之间有以下区别：

- 数据类型：
      - 数组（NumPy数组）：NumPy库提供了一个多维数组对象，它可以包含相同数据类型的元素，并支持高级数学、科学和工程计算。NumPy数组的元素类型通常是固定的，例如，可以是整数、浮点数、复数等。这些数组是高性能的，支持向量化操作。
      - 列表（Python列表）：Python的内置列表是一种通用的、动态类型的数据结构，可以包含不同数据类型的元素，例如整数、浮点数、字符串、对象等。列表可以动态扩展和缩小，并提供了丰富的内置方法和操作。
- 性能：
      - 数组（NumPy数组）：NumPy数组通常比Python列表更高效，特别是在进行数值计算和科学计算时。它们内部使用了C语言实现，支持向量化操作，因此在大规模数据处理中通常更快。
      - 列表（Python列表）：Python列表虽然灵活，但性能相对较低，不适合大规模的数值计算。它们的元素类型可以不同，这意味着需要更多的内存和处理时间来管理元素。
- 库依赖：
      - 数组（NumPy数组）：使用NumPy库需要安装NumPy模块。NumPy是Python中用于数值计算的核心库，广泛应用于科学计算、机器学习等领域。
      - 列表（Python列表）：Python的内置列表是Python标准库的一部分，无需额外安装。
- 功能：
      - 数组（NumPy数组）：NumPy数组提供了许多数学和科学计算函数，如线性代数、傅立叶变换、统计分析等。它们适用于处理大量数值数据。
      - 列表（Python列表）：Python列表提供了通用的数据容器，用于存储和管理各种类型的数据，但不提供专门的数学和科学计算功能。

如果需要进行数值计算、科学计算或数据分析，通常会使用NumPy数组。如果只是需要一个通用的数据容器，用于存储和管理数据，那么Python列表通常足够了。

3．请说明数组的物理尺寸和逻辑尺寸之间的区别。

解答："物理尺寸"和"逻辑尺寸"通常用于描述数据结构中的两个不同方面：

- 物理尺寸（Physical Size）：
      - 物理尺寸是指数据结构实际占用的内存空间或存储介质中的空间大小。
      - 它表示数据结构在计算机内存或磁盘中所占据的实际字节数。
      - 物理尺寸与数据结构的存储方式、数据类型以及计算机架构有关。
- 逻辑尺寸（Logical Size）：
      - 逻辑尺寸是指数据结构中包含的元素数量或数据项的数量。
      - 它表示数据结构内部的元素数量或数据项的个数，不涉及实际的存储大小。
      - 逻辑尺寸通常用于描述数据结构的容量、规模或维度。

这两个概念之间的关系如下：

- 一个数据结构可以具有固定的物理尺寸（占据固定数量的字节），但其逻辑尺寸可以根据实际存储的元素数量而变化。
- 物理尺寸通常是由计算机硬件和操作系统管理的，而逻辑尺寸则是程序员根据数据结构的设计来管理的。

举例来说，一个整数数组可以具有固定的物理尺寸，例如4字节/整数，但它的逻辑尺寸可以是数组中整数的数量，可以是0个、10个、100个等等。因此，逻辑尺寸描述了数组可以容纳的元素数量，而物理尺寸描述了实际占用的内存空间。

在数据结构的设计和使用中，了解和管理物理尺寸和逻辑尺寸对于有效地利用计算机资源非常重要。

## 4.2.数组的操作

Python的`array`模块包含一个叫作`array`的类，它非常类似于列表，但是只能存储数字。我们会定义一个叫作`Array`的新类，使用列表保存元素，存储任何类型的元素。

下面的示例定义了一个数组类`Array`，下面对数组的一些操作的代码实现也已经包含在下面的代码中。其中：

- 数组默认的物理尺寸（也就是容量）是5
- 数组的初始逻辑尺寸是0

```python
class Array(object):
    """描述一个数组。"""

    def __init__(self, capacity, fillValue=None):
        """Capacity是数组的大小.  fillValue会填充在每个元素位置, 默认值是None"""
        # 初始化数组的逻辑尺寸和物理尺寸
        self.logicalSize = 0
        self.capacity = capacity
        self.fillValue = fillValue
        #初始化内部数组，并填充元素值
        self.items = list()
        for count in range(capacity):
            self.items.append(fillValue)

    def __len__(self):
        """返回数组的大小"""
        return len(self.items)

    def __str__(self):
        """将数组字符串化并返回"""
        result = ""
        for index in range(self.size()):
            result += str(self.items[index]) + " "
        return result

    def size(self):
        """返回数组的逻辑尺寸"""
        return self.logicalSize

    def __iter__(self):
        """支持for循环对数组进行遍历."""
        print("__iter__ called")  # 仅用来测试何时__iter__会被调用
        return iter(self.items)

    def __getitem__(self, index):
        """
        用于访问索引处的下标运算符.
        先决条件: 0 <= index < size()
        """
        if index < 0 or index >= self.size():
            raise IndexError("读取操作出错, 数组索引越界(不在数组逻辑边界范围内)")

        return self.items[index]

    def __setitem__(self, index, newItem):
        """
        下标运算符用于在索引处进行替换.
        先决条件: 0 <= index < size()
        """
        if index < 0 or index >= self.size():
            raise IndexError("更新操作出错, 数组索引越界(不在数组逻辑边界范围内)")
        self.items[index] = newItem

    def __eq__(self, other):
        """
        两个数组相等则返回True，否则返回False
        """
        # 判断两个数组是否是同一个对象，注意，不是它们的值是否相等
        if self is other:
            return True
        # 判断两个对象类型是否一样
        if type(self) != type(other):
            return False
        # 判断两个数组大小是否一样
        if self.size() != other.size():
            return False
        # 比较两个数组的值是否一样
        for index in range(self.size()):
            if self[index] != other[index]:
                return False
        return True

    def grow(self):
        """增大数组物理尺寸"""
        # 基于当前物理尺寸加倍，并将fillValue赋值底层列表的新元素
        for count in range(len(self)):
            self.items.append(self.fillValue)

    def insert(self, index, newItem):
        """在数组指定索引处插入新元素"""
        # 当数组的物理尺寸和逻辑尺寸一样时，则增加物理尺寸
        if self.size() == len(self):
            self.grow()
        # 插入新元素
        # 当插入位置大于或等于最大逻辑位置，则在数组末端插入新元素
        # 当插入位置介于数组逻辑位置的中间，则从插入位置起将剩余数组元素向尾部平移一个位置
        if index >= self.size():
            self.items[self.size()] = newItem
        else:
            index = max(index, 0)

            # 将数组元素向尾部平移一个位置
            for i in range(self.size(), index, -1):
                self.items[i] = self.items[i - 1]

            # 插入新元素
            self.items[index] = newItem

        # 增加数组的逻辑尺寸
        self.logicalSize += 1

    def shrink(self):
        """
        减少数组的物理尺寸
        当:
        - 数组的逻辑尺寸小于或等于其物理尺寸的1/4
        - 并且它的物理尺寸至少是这个数组建立时默认容量的2倍时
        则把数组的物理尺寸减小到原来的一半，并且也不会小于其默认容量
        """
        # 在逻辑尺寸和物理尺寸的一半之间选择最大值作为数组收缩后的物理尺寸
        newSize = max(self.capacity, len(self) // 2)
        # 释放多余的数组空间
        for count in range(len(self) - newSize):
            self.items.pop()

    def pop(self, index):
        """
        删除指定索引值的数组元素,并返回删除的数组元素值
        先决条件: 0 <= index < size()
        """
        if index < 0 or index >= self.size():
            raise IndexError("删除操作出错, 数组索引越界(不在数组逻辑边界范围内)")

        # 保存即将被删除的数组元素值
        itemToReturn = self.items[index]

        # 将数组元素向头部平移一个位置
        for i in range(index, self.size() - 1):
            self.items[i] = self.items[i + 1]

        # 将数组尾部的空余位赋值fillValue，默认是None
        self.items[self.size() - 1] = self.fillValue

        # 减少数组逻辑尺寸
        self.logicalSize -= 1

        # 减少数组物理尺寸
        # 当:
        # - 数组的逻辑尺寸小于或等于其物理尺寸的1/4
        # - 并且它的物理尺寸至少是这个数组建立时默认容量的2倍时
        # 则把数组的物理尺寸减小到原来的一半，并且也不会小于其默认容量
        if self.size() <= len(self) // 4 and len(self) > self.capacity:
            self.shrink()

        # 返回被删除元素的值
        print(f'Item {itemToReturn} was deleted')
        return itemToReturn


def main():
    # 初始化空数组
    DEFAULT_CAPACITY = 5
    my_arr = Array(DEFAULT_CAPACITY)

    # 打印输出数组初始信息
    print("Physical size:", len(my_arr))
    print("Logical size:", my_arr.size())
    print("Initial items:", my_arr.items)

    # 初始化数组元素
    print('------')
    for item in range(4):
        my_arr.insert(0, item)  # 在数组头部插入，每插入一次都需要向后移动已有数组元素
    print("Items(logical):", my_arr)
    print("Items(physical):", my_arr.items)

    # 在数组中间插入新元素
    print('------')
    my_arr.insert(3, 99)
    print("Items(logical):", my_arr)
    print("Items(physical):", my_arr.items)

    # 在数组逻辑尺寸外插入新元素
    print('------')
    my_arr.insert(20, 88)
    print("Items(logical):", my_arr)
    print("Items(physical):", my_arr.items)

    # 删除数组元素
    print('------')
    my_arr.pop(3)
    my_arr.pop(3)
    print("Items(logical):", my_arr)
    print("Items(physical):", my_arr.items)

    # 清空数组元素
    print('------')
    for count in range(my_arr.size()):
        my_arr.pop(0)
    print("Items(logical):", my_arr)
    print("Items(physical):", my_arr.items)

    # 数组元素已经全部删除，逻辑尺寸为零，下面命令返回错误
    # print('------')
    # print(my_arr.pop(0))

    # 数组比较
    # 初始化数组
    print('------')
    arr_a = Array(5)
    for item in range(4):
        arr_a.insert(0, item)
    arr_b = arr_a
    arr_c = Array(5)
    for item in range(4):
        arr_c.insert(0, item)
    arr_d = []

    print("arr_a(physical):", arr_a.items)
    print("arr_b(physical):", arr_b.items)
    print("arr_c(physical):", arr_c.items)
    print("arr_d(physical):", arr_d)

    print("arr_a == arr_b:", arr_a == arr_b)
    print("arr_a is arr_b:", arr_a is arr_b)
    print("arr_a == arr_c:", arr_a == arr_c)
    print("arr_a is arr_c:", arr_a is arr_c)

    arr_c.insert(10, 10)
    print("arr_a == arr_c:", arr_a == arr_c)
    arr_c.pop(arr_c.size() - 1)
    arr_c[2] = 6
    print("arr_a == arr_c:", arr_a == arr_c)

    print("arr_a == arr_d:", arr_a == arr_d)


if __name__ == "__main__":
    main()

# 运行结果
# Physical size: 5
# Logical size: 0
# Initial items: [None, None, None, None, None]
# ------
# Items(logical): 3 2 1 0
# Items(physical): [3, 2, 1, 0, None]
# ------
# Items(logical): 3 2 1 99 0
# Items(physical): [3, 2, 1, 99, 0]
# ------
# Items(logical): 3 2 1 99 0 88
# Items(physical): [3, 2, 1, 99, 0, 88, None, None, None, None]
# ------
# Item 99 was deleted
# Item 0 was deleted
# Items(logical): 3 2 1 88
# Items(physical): [3, 2, 1, 88, None, None, None, None, None, None]
# ------
# Item 3 was deleted
# Item 2 was deleted
# Item 1 was deleted
# Item 88 was deleted
# Items(logical):
# Items(physical): [None, None, None, None, None]
# ------
# IndexError: 删除操作出错, 数组索引越界(不在数组逻辑边界范围内)
# ------
# arr_a(physical): [3, 2, 1, 0, None]
# arr_b(physical): [3, 2, 1, 0, None]
# arr_c(physical): [3, 2, 1, 0, None]
# arr_d(physical): []
# arr_a == arr_b: True
# arr_a is arr_b: True
# arr_a == arr_c: True
# arr_a is arr_c: False
# arr_a == arr_c: False
# Item 10 was deleted
# arr_a == arr_c: False
# arr_a == arr_d: False
```

### 4.2.1.增大数组的尺寸

当数组的逻辑尺寸等于它的物理尺寸时，如果要插入新的元素，就需要增大数组的物理尺寸。
如果需要为数组提供更多内存，Python的list类型会在调用insert或append方法时执行这个操作。

调整数组物理尺寸的过程包含如下3个步骤。

- 创建一个更大的新数组。
- 将数据从旧数组中复制到新数组。
- 将指向旧数组的变量指向新数组对象。

下面代码实现。

```python
# 增大数组物理尺寸
if logicalSize == len(my_array):
    temp = Array(len(my_array) + 1)  # 创建一个新数组
    for i in range(logicalSize):
        temp[i] = my_array[i]  # 从原数组复制内容到新数组
    my_array = temp  # 把新数组赋值给原数组
```

在上面代码中，通过`temp[i] = my_array[i]`来调整数组尺寸，这个复制操作的数量是线性增长的。因此，将`n`个元素添加到数组里的总时间复杂度是`1+2+3...+n`，也就是`n(n+1)/2`，因此是`O(n^2)`。

在上面的代码中，通过``temp = Array(len(my_array) + 1)``对数组进行动态扩展，对性能会产生一些可能的影响：

- 时间复杂度：动态扩展数组通常需要复制现有数据到新的内存位置，这将涉及到元素的复制操作。这些操作的时间复杂度取决于数组的长度，通常是`O(n)`，其中`n`是数组的长度。因此，当数组需要扩展时，可能会产生一些额外的时间开销。
- 空间复杂度：动态扩展数组会占用额外的内存空间，因为需要分配新的内存块来容纳扩展后的数组。这可能会导致内存碎片化，特别是在频繁扩展和缩小数组时。
- 扩展频率：扩展数组的频率会影响性能。如果数组需要频繁扩展，那么复制和内存分配的开销会更加显著，从而降低性能。因此，在设计数据结构时，通常会考虑初始容量和扩展策略，以减少不必要的扩展次数。
- Amortized Analysis：一些数据结构，例如Python的列表（list），采用摊还分析来平摊动态扩展的开销。这意味着虽然某些操作可能会花费`O(n)`的时间，但这些开销在一系列操作中被分摊，平均下来仍然保持较低的复杂度。这可以在一定程度上缓解性能问题。

动态扩展数组会引入一些性能开销，但在实际应用中，这种开销通常是可以接受的。为了优化性能，可以考虑以下几点策略，需要根据具体应用的需求和性能要求来权衡这些因素：

- 预先分配足够的初始容量，以减少扩展的频率。
- 使用摊还分析来平摊开销。
- 考虑使用其他数据结构，如链表，对插入和删除操作的性能更加友好。

下面，尝试在每次增大数组尺寸时把数组尺寸翻倍，代码实现如下：

```python
# 增大数组物理尺寸
while logicalSize < DEFAULT_CAPACITY * 2:
    logicalSize += 1
    if logicalSize == len(my_array):  # 触发条件
        temp = Array(len(my_array) + 1)  # 创建一个新数组
        for i in range(logicalSize):
            temp[i] = my_array[i]  # 从原数组复制内容到新数组
        my_array = temp  # 把新数组赋值给原数组
```

将数组尺寸翻倍来扩展数组的方式是一种常见的策略，通常用于减少动态数组的频繁扩展次数，以提高性能。这种方式的操作时间复杂度主要取决于扩展操作的频率和元素的复制成本。

- 摊还分析：对于将数组尺寸翻倍的策略，摊还分析表明，每次扩展操作的摊还时间复杂度仍然是常数时间的（通常是O(1)），这意味着平均下来，每次扩展的开销是固定的，而不会随数组的大小线性增加。
- 操作时间：假设数组需要扩展，那么将数组尺寸翻倍需要分配新的内存块并复制现有元素，这个操作的时间复杂度是O(n)，其中n是数组的当前大小。然而，由于扩展操作不是每次都执行的，而是当数组已满时才执行，因此可以认为这个操作的摊还时间是常数时间，即O(1)。
- 空间复杂度：将数组尺寸翻倍会占用额外的内存空间，但随着数组的增长，额外内存的占用相对于数组本身的大小来说是有限的。通常情况下，这种占用可以接受。

总结，将数组尺寸翻倍的策略可以显著减少动态数组的扩展次数，从而提高性能。虽然每次扩展操作可能会花费一些时间和额外内存，但这些开销在一系列操作中被平摊，平均下来是常数时间。这是一种高效的动态数组实现方式，常见于许多编程语言的标准库中，包括Python的列表（list）。

在增加数组的长度时，每次增加一个内存单元，与每次增大数组尺寸时把数组尺寸翻倍相比，后者的方法通常更高效。

- 每次增加一个内存单元：这种方式在每次添加新元素时都需要分配额外的内存，导致数组尺寸的增长是线性的。如果频繁添加元素，这将导致大量的内存分配和数据复制操作，因此时间复杂度会变得相对较高。
- 每次增大数组尺寸时把数组尺寸翻倍：这是一种更高效的策略。在这种方式下，每次扩展操作都会增加数组的尺寸，但增幅是指数级的，而不是线性的。这意味着随着数组的增长，扩展操作的频率会减少，因为数组能够容纳更多元素。这样，虽然每次扩展操作需要复制更多的元素，但它们的摊还时间复杂度仍然是常数时间，因为它们不是每次都执行的。

总结，将数组尺寸翻倍的策略通常更高效，因为它可以减少频繁的内存分配和复制操作，降低了时间复杂度。这是许多动态数组实现的常见做法，包括Python的列表（list）。

在`Array`类实现中，是通过下面代码段实现的数组物理尺寸增加的，即将数组尺寸翻倍。

```python
    def grow(self):
        """增大数组物理尺寸"""
        # 基于当前物理尺寸加倍，并将fillValue赋值底层列表的新元素
        for count in range(len(self)):
            self.items.append(self.fillValue)
```

### 4.2.2.减小数组的尺寸

如果减小数组的逻辑尺寸，就会浪费相应的内存单元。因此，当删除某一个元素，如果未使用的内存单元数达到或超过了某个阈值（如数组物理尺寸的3/4）时，则应该减小物理尺寸了。如果浪费的内存超过特定阈值，那么Python的list类型会在调用`pop`方法时执行减小数组物理尺寸的操作。

减小数组尺寸的过程与增大数组尺寸的过程相反，步骤如下：

- 创建一个更小的新数组。
- 将数据从旧数组中复制到新数组。
- 将指向旧数组的变量指向新数组对象。

下面的代码实现了减小数组尺寸。

当数组的逻辑尺寸小于或等于其物理尺寸的1/4，并且它的物理尺寸至少是这个数组建立时默认容量的2倍时，则下面的算法把数组的物理尺寸减小到原来的一半，并且也不会小于其默认容量。

```python
# 减小数组物理尺寸
while logicalSize > len(my_array) // 4:
    logicalSize -= 1
    if logicalSize <= len(my_array) // 4 and len(my_array) >= DEFAULT_CAPACITY * 2:  # 触发条件
        temp = Array(len(my_array) // 2)  # 创建一个新数组
        for i in range(logicalSize):
            temp[i] = my_array[i]  # 从原数组复制内容到新数组
        my_array = temp  # 把新数组赋值给原数组
```

按照上面算法减少数组的尺寸，我们可以分析其时间和空间复杂度如下：

时间复杂度：主要涉及两个操作：

- 创建新数组并将元素从旧数组复制到新数组；
- 将旧数组引用更改为新数组。

复制操作的时间复杂度取决于数组的物理尺寸，可以表示为`O(n)`，其中`n`是数组的当前物理尺寸。引用更改是一个常数时间操作，不影响时间复杂度。所以，整体的时间复杂度是`O(n)`。

空间复杂度：空间复杂度也涉及两个方面：

- 创建新数组的内存消耗，其空间复杂度是O(N)；
- 引用更改所需的常数额外空间，通常忽略不计。

所以，总的空间复杂度是`O(n)`。

这个算法策略会在适当的时候减小数组的物理尺寸，以减少内存占用，但仍然保持着数组的动态性。时间复杂度和空间复杂度都与当前数组的物理尺寸成线性关系，因此是线性的，这是一种有效的策略来优化内存使用。同时，保留了一定的冗余空间，以避免频繁地扩展和缩小数组，从而提高了性能。

下面是在`Array`类中实现减小数组的物理尺寸的代码。

```python
    def shrink(self):
        """
        减少数组的物理尺寸
        当:
        - 数组的逻辑尺寸小于或等于其物理尺寸的1/4
        - 并且它的物理尺寸至少是这个数组建立时默认容量的2倍时
        则把数组的物理尺寸减小到原来的一半，并且也不会小于其默认容量
        """
        # 在逻辑尺寸和物理尺寸的一半之间选择最大值作为数组收缩后的物理尺寸
        newSize = max(self.capacity, len(self) // 2)
        # 释放多余的数组空间
        for count in range(len(self) - newSize):
            self.items.pop()
```

### 4.2.3.将元素插入增大的数组

把元素插入数组中和替换数组里的元素是不一样的。

替换数组元素时，元素已在一个给定的索引位置，对这个位置进行简单复制即可，数组的逻辑尺寸并不会改变。

插入数组元素时，需要完成下面4个步骤：

- 在插入元素之前先检查可以使用的空间，根据需要来增大数组的物理尺寸。
- 将数组里从逻辑结尾到目标索引的所有元素向后移动。这个过程会在目标索引位置处为新元素留下一个空格。
- 将新元素分配到目标索引位置。
- 将逻辑尺寸加1。

### 4.2.4.从数组里删除元素

### 4.2.5.复杂度的权衡：时间、空间和数组

### 4.2.6.练习题

1．请说明为什么插入或删除给定元素时必须要移动数组里的某些元素。

2．在插入过程中，移动数组元素时，要先移动哪个元素？先移动插入位置的元素，还是最后一个元素？为什么？

3．如果插入位置是数组的逻辑末尾，请说明这个插入操作的运行时复杂度。

4．假设数组当前包含14个元素，它的负载因子为0.70，那么它的物理容量是多少？

## 4.3.二维数组（网格）

### 4.3.1.使用网格

### 4.3.2.创建并初始化网格

### 4.3.3.定义Grid类

### 4.3.4.参差不齐的网格和多维数组

### 4.3.5.练习题

1．什么是二维数组（网格）？

2．请描述一个可能会用到二维数组的应用程序。

3．编写一个程序，使之可以在Grid对象里搜索一个负整数。循环应该在遇到网格里的第一个负整数的地方终止，这时变量row和column应该被设置为这个负数的位置。如果在网格里找不到负数，那么变量row和column应该等于网格的行数和列数。

4．说说运行下面这段代码后网格里的内容是什么。

```python
matrix = Grid(3, 3)
for row in range(matrix.getHeight()):
     for column in range(matrix.getWidth()):
         matrix[row][column] = row * column
```

5．编写一段代码以创建一个参差不齐的网格，它的行分别用来存储3个、6个和9个元素。

6．提供一个把Grid类用作数据结构来实现三维array类的策略。

7．编写一段代码：这段代码会把三维数组里每个单元的值都初始化为它的3个索引位置。例如，如果位置是（深度、行、列），则对于位置（2、3、3）来说，它的值就是233。

8．编写一段代码：这段代码可以显示出三维数组里的所有元素。打印出的每一行数据都应该代表给定行和列里的所有元素，而深度将从第一个位置向后递归到最后一个位置。遍历应该从第1行、第1列以及第一个深度位置开始，依次遍历所有的深度、列和行。

## 4.4.链接结构

### 4.4.1.单向链接结构和双向链接结构

### 4.4.2.非连续内存和节点

### 4.4.3.定义单向链接节点类

### 4.4.4.使用单向链接节点类

### 4.4.5.练习题

1．用框和指针绘制测试程序里第一个循环所创建的节点的示意图。

2．当节点变量引用的是None时，如果程序员尝试访问节点的数据字段，则会发生什么？如何防止这种情况的发生？

3．编写一段代码：这段代码会把一个被填满的数组里的元素都转移为单向链接结构里的数据。这个操作应保留元素的顺序不变。

## 4.5.单向链接结构上的操作

### 4.5.1.遍历

### 4.5.2.搜索

### 4.5.3.替换

### 4.5.4.在开始处插入

### 4.5.5.在结尾处插入

### 4.5.6.在开始处删除

### 4.5.7.在结尾处删除

### 4.5.8.在任意位置处插入

### 4.5.9.在任意位置处删除

### 4.5.10.复杂度的权衡：时间、空间和单向链接结构

### 4.5.11.练习题

1．假设已经找到了从单向链接结构里删除元素的位置，请说明从这个时候开始完成删除操作的运行时复杂度。

2．可以对单向链接结构里按顺序排列的元素执行二分搜索吗？如果不可以，为什么？

3．请说明为什么Python列表会使用数组而不是链接结构来保存它的元素。

## 4.6.链接上的变化

### 4.6.1.包含虚拟头节点的环状链接结构

### 4.6.2.双向链接结构

### 4.6.3.练习题

1．包含虚拟头节点的环状链接结构给程序员带来了什么好处？

2．和单向链接结构相比，请描述双向链接结构的一个好处和一个额外开销。

## 4.7.小结

- 数据结构是一个表示多项集里所包含数据的对象。
- 数组是一种在常数时间内支持对位置逐项随机访问的数据结构。在创建数组时，会为它分配若干个用来存放数据的内存空间，并且数组的长度会保持不变。插入和删除操作需要移动数据元素，并且可能需要创建一个新的、更大或更小的数组。
- 二维数组里的每个数据值都位于矩形网格的行和列上。
- 链接结构是由0个或多个节点组成的数据结构。每个节点都包含一个数据元素和一个或多个指向其他节点的链接。
- 单向链接结构的节点包含数据元素和到下一个节点的链接。双向链接结构里的节点还包含到前一个节点的链接。
- 在链接结构里进行插入或删除操作不需要移动数据元素，每次最多只会创建一个节点。但是，在链接结构里执行插入、删除和访问操作需要的时间复杂度都是线性的。
- 在链接结构里使用头节点可以简化某些操作，如添加或删除元素。

## 4.8.复习题

1．数组和链接结构都是：

- 抽象数据类型（ADT）
- 数据结构

2．数组的长度：

- 在创建之后大小是固定的
- 在创建之后大小可以增加或减少

3．在数组里进行随机访问支持在：

- 常数时间里访问数据
- 线性时间里访问数据

4．单向链接结构里的数据包含在：

- 单元里
- 节点里

5．对单向链接结构执行的大多数操作都需要：

- 常数时间
- 线性时间

6．从以下哪种类型里删除第一个元素需要常数时间：

- 数组
- 单向链接结构

7．在下面哪种情况下，数组里使用的内存会少于单向链接结构的：

- 不到一半的位置放置了数据
- 一半以上的位置放置了数据

8．当数组的内存不足以保存数据时，最好创建一个新的数组，这个新数组应该：

- 大小比旧数组多1个位置
- 大小是旧数组的2倍

9．对于单向链接结构，当你在什么地方执行插入操作会得到最坏情况下的运行时：

- 在结构的开头
- 在结构的末尾

10．双向链接结构让程序员可以移动到：

- 给定节点的后一个节点或前一个节点
- 给定节点的后一个节点

## 4.9.编程练习

在前6个项目里，你将修改在本章定义的Array类，从而让它更像Python的list类。对于这些项目的答案，请包含你对Array类所做修改的代码测试。

1．为Array类添加一个实例变量`logicalSize`。这个变量的初始值为`0`，用来记录数组里当前已经包含的元素数量。然后为Array类添加`size()`方法，这个方法用来返回数组的逻辑尺寸。`__len__`方法依然会返回数组的容量，也就是它的物理尺寸。

2．为Array类的`__getitem__`和_`_setitem__`方法添加先验条件。它们的先验条件是`0<=index < size()`。如果不满足先验条件，就引发异常。

3．将`grow`和`shrink`方法添加到Array类。它们能够基于本章所讨论的策略来增加或减少数组里所包含的列表长度。在实现时，要保证数组的物理尺寸不会缩小到用户指定的容量之下，并且在增加数组尺寸时，数组的内存单元将会用默认值来填充。

4．将方法`insert`和`pop`添加到Array类中。它们基于本章已经讨论过的策略，在需要的时候对数组的长度进行调整。`insert`方法会接收一个位置和一个元素值作为参数，然后把这个元素插入指定的位置。如果位置大于或等于数组的逻辑尺寸，那么这个方法会把元素插入数组里当前可获得的最后一个元素之后。`pop`方法会接收一个位置作为参数，然后删除并返回这个位置的元素。`pop`方法的先验条件是`0<=index < size()`。`pop`方法还应该把腾出来的数组内存单元重置为填充值。

5．将方法`__eq__`添加到Array类中。当Array对象作为`==`运算符的左操作数时，Python会运行这个方法。如果这个方法的参数也是一个Array对象，并且它的逻辑尺寸和左操作数相同，且在两个数组里每个逻辑位置上的元素都相等，那么这个方法会返回`True`；否则，这个方法返回`False`。

6．为了让Array类和列表一样，应该删除`__iter__`方法的当前实现。请解释这为什么是一个好建议，并说明在这个情况下应该如何对`__str__`方法进行修改。

7．`Matrix`类可以执行线性代数里的某些运算，比如矩阵运算。开发一个使用内置运算符进行算术运算的`Matrix`类，这个`Matrix`类应扩展自`Grid`类。在接下来的4个项目里，你应定义一些用来操作链接结构的函数。在解答的过程中，你应该继续使用本章定义的`Node`和`TwoWayNode`类。创建一个测试模块以包含你的函数定义和用来测试它们的代码。

8．定义一个叫作`length`的函数（不是`len`），这个函数会接受一个单向链接结构作为参数，并能够返回结构里的元素数量。

9．定义一个叫作`insert`的函数，这个函数具有把元素插入单向链接结构中指定位置的功能。这个函数有3个参数：元素、位置以及一个链接结构（这个链接结构可能为空）。这个函数能够返回修改之后的链接结构。如果传递的位置大于或等于链接结构的长度，那么这个函数会把元素插入它的末尾。这个函数的调用示例是`head =insert(1,data,head)`，其中`head`是一个变量，这个变量要么为空链接，要么指向链接结构的第一个节点。

10．定义一个叫作`pop`的函数，这个函数能够在单向链接结构的指定位置上删除元素。这个函数的第一个参数是位置，它的先验条件是`0<=position<结构的长度`。它的第二个参数是一个链接结构，很明显它不应该为空。这个函数将会返回一个元组，包含修改后的链接结构和删除的元素。它的调用示例是`(head, item) = pop(1,head)`。

11．定义一个函数`makeTwoWay`，这个函数会接受一个单向链接结构作为参数，然后生成并返回一个包含单向链接结构里的元素的双向链接结构。（注意：这个函数不应该对作为参数的链接结构进行任何修改。）
